<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Induction: The Trap</title>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        /* CONTROLS AREA */
        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        /* NAVIGATION FOOTER */
        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        /* NEXT BUTTON STYLING FIX */
        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            border: none;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
            transform: none;
            animation: none;
        }

        /* MAIN CANVAS */
        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Simulation: Induction & The Dipole</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- 1. Introduce Rod -->
            <div class="control-row" id="ctrl-rod">
                <label>Step 1: The Influence</label>
                <button id="btn-rod" onclick="introduceRod()">Bring Negative Rod</button>
            </div>

            <!-- 2. Separate Spheres -->
            <div class="control-row" id="ctrl-sep">
                <label>Step 2: The Trap</label>
                <button id="btn-sep" onclick="separateSpheres()">Separate Spheres</button>
            </div>

            <!-- 3. Remove Rod -->
            <div class="control-row" id="ctrl-remove">
                <label>Step 3: Isolation</label>
                <button id="btn-remove" onclick="removeRod()">Remove Rod</button>
            </div>

            <!-- Reset -->
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Experiment Control</label>
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Laboratory Frame</div>
    </main>

    <script type="module">
        import * as THREE from 'three';

        // ==========================================
        // GLOBALS
        // ==========================================
        let currentChapter = 0;

        const state = {
            rodNear: false,
            spheresSeparated: false,
            rodRemoved: false,
            time: 0
        };

        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================
        const scene = new THREE.Scene();
        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 35;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );

        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('world').appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Floor (Grid)
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({
            color: 0x222222,
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -6;
        floor.receiveShadow = true;
        scene.add(floor);
        scene.background = new THREE.Color(0x151515);

        const gridHelper = new THREE.GridHelper(100, 20, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -5.9;
        scene.add(gridHelper);

        // ==========================================
        // PART 2: LABORATORY EQUIPMENT
        // ==========================================

        // --- MATERIALS ---
        const metalMat = new THREE.MeshStandardMaterial({ color: 0xbdc3c7, roughness: 0.3, metalness: 0.8 });
        const standMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.9 });
        const rubberMat = new THREE.MeshStandardMaterial({ color: 0x2f3640, roughness: 0.9 });
        const electronMat = new THREE.MeshStandardMaterial({ color: 0x54a0ff, emissive: 0x2980b9, emissiveIntensity: 0.5 });
        const protonMat = new THREE.MeshStandardMaterial({ color: 0xff6b6b, emissive: 0xc0392b, emissiveIntensity: 0.5 });

        // --- SPHERES ---
        const sphereRadius = 3.5;

        function createSphereSetup(xPos) {
            const group = new THREE.Group();

            // The Metal Sphere
            const geo = new THREE.IcosahedronGeometry(sphereRadius, 2);
            const mesh = new THREE.Mesh(geo, metalMat);
            mesh.castShadow = true;
            group.add(mesh);

            // Insulating Stand
            const poleGeo = new THREE.CylinderGeometry(0.3, 0.3, 8, 8);
            const pole = new THREE.Mesh(poleGeo, standMat);
            pole.position.y = -4;
            pole.castShadow = true;

            const baseGeo = new THREE.CylinderGeometry(2, 2, 0.5, 16);
            const base = new THREE.Mesh(baseGeo, standMat);
            base.position.y = -8;
            base.receiveShadow = true;

            group.add(pole, base);
            group.position.set(xPos, 0, 0);
            return { group, mesh };
        }

        const sphereA = createSphereSetup(-3.6); // Left Sphere
        const sphereB = createSphereSetup(3.6);  // Right Sphere
        scene.add(sphereA.group, sphereB.group);

        // --- THE CHARGED ROD ---
        const rodGroup = new THREE.Group();
        const rodGeo = new THREE.CapsuleGeometry(1, 12, 4, 8);
        const rodMesh = new THREE.Mesh(rodGeo, rubberMat);
        rodMesh.rotation.z = Math.PI / 2;
        rodMesh.castShadow = true;
        rodGroup.add(rodMesh);

        // Rod charge indicators
        function createTextSprite(text, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 40px Arial';
            ctx.fillStyle = color;
            ctx.textAlign = "center";
            ctx.fillText(text, 32, 45);
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, depthTest: false });
            const sprite = new THREE.Sprite(mat);
            return sprite;
        }

        for (let i = -5; i <= 5; i += 2) {
            const sign = createTextSprite("-", "#54a0ff");
            sign.position.set(i, 1.2, 0);
            sign.scale.set(1.5, 1.5, 1);
            rodGroup.add(sign);
        }
        rodGroup.position.set(-25, 0, 0);
        scene.add(rodGroup);

        // --- CHARGE PARTICLES ---
        const electrons = [];
        const positiveHoles = [];
        const particleRadius = 0.4;

        // 1) <--- EDITED: CHANGE THIS VALUE TO EDIT RADIUS OF DISTRIBUTION
        // 3.5 = On Surface. 4.0 = Floating above.
        const particleSurfaceOffset = 3.5;

        function createParticle(isNeg) {
            const geo = new THREE.IcosahedronGeometry(particleRadius, 0);
            const mesh = new THREE.Mesh(geo, isNeg ? electronMat : protonMat);
            return mesh;
        }

        function randomPointOnSurface(radius) {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);

            // Fix r to be surface radius exactly
            const r = radius;
            const sinPhi = Math.sin(phi);

            return new THREE.Vector3(
                r * sinPhi * Math.cos(theta),
                r * sinPhi * Math.sin(theta),
                r * Math.cos(phi)
            );
        }

        // Initialize random positions
        for (let i = 0; i < 40; i++) {
            const e = createParticle(true);
            const targetSphere = Math.random() > 0.5 ? sphereA.group : sphereB.group;

            const pos = randomPointOnSurface(particleSurfaceOffset);

            e.position.copy(pos).add(targetSphere.position);
            e.userData = {
                homeSphere: targetSphere === sphereA.group ? 'A' : 'B',
                offset: pos
            };
            scene.add(e);
            electrons.push(e);
        }

        for (let i = 0; i < 20; i++) {
            const p = createParticle(false);
            const pos = randomPointOnSurface(particleSurfaceOffset);
            p.position.copy(pos).add(sphereA.group.position);
            p.visible = false;
            p.userData = { offset: pos };
            scene.add(p);
            positiveHoles.push(p);
        }

        // ==========================================
        // PART 3: ANIMATION LOOP
        // ==========================================

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.05;

            // 2) <--- EDITED: SHARED SPEED FOR SYNC
            // This ensures electrons move at the same speed as the sphere
            const motionSpeed = 0.08;

            // Rod Logic
            const rodTargetX = state.rodNear ? -12 : -35;
            const rodTargetY = state.rodRemoved ? 20 : 0;
            rodGroup.position.x += (rodTargetX - rodGroup.position.x) * motionSpeed;
            rodGroup.position.y += (rodTargetY - rodGroup.position.y) * motionSpeed;

            // Sphere Movement
            const sphereB_TargetX = state.spheresSeparated ? 10 : 3.6;
            // Use motionSpeed here
            sphereB.group.position.x += (sphereB_TargetX - sphereB.group.position.x) * motionSpeed;

            // Physics Logic
            electrons.forEach(e => {
                let targetPos = new THREE.Vector3();

                if (state.rodNear && !state.spheresSeparated) {
                    // Induction: Push to Sphere B
                    targetPos.copy(e.userData.offset).add(sphereB.group.position);
                    positiveHoles.forEach(p => p.visible = true);
                }
                else if (state.rodNear && state.spheresSeparated) {
                    // Trapped on B
                    targetPos.copy(e.userData.offset).add(sphereB.group.position);
                }
                else if (state.rodRemoved && state.spheresSeparated) {
                    // Isolation: B is negative
                    targetPos.copy(e.userData.offset).add(sphereB.group.position);

                    positiveHoles.forEach(p => {
                        p.visible = true;
                        const pTarget = new THREE.Vector3().copy(p.userData.offset).add(sphereA.group.position);
                        p.position.lerp(pTarget, motionSpeed);
                    });
                }
                else {
                    // Neutral (Reset)
                    if (e.userData.homeSphere === 'A')
                        targetPos.copy(e.userData.offset).add(sphereA.group.position);
                    else
                        targetPos.copy(e.userData.offset).add(sphereB.group.position);

                    positiveHoles.forEach(p => p.visible = false);
                }
                // Use motionSpeed here
                e.position.lerp(targetPos, motionSpeed);
            });

            if (state.rodNear) {
                positiveHoles.forEach(p => {
                    const pTarget = new THREE.Vector3().copy(p.userData.offset).add(sphereA.group.position);
                    p.position.lerp(pTarget, motionSpeed);
                });
            }

            renderer.render(scene, camera);
        }
        animate();

        // ==========================================
        // PART 4: INTERACTION & STORY
        // ==========================================

        const lessons = [
            {
                title: "Creating Dipoles",
                text: "Observe the two metal spheres. They are touching, effectively forming a single conductor.<br><br>In a metal, electrons (blue spheres) are free to roam on the surface. Currently, they are evenly distributed. The positive charges (red) are hidden underneath, neutralized by the electrons. <br><br>Let's disturb this equilibrium. <span class='instruction-inline'>Click 'BRING NEGATIVE ROD'</span>.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-rod');
                },
                check: () => state.rodNear
            },
            {
                title: "Electrostatic Repulsion",
                text: "The negatively charged rod approaches. <strong>Like charges repel.</strong><br><br>Watch the blue electrons slowly drift away from the rod. They flow from the left sphere to the right sphere.<br><br>This exposes the positive ions (red) on the left sphere. The system is polarized. <span class='instruction-inline'>Click 'SEPARATE SPHERES'</span>.",
                setup: () => {
                    unlock('ctrl-sep');
                },
                check: () => state.spheresSeparated
            },
            {
                title: "Setting the Trap",
                text: "You have separated the spheres while the rod was still pushing the electrons.<br><br>The bridge is broken! The blue electrons are now trapped on the right sphere. They cannot return to the left sphere.<br><br>We can now remove the influence. <span class='instruction-inline'>Click 'REMOVE ROD'</span>.",
                setup: () => {
                    unlock('ctrl-remove');
                },
                check: () => state.rodRemoved
            },
            {
                title: "Conclusion",
                text: "With the rod gone, look at the result.<br><br>The Left Sphere is positively charged (Red).<br>The Right Sphere is negatively charged (Blue).<br><br>We have successfully created static electricity from neutral objects using <strong>Induction</strong>. The charges are permanently separated. Now, let's see what happens when we bring a dipole near a massive source of charge: The Van de Graaff Generator.",
                setup: () => { },
                check: () => true
            }
        ];

        // --- EXPORT FUNCTIONS ---

        window.introduceRod = function () {
            state.rodNear = true;
            document.getElementById('btn-rod').disabled = true;
            document.getElementById('btn-rod').innerText = "Rod in Position";
            checkAdvance();
        };

        window.separateSpheres = function () {
            state.spheresSeparated = true;
            document.getElementById('btn-sep').disabled = true;
            document.getElementById('btn-sep').innerText = "Spheres Separated";
            checkAdvance();
        };

        window.removeRod = function () {
            state.rodRemoved = true;
            state.rodNear = false;
            document.getElementById('btn-remove').disabled = true;
            document.getElementById('btn-remove').innerText = "Rod Removed";
            checkAdvance();
        };

        window.resetSim = function () {
            state.rodNear = false;
            state.spheresSeparated = false;
            state.rodRemoved = false;

            resetBtn('btn-rod', "Bring Negative Rod");
            resetBtn('btn-sep', "Separate Spheres");
            resetBtn('btn-remove', "Remove Rod");

            loadLesson(0);
        };

        // Navigation Exports
        window.nextLesson = function () {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.location.href = '/theapplefalls/lessons/chapter2/8_dipole_on_vandeGraff.html';
            }
        };
        window.prevLesson = function () {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        };

        function resetBtn(id, txt) {
            const b = document.getElementById(id);
            if (b) {
                b.disabled = false;
                b.innerText = txt;
                b.parentElement.classList.remove('active');
            }
        }

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div>
                 <div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');

            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }

            l.setup();
        }

        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) {
            const el = document.getElementById(id);
            if (el) el.classList.add('active');
        }

        // Init
        loadLesson(0);

        // Resize Handle
        window.addEventListener('resize', () => {
            aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            const camSize = camera.top - camera.bottom;
            camera.left = -camSize * aspect / 2;
            camera.right = camSize * aspect / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });
    </script>
</body>

</html>