<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>The Invisible Web: Grass Seed Experiment</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT (Identical to previous) --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        .math-block {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #333;
            color: #fff;
            text-align: center;
        }

        /* CONTROLS AREA */
        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        /* NAVIGATION FOOTER */
        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        /* NEXT BUTTON STYLING FIX */
        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            border: none;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
            transform: none;
            animation: none;
        }

        /* MAIN CANVAS */
        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }

        /* Specific tweaks for toggle buttons */
        .mode-toggle {
            display: flex;
            gap: 10px;
        }

        .mode-toggle button {
            flex: 1;
        }

        .mode-toggle button.selected {
            background: var(--accent);
            color: #111;
            border-color: var(--accent);
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Experiment: Dielectric Polarization</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- 1. Sprinkle Seeds -->
            <div class="control-row" id="ctrl-seeds">
                <label>Step 1: The Medium</label>
                <button id="btn-seeds" onclick="scatterSeeds()">Scatter Seeds</button>
            </div>

            <!-- 2. Apply Voltage -->
            <div class="control-row" id="ctrl-voltage">
                <label>Step 2: High Voltage Supply</label>
                <button id="btn-voltage" onclick="applyVoltage()">Engage Field</button>
            </div>

            <!-- 3. Configuration -->
            <div class="control-row" id="ctrl-config">
                <label>Step 3: Charge Configuration</label>
                <div class="mode-toggle">
                    <button id="btn-dipole" class="selected" onclick="setMode('dipole')">Dipole (+ / -)</button>
                    <button id="btn-repel" onclick="setMode('repel')">Repulsion (+ / +)</button>
                </div>
            </div>

            <!-- Reset -->
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Lab Safety</label>
                <button onclick="resetSim()">Clean Tray</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Insulating Oil Bath</div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const state = {
            seedsScattered: false,
            voltageOn: false,
            mode: 'dipole', // 'dipole' or 'repel'
            time: 0
        };

        const scene = new THREE.Scene();

        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 35;

        // Isometric-ish Orthographic Camera
        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );
        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('world').appendChild(renderer.domElement);

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // --- ENVIRONMENT ---

        // --- GROUND & FLOOR ---
        const tableGeo = new THREE.PlaneGeometry(100, 100);
        const tableMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
        const table = new THREE.Mesh(tableGeo, tableMat);
        table.rotation.x = -Math.PI / 2;
        table.position.y = -2;
        table.receiveShadow = true;
        scene.add(table);
        scene.background = new THREE.Color(0x151515);

        // The Petri Dish / Oil Tray
        const trayGroup = new THREE.Group();

        // Tray Bottom (Dark to make seeds pop)
        const trayGeo = new THREE.CylinderGeometry(14, 14, 0.5, 32);
        const trayMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.1, roughness: 0.2 });
        const tray = new THREE.Mesh(trayGeo, trayMat);
        tray.position.y = -0.25;
        tray.receiveShadow = true;
        trayGroup.add(tray);

        // The Oil (Glassy Surface)
        const oilGeo = new THREE.CylinderGeometry(13.8, 13.8, 0.1, 32);
        const oilMat = new THREE.MeshPhysicalMaterial({
            color: 0xffeeaa,
            transparent: true,
            opacity: 0.2,
            roughness: 0.1,
            metalness: 0,
            transmission: 0.5
        });
        const oil = new THREE.Mesh(oilGeo, oilMat);
        oil.position.y = 0.1;
        trayGroup.add(oil);

        // Rim
        const rimGeo = new THREE.TorusGeometry(14, 0.2, 8, 32);
        const rimMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
        const rim = new THREE.Mesh(rimGeo, rimMat);
        rim.rotation.x = Math.PI / 2;
        rim.position.y = 0.2;
        trayGroup.add(rim);

        scene.add(trayGroup);

        // --- ELECTRODES ---
        const electrodeGroup = new THREE.Group();

        function createElectrode(x, colorHex, labelText) {
            const grp = new THREE.Group();

            // Rod
            const rodGeo = new THREE.CylinderGeometry(0.2, 0.2, 4, 8);
            const rodMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.3 });
            const rod = new THREE.Mesh(rodGeo, rodMat);
            rod.position.y = 2;
            grp.add(rod);

            // Sphere (Charge)
            const sphereGeo = new THREE.SphereGeometry(1, 16, 16);
            const sphereMat = new THREE.MeshStandardMaterial({ color: colorHex, emissive: colorHex, emissiveIntensity: 0.2 });
            const sphere = new THREE.Mesh(sphereGeo, sphereMat);
            sphere.castShadow = true;
            sphere.position.y = 0; // In the oil
            grp.add(sphere);

            // Label
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 80px Arial';
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.fillText(labelText, 64, 90);
            const tex = new THREE.CanvasTexture(canvas);
            const sprMat = new THREE.SpriteMaterial({ map: tex });
            const sprite = new THREE.Sprite(sprMat);
            sprite.position.set(0, 3.5, 0);
            sprite.scale.set(2, 2, 1);
            grp.add(sprite);

            grp.position.set(x, 0.5, 0);
            return grp;
        }

        const leftElectrode = createElectrode(-7, 0xff5555, "+"); // Always positive
        const rightElectrode = createElectrode(7, 0x5555ff, "-"); // Swaps based on mode
        electrodeGroup.add(leftElectrode);
        electrodeGroup.add(rightElectrode);
        scene.add(electrodeGroup);

        // --- GRASS SEEDS ---
        // We will use standard Meshes stored in an array for simplicity of logic updates
        // (InstancedMesh is faster but logic is slightly more complex for tutorial code)
        const seeds = [];
        const seedGroup = new THREE.Group();
        scene.add(seedGroup);

        function createSeed() {
            // Geometry: Elongated "rice" shape
            const geo = new THREE.BoxGeometry(0.6, 0.1, 0.1);
            const mat = new THREE.MeshStandardMaterial({ color: 0xeebb44, flatShading: true });
            const mesh = new THREE.Mesh(geo, mat);

            // Random Position in Circle
            let r = 13 * Math.sqrt(Math.random());
            let theta = Math.random() * 2 * Math.PI;

            mesh.position.x = r * Math.cos(theta);
            mesh.position.z = r * Math.sin(theta);
            mesh.position.y = 0.2; // Float on oil

            // Check collision with electrodes
            const distL = new THREE.Vector3(-7, 0, 0).distanceTo(mesh.position);
            const distR = new THREE.Vector3(7, 0, 0).distanceTo(mesh.position);

            if (distL < 1.5 || distR < 1.5) return null; // Dont place inside electrode

            // Random initial rotation
            mesh.rotation.y = Math.random() * Math.PI * 2;

            // Store velocity for Brownian motion simulation
            mesh.userData = {
                rotVel: (Math.random() - 0.5) * 0.05
            };

            return mesh;
        }

        function scatterSeeds() {
            // Clear old
            while (seedGroup.children.length > 0) {
                seedGroup.remove(seedGroup.children[0]);
            }
            seeds.length = 0;

            // Create new
            for (let i = 0; i < 600; i++) {
                const seed = createSeed();
                if (seed) {
                    seedGroup.add(seed);
                    seeds.push(seed);
                }
            }
            state.seedsScattered = true;
            checkAdvance();
        }


        // ==========================================
        // PART 2: PHYSICS LOOP
        // ==========================================

        function getFieldVector(pos) {
            // We add a tiny offset to denominators to prevent division by zero/infinity
            const k = 100; // Constant multiplier
            const minDist = 0.5; // Prevent singularity

            // 1. Left Charge (+Q)
            const q1 = 50;
            const p1 = new THREE.Vector3(-7, 0, 0);
            const r1_vec = new THREE.Vector3().subVectors(pos, p1);
            const r1_len = r1_vec.length();
            // E = kQ/r^2
            // Scale down intensity slightly for visual clarity
            const mag1 = k * q1 / (Math.max(r1_len, minDist) ** 2);
            const E1 = r1_vec.normalize().multiplyScalar(mag1);

            // 2. Right Charge (+Q or -Q)
            const q2 = (state.mode === 'dipole') ? -50 : 50;
            const p2 = new THREE.Vector3(7, 0, 0);
            const r2_vec = new THREE.Vector3().subVectors(pos, p2);
            const r2_len = r2_vec.length();
            const mag2 = k * Math.abs(q2) / (Math.max(r2_len, minDist) ** 2);
            // Note: Multiply by sign of q2 manually to keep direction logic clear
            const dir2 = r2_vec.normalize();
            if (q2 < 0) dir2.negate(); // If negative, vector points TOWARDS charge

            const E2 = dir2.multiplyScalar(mag2);

            // Superposition
            return new THREE.Vector3().addVectors(E1, E2);
        }

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.01;

            if (state.seedsScattered) {
                seeds.forEach(seed => {
                    if (state.voltageOn) {
                        // FIELD ON: Align with field

                        const E = getFieldVector(seed.position);
                        const fieldStrength = E.length(); // Get Magnitude

                        // --- PHYSICS FIX ---
                        // Only apply alignment if field is strong enough to overcome "friction"
                        // In the dead zone of Repulsion, fieldStrength approaches 0.

                        if (fieldStrength > 0.1) {
                            const targetAngle = Math.atan2(E.z, E.x);

                            let current = seed.rotation.y;

                            // Angle normalization
                            let diff = targetAngle - current;
                            while (diff > Math.PI) diff -= Math.PI * 2;
                            while (diff < -Math.PI) diff += Math.PI * 2;

                            // Symmetric alignment (Head or Tail)
                            if (Math.abs(diff) > Math.PI / 2) {
                                if (diff > 0) diff -= Math.PI;
                                else diff += Math.PI;
                            }

                            // Apply torque based on Field Strength
                            // Stronger field = faster/tighter alignment
                            // We clamp the speed so they don't spin uncontrollably near poles
                            const torque = Math.min(fieldStrength * 0.05, 0.2);

                            seed.rotation.y += diff * torque;
                        }
                        // If fieldStrength is < 0.1 (The Dead Zone), the seed 
                        // stays at its random rotation (Chaos/Entropy).

                    } else {
                        // FIELD OFF: Brownian Motion
                        seed.rotation.y += seed.userData.rotVel;
                        seed.userData.rotVel *= 0.99;
                        if (Math.random() > 0.95) seed.userData.rotVel += (Math.random() - 0.5) * 0.01;
                    }
                });
            }

            // Pulse Effect
            if (state.voltageOn) {
                const scale = 1 + Math.sin(state.time * 10) * 0.05;
                leftElectrode.children[1].scale.set(scale, scale, scale);
                rightElectrode.children[1].scale.set(scale, scale, scale);
            } else {
                leftElectrode.children[1].scale.set(1, 1, 1);
                rightElectrode.children[1].scale.set(1, 1, 1);
            }

            renderer.render(scene, camera);
        }
        animate();

        // ==========================================
        // PART 3: LOGIC & NARRATIVE
        // ==========================================

        let currentChapter = 0;

        function applyVoltage() {
            if (!state.seedsScattered) return;
            state.voltageOn = !state.voltageOn; // Toggle

            const btn = document.getElementById('btn-voltage');
            if (state.voltageOn) {
                btn.innerText = "Cut Power";
                btn.style.borderColor = "#ff5555";
                btn.style.color = "#ff5555";
            } else {
                btn.innerText = "Engage Field";
                btn.style.borderColor = "#3d4450";
                btn.style.color = "#aaa";
            }
            checkAdvance();
        }

        function setMode(mode) {
            state.mode = mode;

            // Update Buttons
            document.getElementById('btn-dipole').classList.toggle('selected', mode === 'dipole');
            document.getElementById('btn-repel').classList.toggle('selected', mode === 'repel');

            // Update Visuals (Right Electrode Color)
            const rightSphere = rightElectrode.children[1];
            const rightLabel = rightElectrode.children[2]; // Sprite

            if (mode === 'dipole') {
                // Blue (-)
                rightSphere.material.color.setHex(0x5555ff);
                rightSphere.material.emissive.setHex(0x5555ff);

                // Update Label text
                const ctx = rightLabel.material.map.image.getContext('2d');
                ctx.clearRect(0, 0, 128, 128);
                ctx.fillStyle = "white"; ctx.textAlign = "center"; ctx.fillText("-", 64, 90);
                rightLabel.material.map.needsUpdate = true;

            } else {
                // Red (+)
                rightSphere.material.color.setHex(0xff5555);
                rightSphere.material.emissive.setHex(0xff5555);

                // Update Label text
                const ctx = rightLabel.material.map.image.getContext('2d');
                ctx.clearRect(0, 0, 128, 128);
                ctx.fillStyle = "white"; ctx.textAlign = "center"; ctx.fillText("+", 64, 90);
                rightLabel.material.map.needsUpdate = true;
            }
            checkAdvance();
        }

        function resetSim() {
            state.seedsScattered = false;
            state.voltageOn = false;
            state.mode = 'dipole';

            // Reset Visuals
            while (seedGroup.children.length > 0) seedGroup.remove(seedGroup.children[0]);
            seeds.length = 0;

            document.getElementById('btn-voltage').innerText = "Engage Field";
            document.getElementById('btn-voltage').style.color = "#aaa";
            document.getElementById('btn-voltage').style.borderColor = "#3d4450";

            setMode('dipole');
            loadLesson(0);
        }

        // --- LESSON CONTENT ---

        const lessons = [
            {
                title: "The Chaos of Entropy",
                text: "To visualize the invisible electric field, we need a medium. We have filled a tray with insulating oil and will scatter <strong>grass seeds</strong> on top.<br><br>Grass seeds are insulators, not conductors. They are currently uncharged and oriented randomly due to entropy.<br><br><span class='instruction-inline'>Click 'SCATTER SEEDS'</span> to prepare the tray.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-seeds');
                },
                check: () => state.seedsScattered
            },
            {
                title: "First Principles: Polarization",
                text: "When we apply high voltage, we create an <strong>Electric Field (E)</strong>.<br><br>Even though the seeds are neutral, the field pulls positive charges within the seed one way, and negative charges the other. This creates a <strong>Induced Dipole</strong>.<br><br>The field then exerts <strong>Torque</strong> on these poles, twisting the seed until it aligns with the field lines.<br><br><span class='instruction-inline'>Click 'ENGAGE FIELD'</span> to observe.",
                setup: () => {
                    unlock('ctrl-voltage');
                },
                check: () => state.voltageOn
            },
            {
                title: "Dipole Configuration",
                text: "You are looking at the field of a <strong>Dipole</strong> (One positive, one negative).<br><br>Notice the arches? The field lines leave the positive charge and terminate on the negative charge. The seeds trace this path because it is the path of least energy.<br><br>The lines are densest near the charges, indicating the field is strongest there.",
                setup: () => {
                    unlock('ctrl-config');
                },
                check: () => true // Just needs to read
            },
            {
                title: "Conclusion",
                text: "Now, let's see what happens when forces collide.<br><br><span class='instruction-inline'>Click 'REPULSION (+ / +)'</span>.<br><br>Both charges are now positive. Field lines cannot cross. Instead, they push against each other, creating a 'dead zone' in the center where the net field is zero. The seeds here have no direction to point. We've seen how fields affect solids. Now, let's see how they affect liquids. Get ready to bend water.",
                setup: () => {
                    unlock('ctrl-config');
                },
                check: () => state.mode === 'repel'
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Observation ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div>
             <div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');

            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }

            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.top.location.href = '/theapplefalls/lesson/10_dipole';
            }
        }
        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }
        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        // Init
        loadLesson(0);

        window.addEventListener('resize', () => {
            aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * aspect / 2;
            camera.right = viewSize * aspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

    </script>
</body>

</html>