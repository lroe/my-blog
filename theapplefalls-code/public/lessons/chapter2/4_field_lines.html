<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>The Invisible Web: Field Lines</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
            --red: #ff6b6b;
            --blue: #54a0ff;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        .coord-display {
            float: right;
            color: var(--accent);
            font-family: monospace;
        }

        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        /* NEXT BUTTON STYLING FIX */
        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            border: none;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
            transform: none;
            animation: none;
        }

        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }

        /* UPDATED BADGE STYLE */
        .analogy-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            /* Pill shape */
            font-size: 11px;
            text-transform: uppercase;
            font-weight: 800;
            margin-left: 4px;
            color: #fff;
            /* White text */
            vertical-align: middle;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            letter-spacing: 0.5px;
        }

        .badge-source {
            background: var(--red);
        }

        .badge-sink {
            background: var(--blue);
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Sim: Field Line Topology</div>
        </header>

        <div id="story-container">
            <div id="chapter-content"><!-- Content injected by JS --></div>
        </div>

        <div id="controls-area">
            <div class="control-row" id="ctrl-vis">
                <label>Step 1: The Map</label>
                <button id="btn-vis" onclick="toggleLines()">Draw Field Lines</button>
            </div>
            <div class="control-row" id="ctrl-flow">
                <label>Step 2: The Flow</label>
                <button id="btn-flow" onclick="toggleParticles()">Activate "Test Charge" Flow</button>
            </div>
            <div class="control-row" id="ctrl-config">
                <label>Step 3: Configuration</label>
                <div style="display:flex; gap:10px;">
                    <button id="btn-attract" onclick="setConfig('dipole')"
                        style="background:var(--accent); color:#111;">Dipole (+/-)</button>
                    <button id="btn-repel" onclick="setConfig('repulse')">Repulsion (+/+)</button>
                </div>
            </div>
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Experiment Control</label>
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Electrostatic Topology</div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const state = {
            linesVisible: false,
            particlesActive: false,
            config: 'dipole',
            time: 0
        };

        const scene = new THREE.Scene();
        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        let viewSize = 50;

        const camera = new THREE.OrthographicCamera(-viewSize * aspect / 2, viewSize * aspect / 2, viewSize / 2, -viewSize / 2, 1, 1000);
        camera.position.set(20, 30, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('world').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Floor & Grid
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8, metalness: 0.2 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -10;
        floor.receiveShadow = true;
        scene.add(floor);
        scene.background = new THREE.Color(0x151515);
        const gridHelper = new THREE.GridHelper(300, 60, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -9.9;
        scene.add(gridHelper);

        // --- CHARGES ---
        const charges = [];
        const chargeGroup = new THREE.Group();
        scene.add(chargeGroup);

        function createCharge(val, x, color) {
            const geo = new THREE.IcosahedronGeometry(val > 0 ? 3 : 2, 1);
            const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.4 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, 0, 0);

            // Label
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 60px Arial';
            ctx.fillStyle = color;
            ctx.textAlign = "center";
            ctx.fillText(val > 0 ? "+" : "-", 64, 80);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
            sprite.position.set(0, 4, 0);
            sprite.scale.set(4, 4, 1);
            mesh.add(sprite);

            chargeGroup.add(mesh);
            return { val: val, mesh: mesh };
        }

        // --- FIELD LINE ENGINE ---
        const linesGroup = new THREE.Group();
        scene.add(linesGroup);

        // Particle System for Flow
        const particleCount = 600;
        const particleGeo = new THREE.BufferGeometry();
        const particlePos = new Float32Array(particleCount * 3);
        particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePos, 3));
        // Updated material for better visibility
        const particleMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.6, transparent: true, opacity: 0 });
        const particleSystem = new THREE.Points(particleGeo, particleMat);
        particleSystem.frustumCulled = false; // Prevent disappearing at edges
        scene.add(particleSystem);

        const particles = [];
        const paths = [];

        function getNetField(pos) {
            let E = new THREE.Vector3(0, 0, 0);
            charges.forEach(q => {
                const rVec = new THREE.Vector3().subVectors(pos, q.mesh.position);
                const dist = rVec.length();
                if (dist < 0.1) return;
                const mag = q.val / (dist * dist * dist);
                E.add(rVec.multiplyScalar(mag));
            });
            return E;
        }

        function generateLines() {
            // Clear old
            linesGroup.clear();
            paths.length = 0;
            particles.length = 0;

            const mat = new THREE.LineBasicMaterial({ color: 0x8892b0, transparent: true, opacity: 0.3 });

            // Find Positive Charges (Sources)
            const sources = charges.filter(c => c.val > 0);

            sources.forEach(src => {
                // Emit lines
                const numLines = Math.abs(src.val) * 12;
                const radius = 2.5;

                for (let i = 0; i < numLines; i++) {
                    const phi = Math.acos(1 - 2 * (i + 0.5) / numLines);
                    const theta = Math.PI * (1 + Math.sqrt(5)) * i;

                    const startPos = new THREE.Vector3(
                        radius * Math.sin(phi) * Math.cos(theta),
                        radius * Math.sin(phi) * Math.sin(theta),
                        radius * Math.cos(phi)
                    ).add(src.mesh.position);

                    const path = [startPos];
                    let curr = startPos.clone();
                    let alive = true;

                    for (let step = 0; step < 200; step++) {
                        const E = getNetField(curr);
                        const Emag = E.length();

                        if (Emag < 0.01) { alive = false; break; }

                        const dir = E.normalize();
                        const move = dir.multiplyScalar(0.8);
                        const next = curr.clone().add(move);

                        let hitSink = false;
                        charges.forEach(q => {
                            if (q.val < 0 && next.distanceTo(q.mesh.position) < 2.5) hitSink = true;
                        });

                        path.push(next);
                        curr = next;

                        if (hitSink) break;
                        if (Math.abs(curr.x) > 50 || Math.abs(curr.z) > 40) break;
                    }

                    if (path.length > 5) {
                        paths.push(path);
                        const geometry = new THREE.BufferGeometry().setFromPoints(path);
                        linesGroup.add(new THREE.Line(geometry, mat));
                    }
                }
            });

            // Initialize particles if paths exist
            if (paths.length > 0) {
                for (let i = 0; i < particleCount; i++) {
                    particles.push({
                        pathIdx: Math.floor(Math.random() * paths.length),
                        progress: Math.random(),
                        speed: 0.005 + Math.random() * 0.01
                    });
                }
            }
        }

        function updateConfig() {
            chargeGroup.clear();
            charges.length = 0;

            if (state.config === 'dipole') {
                const q1 = createCharge(4, -10, '#ff6b6b');
                const q2 = createCharge(-4, 10, '#54a0ff');
                charges.push(q1, q2);
            } else {
                const q1 = createCharge(4, -10, '#ff6b6b');
                const q2 = createCharge(4, 10, '#ff6b6b');
                charges.push(q1, q2);
            }

            // Always generate data, but visibility controls render
            generateLines();
            if (!state.linesVisible) linesGroup.clear();
        }


        // ==========================================
        // PART 2: ANIMATION LOOP
        // ==========================================

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.01;

            // Animate Charge Bobbing
            charges.forEach((c, i) => {
                c.mesh.position.y = Math.sin(state.time + i) * 0.5;
            });

            // Animate Particles
            if (state.particlesActive && paths.length > 0 && particles.length > 0) {
                particleMat.opacity = 1.0;
                const positions = particleSystem.geometry.attributes.position.array;

                particles.forEach((p, i) => {
                    const path = paths[p.pathIdx];

                    // Safety check
                    if (!path) return;

                    p.progress += p.speed;
                    if (p.progress >= 1) p.progress = 0;

                    const totalPoints = path.length - 1;
                    const floatIdx = p.progress * totalPoints;
                    const idx = Math.floor(floatIdx);
                    const t = floatIdx - idx;

                    if (idx < totalPoints) {
                        const p1 = path[idx];
                        const p2 = path[idx + 1];
                        const x = p1.x + (p2.x - p1.x) * t;
                        const y = p1.y + (p2.y - p1.y) * t;
                        const z = p1.z + (p2.z - p1.z) * t;

                        positions[i * 3] = x;
                        positions[i * 3 + 1] = y;
                        positions[i * 3 + 2] = z;
                    }
                });
                particleSystem.geometry.attributes.position.needsUpdate = true;
            } else {
                particleMat.opacity = 0;
            }

            renderer.render(scene, camera);
        }

        // Init
        updateConfig();
        animate();


        // ==========================================
        // PART 3: NARRATIVE LOGIC
        // ==========================================

        let currentChapter = 0;

        function toggleLines() {
            state.linesVisible = !state.linesVisible;
            if (state.linesVisible) {
                generateLines(); // Regenerate to ensure fresh paths
            } else {
                linesGroup.clear();
                // We keep paths in memory so particles can work if user clicks flow without lines (optional, but safer to clear)
                // But for this UI, clearing visuals is enough.
            }

            document.getElementById('btn-vis').innerText = state.linesVisible ? "Hide Lines" : "Draw Field Lines";
            checkAdvance();
        }

        function toggleParticles() {
            state.particlesActive = !state.particlesActive;

            // If lines aren't drawn yet, draw them invisibly so we have paths
            if (paths.length === 0) generateLines();
            if (!state.linesVisible) linesGroup.clear(); // Keep lines hidden if they were hidden

            document.getElementById('btn-flow').innerText = state.particlesActive ? "Stop Flow" : "Activate 'Test Charge' Flow";
            checkAdvance();
        }

        function setConfig(type) {
            state.config = type;
            const btnA = document.getElementById('btn-attract');
            const btnR = document.getElementById('btn-repel');

            if (type === 'dipole') {
                btnA.style.background = 'var(--accent)'; btnA.style.color = '#111';
                btnR.style.background = '#2c313a'; btnR.style.color = '#aaa';
            } else {
                btnR.style.background = 'var(--accent)'; btnR.style.color = '#111';
                btnA.style.background = '#2c313a'; btnA.style.color = '#aaa';
            }

            updateConfig();
            checkAdvance();
        }

        function resetSim() {
            state.linesVisible = false;
            state.particlesActive = false;
            linesGroup.clear();

            document.getElementById('btn-vis').innerText = "Draw Field Lines";
            document.getElementById('btn-flow').innerText = "Activate 'Test Charge' Flow";

            setConfig('dipole');
            loadLesson(0);
        }

        const lessons = [
            {
                title: "The Invisible Map",
                text: "Vector arrows are useful, but they get cluttered. Physicists often use <strong>Field Lines</strong> to create a cleaner map of the universe.<br><br>Think of these lines as rails. If we placed a tiny positive test charge on a rail, the electrostatic force would push it along that specific track.<br><br><span class='instruction-inline'>Click 'DRAW FIELD LINES'</span> to reveal the topology.",
                setup: () => { lockAll(); unlock('ctrl-vis'); },
                check: () => state.linesVisible
            },
            {
                title: "Sources and Sinks",
                text: "Notice the direction. Positive charges (Red) act as <strong>Sources</strong> <span class='analogy-badge badge-source'>HAIRDRYER</span>. They blow the field out.<br><br>Negative charges (Blue) act as <strong>Sinks</strong> <span class='analogy-badge badge-sink'>VACUUM</span>. They suck the field in.<br><br><span class='instruction-inline'>Click 'ACTIVATE FLOW'</span> to release test charges and visualize this movement.",
                setup: () => { unlock('ctrl-flow'); },
                check: () => state.particlesActive
            },
            {
                title: "Density is Strength",
                text: "Observe the spacing of the lines. <br><br>Near the charges, the lines are packed tight. This indicates <strong>High Field Strength</strong>.<br><br>In the spaces far from the axis, the lines spread out. This indicates a <strong>Weaker Field</strong>. The density of lines literally represents the magnitude of the force.",
                setup: () => { },
                check: () => true
            },
            {
                title: "Conclusion",
                text: "What if both charges are sources? <br><br>If we switch the right charge to Positive, both act as \"hairdryers\" blowing against each other. The lines cannot cross, so they bend away, creating an asymptote (a wall) in the middle.<br><br><span class='instruction-inline'>Click 'Repulsion (+/+)'</span> to see the lines fight for space. However, field lines can be misleading if we aren't careful. In the next lesson, we will address common misconceptions.",
                setup: () => { unlock('ctrl-config'); },
                check: () => state.config === 'repulse'
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML = `<div class="chapter-title">${l.title}</div><div class="story-text">${l.text}</div>`;
            const btn = document.getElementById('btn-next');
            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            } l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.location.href = '/theapplefalls/lessons/chapter2/5_misconception.html';
            }
        }
        function prevLesson() { if (currentChapter > 0) loadLesson(currentChapter - 1); }
        function checkAdvance() { if (currentChapter >= lessons.length - 1) return; if (lessons[currentChapter].check()) { document.getElementById('btn-next').disabled = false; } }
        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        loadLesson(0);

        window.addEventListener('resize', () => {
            aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * aspect / 2;
            camera.right = viewSize * aspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });
    </script>
</body>

</html>