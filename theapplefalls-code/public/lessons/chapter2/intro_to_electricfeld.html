<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>The Invisible Web: Electric Fields</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        .math-block {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #333;
            color: #fff;
            text-align: center;
        }

        /* CONTROLS AREA */
        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
            height: 6px;
            background: #333;
            border-radius: 3px;
        }

        /* NAVIGATION FOOTER */
        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        /* NEXT BUTTON STYLING FIX */
        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            border: none;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
            transform: none;
            animation: none;
        }

        /* MAIN CANVAS */
        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        /* TAGS IN SCENE */
        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Simulation: Defining The Field</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- 1. Introduce Test Charge -->
            <div class="control-row" id="ctrl-intro">
                <label>Step 1: The Probe</label>
                <button id="btn-intro" onclick="introduceTestCharge()">Place Test Charge (q)</button>
            </div>

            <!-- 2. Slider -->
            <div class="control-row" id="ctrl-move">
                <label>Step 2: Distance (r)</label>
                <input type="range" id="slider-dist" min="5" max="30" value="15" step="0.1">
            </div>

            <!-- 3. Divide by q -->
            <div class="control-row" id="ctrl-field">
                <label>Step 3: The Definition</label>
                <button id="btn-field" onclick="toggleFieldMode()">Divide by 'q' (Show E)</button>
            </div>

            <!-- Reset -->
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Experiment Control</label>
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Vacuum Space</div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const state = {
            testChargeVisible: false,
            fieldMode: false,
            distance: 15,
            time: 0
        };

        const scene = new THREE.Scene();

        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 40;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );

        camera.position.set(20, 25, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('world').appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // Floor
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({
            color: 0x222222,
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -10;
        floor.receiveShadow = true;
        scene.background = new THREE.Color(0x151515);

        // Grid Helper
        const gridHelper = new THREE.GridHelper(100, 20, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -9.9;
        scene.add(floor);
        scene.add(gridHelper);

        // --- OBJECTS ---

        // 1. Source Charge (Q) - Big Red
        const sourceGroup = new THREE.Group();
        const sourceGeo = new THREE.IcosahedronGeometry(3, 1);
        const sourceMat = new THREE.MeshStandardMaterial({ color: 0xff6b6b, flatShading: true, emissive: 0x550000 });
        const sourceMesh = new THREE.Mesh(sourceGeo, sourceMat);
        sourceMesh.castShadow = true;
        sourceGroup.add(sourceMesh);

        // Label Q
        function createTextSprite(text, scale) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128; // Higher res
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 50px Arial';
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.fillText(text, 128, 80);
            const tex = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: tex, depthTest: false }); // depthTest false to see through objects if needed
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(scale * 2, scale, 1);
            sprite.renderOrder = 100;
            return sprite;
        }
        const labelQ = createTextSprite("Q (+)", 4);
        labelQ.position.y = 5;
        sourceGroup.add(labelQ);
        scene.add(sourceGroup);

        // 2. Test Charge (q) - Small Yellow
        const testGroup = new THREE.Group();
        const testGeo = new THREE.IcosahedronGeometry(0.8, 0);
        const testMat = new THREE.MeshStandardMaterial({ color: 0xfeca57, flatShading: true, emissive: 0x554400 });
        const testMesh = new THREE.Mesh(testGeo, testMat);
        testMesh.castShadow = true;
        testGroup.add(testMesh);

        const labelq = createTextSprite("q (+)", 3);
        labelq.position.y = 2;
        testGroup.add(labelq);
        scene.add(testGroup);
        testGroup.visible = false;

        // 3. Vector Arrow (The Force/Field)
        // Structure: arrowGroup (Pos/Rot) -> arrowVisuals (Scale) -> Mesh
        const arrowGroup = new THREE.Group();
        const arrowVisuals = new THREE.Group();
        arrowGroup.add(arrowVisuals);

        // Build Arrow Geometry facing +X
        const shaftGeo = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
        shaftGeo.translate(0, 0.5, 0); // Pivot at bottom
        shaftGeo.rotateZ(-Math.PI / 2);  // Point +X
        const shaftMat = new THREE.MeshStandardMaterial({ color: 0x54a0ff });
        const shaft = new THREE.Mesh(shaftGeo, shaftMat);

        const headGeo = new THREE.ConeGeometry(0.5, 1, 8);
        headGeo.rotateZ(-Math.PI / 2);   // Point +X
        headGeo.translate(1, 0, 0);    // Place at end of shaft length 1
        const headMat = new THREE.MeshStandardMaterial({ color: 0x54a0ff });
        const head = new THREE.Mesh(headGeo, headMat);

        arrowVisuals.add(shaft);
        arrowVisuals.add(head);

        // Label F (Not inside arrowVisuals, so it doesn't squash)
        const labelF = createTextSprite("F", 3);
        labelF.position.set(0, 2, 0);
        arrowGroup.add(labelF);

        scene.add(arrowGroup);
        arrowGroup.visible = false;

        // 4. Field Array (Visualizing E)
        const fieldVectors = [];
        const fieldGroup = new THREE.Group();
        scene.add(fieldGroup);

        function createFieldVector(pos) {
            const grp = new THREE.Group();
            // Simplified arrow
            const sGeo = new THREE.CylinderGeometry(0.1, 0.1, 1, 4);
            sGeo.translate(0, 0.5, 0);
            sGeo.rotateZ(-Math.PI / 2);
            const sMat = new THREE.MeshBasicMaterial({ color: 0x54a0ff, transparent: true, opacity: 0.5 });
            const s = new THREE.Mesh(sGeo, sMat);

            const hGeo = new THREE.ConeGeometry(0.3, 0.6, 4);
            hGeo.rotateZ(-Math.PI / 2);
            hGeo.translate(1, 0, 0);
            const hMat = new THREE.MeshBasicMaterial({ color: 0x54a0ff, transparent: true, opacity: 0.5 });
            const h = new THREE.Mesh(hGeo, hMat);

            const subGrp = new THREE.Group(); // Scale this subgrp
            subGrp.add(s, h);
            grp.add(subGrp);
            grp.userData = { visuals: subGrp }; // Reference for scaling

            grp.position.copy(pos);

            // Align +X to radial direction
            const dir = pos.clone().normalize();
            const axisX = new THREE.Vector3(1, 0, 0);
            const quat = new THREE.Quaternion().setFromUnitVectors(axisX, dir);
            grp.rotation.setFromQuaternion(quat);

            return grp;
        }

        // Generate circular field pattern
        for (let r = 6; r < 25; r += 6) {
            const count = r * 1.5;
            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2;
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                const v = createFieldVector(new THREE.Vector3(x, 0, z));
                v.userData.r = r;
                fieldGroup.add(v);
                fieldVectors.push(v);
            }
        }
        fieldGroup.visible = false;


        // ==========================================
        // PART 2: ANIMATION LOOP
        // ==========================================

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.02;

            // Bobbing effect
            sourceMesh.position.y = Math.sin(state.time) * 0.2;
            labelQ.position.y = 5 + Math.sin(state.time) * 0.2;

            // Update Test Charge Position
            const dist = state.distance;
            testGroup.position.set(dist, 0, 0);

            // Calculate Magnitude (Simulated Coulomb 1/r^2)
            const strength = 1500 / (dist * dist);

            // Update Arrow (Force or Field)
            if (state.testChargeVisible || state.fieldMode) {
                arrowGroup.visible = true;
                arrowGroup.position.copy(testGroup.position);

                // 1. Correct Orientation (Align +X Arrow with Radial Vector)
                // Vector from Source -> Test
                const direction = new THREE.Vector3().subVectors(testGroup.position, sourceGroup.position).normalize();
                // Create Quaternion to rotate (1,0,0) to 'direction'
                const axisX = new THREE.Vector3(1, 0, 0);
                const quat = new THREE.Quaternion().setFromUnitVectors(axisX, direction);
                arrowGroup.quaternion.copy(quat);

                // 2. Scale Visuals (Not the Group)
                let scale = Math.min(strength, 10);
                scale = Math.max(scale, 1.5);

                // Scale the mesh only, so label doesn't distort
                arrowVisuals.scale.set(scale, 1, 1);

                // 3. Move Label to midpoint of arrow
                // Since arrow is +X, midpoint is scale/2
                labelF.position.set(scale / 2, 2, 0);

            } else {
                arrowGroup.visible = false;
            }

            // Field Vectors Update
            if (state.fieldMode) {
                fieldVectors.forEach(v => {
                    const r = v.userData.r;
                    const fieldStr = 500 / (r * r);
                    let s = Math.min(fieldStr, 4);
                    s = Math.max(s, 0.5);
                    v.userData.visuals.scale.set(s, 1, 1);
                });
                sourceMesh.rotation.y += 0.005;
                sourceMesh.rotation.z += 0.005;
            }

            renderer.render(scene, camera);
        }
        animate();

        // ==========================================
        // PART 3: LOGIC & NARRATIVE
        // ==========================================

        let currentChapter = 0;

        function introduceTestCharge() {
            state.testChargeVisible = true;
            testGroup.visible = true;
            document.getElementById('btn-intro').disabled = true;
            document.getElementById('btn-intro').innerText = "Probe Active";
            checkAdvance();
        }

        document.getElementById('slider-dist').addEventListener('input', (e) => {
            state.distance = parseFloat(e.target.value);
            checkAdvance();
        });

        function toggleFieldMode() {
            state.fieldMode = true;

            // Hide test charge
            testGroup.visible = false;

            // Show Field Lines
            fieldGroup.visible = true;

            // Change Arrow Label
            const canvas = labelF.material.map.image;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 256, 128);
            ctx.fillStyle = "#54a0ff";
            ctx.textAlign = "center";
            ctx.fillText("E", 128, 80);
            labelF.material.map.needsUpdate = true;

            document.getElementById('btn-field').disabled = true;
            checkAdvance();
        }

        function resetSim() {
            state.testChargeVisible = false;
            state.fieldMode = false;
            state.distance = 15;

            testGroup.visible = false;
            fieldGroup.visible = false;

            document.getElementById('slider-dist').value = 15;

            // Reset buttons
            const btnI = document.getElementById('btn-intro');
            btnI.disabled = false;
            btnI.innerText = "Place Test Charge (q)";

            const btnF = document.getElementById('btn-field');
            btnF.disabled = false;

            // Reset Label F
            const canvas = labelF.material.map.image;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 256, 128);
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.fillText("F", 128, 80);
            labelF.material.map.needsUpdate = true;

            loadLesson(0);
        }

        // --- LESSON CONTENT ---

        const lessons = [
            {
                title: "Introduction: The Source",
                title: "Introduction: The Source",
                text: "In the previous module, we discovered Coulomb's Law: charges exert force on each other across space. But *how*? How does one particle 'know' the other is there? We now introduce the concept of the **Electric Field**.<br><br>We begin with a single Source Charge (<strong style='color:#ff6b6b'>Q</strong>). It sits in empty space. Does it affect the space around it? Right now, it's hard to tell because there is nothing else here to react to it.<br><br>To map the influence of Q, we need a probe. <span class='instruction-inline'>Click 'PLACE TEST CHARGE'</span>.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-intro');
                },
                check: () => state.testChargeVisible
            },
            {
                title: "Coulomb's Law",
                text: "We have placed a small positive <strong>Test Charge (q)</strong> nearby. According to Coulomb's Law, they repel. The <strong style='color:#54a0ff'>Blue Arrow (F)</strong> represents this Force vector.<br><br><div class='math-block'>F = k * (Q * q) / rÂ²</div><br><span style='font-size:0.9em; color:#aab; border-left: 2px solid #555; padding-left:10px; display:block; margin-bottom:10px;'><strong>Note:</strong> Newton's 3rd Law applies! The Source (Q) experiences this exact same force in the opposite direction. However, since Q is fixed in place for this simulation, we focus on the effect on q.</span><span class='instruction-inline'>Move the slider</span> to change distance (r).",
                setup: () => {
                    unlock('ctrl-move');
                },
                check: () => Math.abs(state.distance - 15) > 2
            },
            {
                title: "Defining the Field",
                text: "Notice that the Force depends on two things: the Source (Q) and the Test Charge (q).<br><br>But we want to define a property that belongs <em>only</em> to the Source. We want to know how strong the 'push' is at this location, regardless of what we put there.<br><br>To do this, we divide out the test charge:<br><div class='math-block'>E = F / q</div><br><span class='instruction-inline'>Click 'DIVIDE BY q'</span> to perform this mathematical abstraction.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-field');
                },
                check: () => state.fieldMode
            },
            {
                title: "Conclusion",
                text: "The test charge is gone, but the vector remains. This is no longer Force (F); it is the <strong>Electric Field (E)</strong>.<br><br><strong>Key Properties:</strong><br>1. <strong>Vector Quantity:</strong> It has magnitude and direction.<br>2. <strong>Convention:</strong> The direction is defined as the force <em>on a positive test charge</em> (away from positive, toward negative).<br><br>The grid shows us that this field exists everywhere in space, surrounding Q like an invisible web. But how do we represent this mathematically and visually? In the next lesson, we will explore the language of vectors.",
                setup: () => {
                    unlock('ctrl-move');
                },
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div>
             <div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');

            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }

            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.location.href = '/theapplefalls/lessons/chapter2/2_vector.html';
            }
        }
        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }
        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        // Init
        loadLesson(0);

        // Resize Handle
        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * newAspect / 2;
            camera.right = viewSize * newAspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

    </script>
</body>

</html>