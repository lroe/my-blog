<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Conductors and Electrostatic Equilibrium</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        .math-block {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #333;
            color: #fff;
            text-align: center;
        }

        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        .nav-btn.next {
            background: var(--accent);
            color: #151515;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }

        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        #graph-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 400px;
            height: 250px;
            background: rgba(26, 26, 26, 0.95);
            border: 2px solid #333;
            border-radius: 8px;
            padding: 15px;
            display: none;
        }

        #graph-canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Chapter 5: Conductors</div>
        </header>

        <div id="story-container">
            <div id="chapter-content"></div>
        </div>

        <div id="controls-area">
            <div class="control-row" id="ctrl-charges">
                <label>Step 1: Place Charges</label>
                <button onclick="addCharges()">Add Charges Inside</button>
            </div>

            <div class="control-row" id="ctrl-field">
                <label>Step 2: Check Internal Field</label>
                <button onclick="checkField()">Measure E Inside</button>
            </div>

            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div id="graph-container">
            <canvas id="graph-canvas"></canvas>
        </div>
    </main>

    <script>
        const state = {
            chargesAdded: false,
            equilibrium: false,
            fieldChecked: false,
            time: 0
        };

        const scene = new THREE.Scene();
        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 30;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );
        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        document.getElementById('world').appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(10, 20, 5);
        scene.add(dirLight);

        scene.background = new THREE.Color(0x151515);

        // Add OrbitControls for rotation
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enableZoom = true;
        controls.enablePan = false;

        // Conductor sphere
        const conductorGeo = new THREE.IcosahedronGeometry(8, 2);
        const conductorMat = new THREE.MeshStandardMaterial({
            color: 0x888888,
            metalness: 0.9,
            roughness: 0.1,
            transparent: true,
            opacity: 0.7
        });
        const conductor = new THREE.Mesh(conductorGeo, conductorMat);
        scene.add(conductor);

        // Charges that will animate to surface
        const initialChargesGroup = new THREE.Group();
        const numCharges = 24;
        const goldenRatio = (1 + Math.sqrt(5)) / 2;

        for (let i = 0; i < numCharges; i++) {
            // Start position (inside)
            const angle = (i / numCharges) * Math.PI * 2 + (Math.random() - 0.5) * 0.3;
            const r = 3 + Math.random() * 3;

            const chargeGeo = new THREE.SphereGeometry(0.4);
            const chargeMat = new THREE.MeshStandardMaterial({
                color: 0xff6b6b,
                emissive: 0x550000
            });
            const charge = new THREE.Mesh(chargeGeo, chargeMat);
            charge.position.set(
                Math.cos(angle) * r,
                (Math.random() - 0.5) * 6,
                Math.sin(angle) * r
            );

            // Target position (on surface using golden spiral)
            const theta = 2 * Math.PI * i / goldenRatio;
            const phi = Math.acos(1 - 2 * (i + 0.5) / numCharges);
            const targetX = 8.2 * Math.sin(phi) * Math.cos(theta);
            const targetY = 8.2 * Math.sin(phi) * Math.sin(theta);
            const targetZ = 8.2 * Math.cos(phi);

            charge.userData.target = new THREE.Vector3(targetX, targetY, targetZ);
            charge.userData.settled = false;
            initialChargesGroup.add(charge);
        }
        scene.add(initialChargesGroup);
        initialChargesGroup.visible = false;



        // Graph in HTML overlay
        const graphCanvas = document.getElementById('graph-canvas');
        const graphCtx = graphCanvas.getContext('2d');
        graphCanvas.width = 370;
        graphCanvas.height = 220;

        function drawGraph() {
            const w = 370, h = 220;
            graphCtx.fillStyle = 'transparent';
            graphCtx.clearRect(0, 0, w, h);

            // Title
            graphCtx.fillStyle = '#2ed573';
            graphCtx.font = 'bold 16px Arial';
            graphCtx.textAlign = 'center';
            graphCtx.fillText('Electric Field vs Distance', w / 2, 20);

            // Axes
            graphCtx.strokeStyle = '#666';
            graphCtx.lineWidth = 2;
            graphCtx.beginPath();
            graphCtx.moveTo(40, h - 30);
            graphCtx.lineTo(w - 20, h - 30);
            graphCtx.moveTo(40, 30);
            graphCtx.lineTo(40, h - 30);
            graphCtx.stroke();

            // Labels
            graphCtx.fillStyle = '#aaa';
            graphCtx.font = '12px Arial';
            graphCtx.textAlign = 'center';
            graphCtx.fillText('r', w / 2, h - 10);
            graphCtx.save();
            graphCtx.translate(15, h / 2);
            graphCtx.rotate(-Math.PI / 2);
            graphCtx.fillText('E', 0, 0);
            graphCtx.restore();

            // Conductor radius marker
            const conductorX = 40 + (8 / 15) * (w - 60);
            graphCtx.strokeStyle = '#ff6b6b';
            graphCtx.setLineDash([3, 3]);
            graphCtx.beginPath();
            graphCtx.moveTo(conductorX, 30);
            graphCtx.lineTo(conductorX, h - 30);
            graphCtx.stroke();
            graphCtx.setLineDash([]);
            graphCtx.fillStyle = '#ff6b6b';
            graphCtx.font = '11px Arial';
            graphCtx.fillText('R', conductorX, h - 35);

            // E-field plot
            graphCtx.strokeStyle = '#54a0ff';
            graphCtx.lineWidth = 2;
            graphCtx.beginPath();

            // Inside: E = 0
            for (let r = 0; r <= 8; r += 0.1) {
                const x = 40 + (r / 15) * (w - 60);
                const y = h - 30;
                if (r === 0) graphCtx.moveTo(x, y);
                else graphCtx.lineTo(x, y);
            }

            // Outside: E ~ 1/r²
            for (let r = 8; r <= 15; r += 0.1) {
                const x = 40 + (r / 15) * (w - 60);
                const E = 64 / (r * r);
                const y = h - 30 - E * 20;
                graphCtx.lineTo(x, y);
            }
            graphCtx.stroke();

            // Label
            graphCtx.fillStyle = '#2ed573';
            graphCtx.font = 'bold 14px Arial';
            graphCtx.textAlign = 'left';
            graphCtx.fillText('E = 0', 50, 80);

            document.getElementById('graph-container').style.display = 'block';
        }

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.01;
            controls.update();

            // Animate charge movement to surface (slower, smoother)
            if (state.chargesAdded && !state.equilibrium) {
                let allSettled = true;
                initialChargesGroup.children.forEach(charge => {
                    if (!charge.userData.settled) {
                        const distToTarget = charge.position.distanceTo(charge.userData.target);
                        if (distToTarget > 0.05) {
                            charge.position.lerp(charge.userData.target, 0.015); // Slow smooth movement
                            allSettled = false;
                        } else {
                            charge.position.copy(charge.userData.target);
                            charge.userData.settled = true;
                        }
                    }
                });

                // All charges reached surface
                if (allSettled) {
                    state.equilibrium = true;
                }
            }

            renderer.render(scene, camera);
        }
        animate();



        let currentChapter = 0;

        function addCharges() {
            state.chargesAdded = true;
            state.equilibrium = false;
            initialChargesGroup.visible = true;

            // Reset settled flags
            initialChargesGroup.children.forEach(charge => {
                charge.userData.settled = false;
            });

            document.querySelector('button[onclick="addCharges()"]').disabled = true;

            checkAdvance();
        }

        function checkField() {
            state.fieldChecked = true;
            drawGraph();
            document.querySelector('button[onclick="checkField()"]').disabled = true;
            checkAdvance();
        }

        function resetSim() {
            state.chargesAdded = false;
            state.equilibrium = false;
            state.fieldChecked = false;

            initialChargesGroup.visible = false;
            document.getElementById('graph-container').style.display = 'none';

            // Reset charge positions to random inside positions
            initialChargesGroup.children.forEach((charge, i) => {
                const angle = (i / 24) * Math.PI * 2 + (Math.random() - 0.5) * 0.3;
                const r = 3 + Math.random() * 3;
                charge.position.set(
                    Math.cos(angle) * r,
                    (Math.random() - 0.5) * 6,
                    Math.sin(angle) * r
                );
                charge.userData.settled = false;
            });

            document.querySelector('button[onclick="addCharges()"]').disabled = false;
            document.querySelector('button[onclick="checkField()"]').disabled = false;

            loadLesson(0);
        }

        const lessons = [
            {
                title: "What is a Conductor?",
                text: "A <strong>conductor</strong> is a material where electrons can move freely. Metals like copper, aluminum, and gold are excellent conductors.<br><br>You're looking at a spherical conductor. When we place charges on it, something remarkable happens.<br><br><span class='instruction-inline'>Click 'ADD CHARGES INSIDE'</span> to place some charges.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-charges');
                },
                check: () => state.chargesAdded
            },
            {
                title: "Electrostatic Equilibrium",
                text: "Watch as the charges automatically move! They experience mutual repulsion and push each other away until they reach <strong>electrostatic equilibrium</strong> on the <strong>outer surface</strong>.<br><br>In a conductor, free charges always redistribute to minimize energy. The surface is as far apart as they can get!<br><br>Once settled, <span class='instruction-inline'>click 'MEASURE E INSIDE'</span> to analyze the field.",
                setup: () => {
                    unlock('ctrl-field');
                },
                check: () => state.fieldChecked
            },
            {
                title: "Zero Field Inside",
                text: "<strong>Key principle:</strong> In electrostatic equilibrium:<br><div class='math-block'>E<sub>inside</sub> = 0</div><br>Why? If there were a field, free charges would move until they canceled it out. Equilibrium means zero net field everywhere inside.<br><br>By <strong>Gauss's Law</strong>: ∮ E · dA = Q<sub>enc</sub>/ε₀<br>Since all charge is on the surface, Q<sub>enc</sub> = 0 inside.<br><br><span class='instruction-inline'>Click 'MEASURE E INSIDE'</span> to see the E vs r graph.",
                setup: () => {
                    unlock('ctrl-field');
                },
                check: () => state.fieldChecked
            },
            {
                title: "Conclusion",
                text: "This principle has profound consequences:<br><br>1. <strong>Faraday cages:</strong> Metal enclosures block external fields<br>2. <strong>Shielding:</strong> Sensitive electronics protected from interference<br>3. <strong>Hollow conductors:</strong> The inside is field-free<br><br>The graph shows E = 0 inside (r < R) and E ~ 1/r² outside (r > R).<br><br>Next, we'll demonstrate this with a hollow conductor experiment.",
                setup: () => {
                    document.getElementById('btn-next').innerText = "Next Lesson";
                    document.getElementById('btn-next').disabled = false;
                },
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div><div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');
            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }
            if (l.setup) l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.location.href = '/theapplefalls/lessons/chapter5/7_hollow_conductor.html';
            }
        }

        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }

        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() {
            document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active'));
        }
        function unlock(id) {
            document.getElementById(id).classList.add('active');
        }

        loadLesson(0);

        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * newAspect / 2;
            camera.right = viewSize * newAspect / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });
    </script>
</body>

</html>