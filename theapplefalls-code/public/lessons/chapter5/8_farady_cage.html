<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Faraday Cage: First Principles</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* --- CORE STYLING (MATCHING PREVIOUS MODULE) --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;

            /* UPDATED: Orange Accent from First Script */
            --accent: #ff9f43;
            --accent-hover: #e58e3c;

            /* Physics Colors (Kept separate for scientific accuracy) */
            --red: #ff7675;
            --blue: #74b9ff;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .story-text .h-red {
            color: var(--red);
            font-weight: bold;
        }

        .story-text .h-blue {
            color: var(--blue);
            font-weight: bold;
        }

        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            transition: 0.3s;
        }

        .control-row.disabled {
            opacity: 0.5;
            pointer-events: none;
            filter: grayscale(1);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
            margin-bottom: 5px;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        button.primary {
            background: #2a2a2a;
            border-color: var(--accent);
            color: var(--accent);
        }

        button.primary:hover {
            background: var(--accent);
            color: #111;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
        }

        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        .nav-btn.next {
            background: var(--accent);
            color: #151515;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
        }

        .nav-btn.next:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #444;
        }

        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        /* Overlay for vector math visualization */
        #vector-hud {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 1px solid #444;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            pointer-events: none;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .bar-container {
            width: 80px;
            background: #333;
            height: 6px;
            margin-top: 6px;
            border-radius: 3px;
            overflow: hidden;
        }

        .bar {
            height: 100%;
            transition: width 0.1s;
        }
    </style>
</head>

<body>
    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Chapter 6: The Faraday Cage</div>
        </header>

        <div id="story-container">
            <div id="chapter-content"></div>
        </div>

        <div id="controls-area">
            <div class="control-row" id="ctrl-field">
                <label>Step 1: External Environment</label>
                <button class="primary" onclick="toggleExternalField()">Activate External Field (E-Ext)</button>
            </div>

            <div class="control-row disabled" id="ctrl-physics">
                <label>Step 2: Conductor Response</label>
                <input type="range" id="separation-slider" min="0" max="1" step="0.01" value="0">
                <div
                    style="font-size: 10px; color: #555; margin-top: 5px; display:flex; justify-content:space-between;">
                    <span>Random (Neutral)</span>
                    <span>Separated (Polarized)</span>
                </div>
            </div>

            <div class="control-row" style="margin-top:20px; border-top:1px solid #333; padding-top:15px;">
                <button onclick="resetSim()">Reset Simulation</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" disabled onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div id="vector-hud" style="opacity:0; transition: opacity 0.5s;">
            <div style="text-align:center; color:#888; margin-bottom:10px;">FIELD SENSOR (CENTER)</div>
            <div class="hud-row">
                <span style="color:var(--red)">E-External</span>
                <div class="bar-container">
                    <div class="bar" id="bar-ext" style="background:var(--red); width:0%"></div>
                </div>
            </div>
            <div class="hud-row">
                <span style="color:var(--blue)">E-Induced</span>
                <div class="bar-container">
                    <div class="bar" id="bar-ind" style="background:var(--blue); width:0%"></div>
                </div>
            </div>
            <div style="border-top:1px solid #555; margin:5px 0;"></div>
            <div class="hud-row">
                <span style="color:#fff; font-weight:bold;">E-NET</span>
                <div class="bar-container">
                    <div class="bar" id="bar-net" style="background:#fff; width:0%"></div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // --- 1. Scene Setup ---
        const state = {
            fieldActive: false,
            separation: 0, // 0 to 1
            time: 0
        };

        const scene = new THREE.Scene();
        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 40;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );
        camera.position.set(20, 15, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        document.getElementById('world').appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minZoom = 0.5;
        controls.maxZoom = 2;

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);

        // --- 2. Geometry: The Cage ---
        const cageRadius = 10;
        const cageGroup = new THREE.Group();
        scene.add(cageGroup);

        // Visual Cage (Wireframe + Transparent Shell)
        const geometry = new THREE.IcosahedronGeometry(cageRadius, 2);

        // Wireframe
        const wireframeMat = new THREE.MeshBasicMaterial({ color: 0x444444, wireframe: true, transparent: true, opacity: 0.3 });
        const cageMesh = new THREE.Mesh(geometry, wireframeMat);
        cageGroup.add(cageMesh);

        // Aesthetic Lattice (Thicker wires)
        const edges = new THREE.EdgesGeometry(geometry);
        const thickWireMat = new THREE.LineBasicMaterial({ color: 0x888888 });
        const wireLines = new THREE.LineSegments(edges, thickWireMat);
        cageGroup.add(wireLines);

        // --- 3. Particles (Electrons & Ions) ---
        const particleCount = 120;
        const electrons = [];
        const ions = [];

        // Materials
        const electronMat = new THREE.MeshStandardMaterial({ color: 0x74b9ff, emissive: 0x001133 }); // Blue
        const ionMat = new THREE.MeshStandardMaterial({ color: 0xff7675, emissive: 0x330000 }); // Red

        // Helper to place on sphere surface
        function getSpherePoint() {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            return new THREE.Vector3(
                cageRadius * Math.sin(phi) * Math.cos(theta),
                cageRadius * Math.cos(phi),
                cageRadius * Math.sin(phi) * Math.sin(theta)
            );
        }

        // Initialize Particles randomly
        for (let i = 0; i < particleCount; i++) {
            const pos = getSpherePoint();

            // Fixed Positive Ion (The lattice structure)
            const ion = new THREE.Mesh(new THREE.SphereGeometry(0.3), ionMat);
            ion.position.copy(pos);
            cageGroup.add(ion);
            ions.push({ mesh: ion, basePos: pos.clone() });

            // Mobile Electron (The sea of charge)
            const elec = new THREE.Mesh(new THREE.SphereGeometry(0.3), electronMat);
            elec.position.copy(pos);
            cageGroup.add(elec);

            // Store data for animation
            electrons.push({
                mesh: elec,
                basePos: pos.clone(), // Where it belongs physically in the lattice
                currentPos: pos.clone(),
                velocity: new THREE.Vector3()
            });
        }

        // --- 4. The External Field (Visuals) ---
        const fieldGroup = new THREE.Group();
        scene.add(fieldGroup);
        const arrows = [];

        for (let x = -25; x <= 25; x += 10) {
            for (let y = -15; y <= 15; y += 10) {
                for (let z = -15; z <= 15; z += 10) {
                    if (Math.abs(x) < 8 && Math.abs(y) < 8 && Math.abs(z) < 8) continue; // Skip inside cage

                    const dir = new THREE.Vector3(1, 0, 0); // Field moves +X
                    const arrow = new THREE.ArrowHelper(dir, new THREE.Vector3(x, y, z), 4, 0xff5555, 1, 0.5);
                    arrow.visible = false;
                    fieldGroup.add(arrow);
                    arrows.push({ mesh: arrow, baseX: x });
                }
            }
        }

        // --- 5. Internal Vector Visualization (The Math) ---
        const vecGroup = new THREE.Group();
        scene.add(vecGroup);

        // Red Arrow (External Field)
        const vecExt = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), 0, 0xff7675, 1, 1);
        vecGroup.add(vecExt);

        // Blue Arrow (Induced Field)
        const vecInd = new THREE.ArrowHelper(new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 0, 0), 0, 0x74b9ff, 1, 1);
        vecGroup.add(vecInd);

        // --- 6. Physics & Animation Logic ---

        function updatePhysics() {
            // Target positions based on state.separation
            // If separation = 1, electrons cluster on LEFT (-x), leaving + on RIGHT (+x).

            // We simulate this by defining a "Target" point for every electron.
            // If Field is ON, target is -X side. If OFF, target is basePos.

            const fieldStrength = state.fieldActive ? 1 : 0;

            // Update HUD
            const indMag = state.separation * 5; // Visual scale
            const extMag = fieldStrength * 5;
            const netMag = Math.max(0, extMag - indMag);

            // Update Arrow Helpers in Scene
            if (state.fieldActive) {
                vecExt.setLength(extMag, 2, 1);
                vecInd.setLength(indMag, 2, 1);

                // Opacity logic for sensor
                document.getElementById('vector-hud').style.opacity = 1;
                document.getElementById('bar-ext').style.width = '100%';
                document.getElementById('bar-ind').style.width = (state.separation * 100) + '%';
                document.getElementById('bar-net').style.width = ((1 - state.separation) * 100) + '%';
            } else {
                vecExt.setLength(0, 0, 0);
                vecInd.setLength(0, 0, 0);
                document.getElementById('vector-hud').style.opacity = 0;
            }

            // Animate Electrons
            electrons.forEach(e => {
                let target = e.basePos.clone();

                if (state.fieldActive) {
                    // Logic: Project position onto sphere, but biased towards -X
                    // Simple bias: Lerp the base position towards (-Radius, 0, 0) based on separation
                    const negativePole = new THREE.Vector3(-cageRadius, 0, 0);

                    const bias = new THREE.Vector3(-1, 0, 0).multiplyScalar(state.separation * 15);
                    const biasedPos = e.basePos.clone().add(bias);
                    target = biasedPos.normalize().multiplyScalar(cageRadius);
                }

                // Smooth movement
                e.mesh.position.lerp(target, 0.1);
            });

            // Animate Field Arrows (Flow effect)
            if (state.fieldActive) {
                const time = Date.now() * 0.001;
                arrows.forEach(a => {
                    a.mesh.visible = true;
                    // Wiggle effect to show "flow"
                    a.mesh.position.x = a.baseX + Math.sin(time * 5 + a.baseX) * 0.2;
                });
            } else {
                arrows.forEach(a => a.mesh.visible = false);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updatePhysics();
            renderer.render(scene, camera);
        }
        animate();

        // --- 7. Interactions ---

        function toggleExternalField() {
            state.fieldActive = true;
            document.querySelector('button[onclick="toggleExternalField()"]').parentElement.classList.add('disabled');
            checkAdvance();
        }

        document.getElementById('separation-slider').addEventListener('input', (e) => {
            state.separation = parseFloat(e.target.value);
            checkAdvance();
        });

        function resetSim() {
            state.fieldActive = false;
            state.separation = 0;
            document.getElementById('separation-slider').value = 0;
            document.querySelector('button[onclick="toggleExternalField()"]').parentElement.classList.remove('disabled');
            loadLesson(0);
        }

        // --- 8. Story Engine ---

        const lessons = [
            {
                title: "The External Threat",
                text: "We begin with a neutral conductive cage in empty space. <br><br>Click <strong>Activate External Field</strong> to apply a strong electric field ($E_{ext}$) moving from Left to Right (Red Arrows).<br><br>Notice that initially, the field lines penetrate the space. If you were inside, you would feel this force.",
                check: () => state.fieldActive,
                setup: () => {
                    document.getElementById('ctrl-physics').classList.add('disabled');
                }
            },
            {
                title: "Charge Migration",
                text: "This is a conductor. It is filled with free electrons (Blue) that can move.<br><br><strong>First Principle:</strong> An Electric Field applies a force $F = qE$.<br>Since electrons are negative, they feel a force to the <strong>Left</strong> (upstream against the Red field).<br><br>Use the slider to simulate the <strong>Conductor Response</strong>. As you drag it, watch the electrons migrate.",
                check: () => state.separation > 0.1,
                setup: () => {
                    document.getElementById('ctrl-physics').classList.remove('disabled');
                }
            },
            {
                title: "Conclusion",
                text: "Drag the slider to the max.<br><br>1. Electrons bunch up on the Left (-).<br>2. Positive ions are left exposed on the Right (+).<br><br>This separation creates a <strong>New Internal Field</strong> (Blue Arrow) pointing from + to - (Right to Left).<br><br>Look at the Sensor in the center. The Induced Field eventually equals the External Field in strength but opposite in direction. <br><br><strong>Net Field = 0.</strong> The cage has cancelled the field inside itself.",
                check: () => state.separation > 0.9,
                setup: () => {
                    document.getElementById('btn-next').innerText = "Next Lesson";
                }
            }
        ];

        let currentChapter = 0;

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Chapter 6: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div><div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');
            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson";
                btn.disabled = !l.check();
            } else {
                btn.innerHTML = "Next Step &rarr;";
                btn.disabled = !l.check();
            }
            if (l.setup) l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.location.href = '/theapplefalls/lessons/chapter5/9_shielding_appplications.html';
            }
        }

        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }

        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        window.addEventListener('resize', () => {
            aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * aspect / 2;
            camera.right = viewSize * aspect / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

        loadLesson(0);

    </script>
</body>

</html>