<!-- Combined HTML File -->


<!-- START: 1_field_energy.html -->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Maxwell's Notebook: Energy of the Field</title>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Load KaTeX for Math Rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body);"></script>

    <style>
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Maxwell Orange */
            --accent-hover: #e58e3c;
            --danger: #ff7675;
            --energy: #00cec9;
            /* Cyan for Energy Glow */
            --field-line: #ffdd59;
            /* Yellow for E-Field */
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* --- SIDEBAR --- */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 10;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.8);
        }

        header {
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid var(--border);
        }

        h1 {
            margin: 0;
            font-size: 18px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        #story-container {
            flex: 1;
            padding: 25px;
            overflow-y: auto;
        }

        .chapter-title {
            font-size: 22px;
            color: #fff;
            margin-bottom: 15px;
            border-left: 3px solid var(--accent);
            padding-left: 10px;
        }

        .text-content {
            line-height: 1.6;
            font-size: 14px;
            color: #ccc;
            text-align: justify;
            margin-bottom: 15px;
        }

        .text-content strong {
            color: #fff;
        }

        .text-content em {
            color: var(--accent);
            font-style: normal;
        }

        .math-block {
            background: #222;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #333;
            font-size: 1.1em;
            /* KaTeX will handle sizing */
            text-align: center;
            margin: 20px 0;
            color: var(--energy);
        }

        /* --- CONTROLS --- */
        #controls {
            background: #111;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        button {
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #444;
            padding: 12px;
            width: 100%;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
            text-transform: uppercase;
            font-size: 12px;
            margin-bottom: 10px;
        }

        button:hover {
            background: var(--accent);
            color: #111;
            border-color: var(--accent);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(1);
            box-shadow: none;
        }

        button.action-btn {
            border-color: var(--accent);
            color: var(--accent);
        }

        button.action-btn:hover {
            background: var(--accent);
            color: #111;
        }

        button.toggle-btn.active {
            background: var(--accent);
            color: #111;
        }

        #nav {
            padding: 15px;
            display: flex;
            gap: 10px;
            background: #000;
            border-top: 1px solid var(--border);
        }

        .nav-btn {
            flex: 1;
        }

        .next-btn {
            background: var(--accent);
            color: #111;
            border: none;
        }

        .next-btn:hover {
            background: #ffb875;
        }

        /* --- VIEWPORT & OVERLAYS --- */
        main {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: radial-gradient(circle at center, #1a1a1a 0%, #000 100%);
        }

        /* Energy Counter HUD */
        #energy-hud {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            width: 220px;
            font-family: 'Segoe UI', sans-serif;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        #charge-list {
            margin-bottom: 10px;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
            color: #aaa;
        }

        .hud-val {
            font-weight: bold;
            color: #fff;
            font-family: monospace;
        }

        .hud-total {
            border-top: 1px solid #555;
            padding-top: 8px;
            color: var(--energy);
            font-size: 14px;
        }

        /* Bar for Work Done */
        .bar-bg {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 5px;
        }

        .bar-fill {
            height: 100%;
            background: var(--energy);
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Chapter 11: Electrostatic Potential Energy</div>
        </header>
        <div id="story-container"></div>
        <div id="controls">
            <div id="dynamic-controls"></div>
        </div>
        <div id="nav">
            <button class="nav-btn" onclick="prevStep()">Back</button>
            <button class="nav-btn next-btn" id="btn-next" onclick="nextStep()">Next</button>
        </div>
    </aside>

    <main id="viewport">
        <div id="energy-hud">
            <div id="charge-list"></div>
            <div class="hud-row"><span>Work (W):</span> <span class="hud-val" id="val-work">0.0 J</span></div>
            <div class="bar-bg">
                <div class="bar-fill" id="bar-work"></div>
            </div>
            <div class="hud-row hud-total" style="margin-top:10px">
                <span>System Energy (U):</span> <span class="hud-val" id="val-total">0.00</span>
            </div>
        </div>
    </main>

    <script>
        // --- CONFIGURATION ---
        const config = {
            sceneIndex: 0,
            showFieldLines: false,
            showEnergyDensity: false,
            animatingChargeIndex: -1,
        };

        // --- THREE.JS SETUP ---
        const viewport = document.getElementById('viewport');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, viewport.offsetWidth / viewport.offsetHeight, 0.1, 500);
        camera.position.set(0, 15, 30);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(viewport.offsetWidth, viewport.offsetHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        viewport.appendChild(renderer.domElement);
        const orbit = new THREE.OrbitControls(camera, renderer.domElement);
        orbit.enableDamping = true;
        scene.add(new THREE.AmbientLight(0x606060));
        const pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(10, 20, 10);
        scene.add(pointLight);

        // --- OBJECTS ---
        const grid = new THREE.GridHelper(40, 40, 0x333333, 0x111111);
        scene.add(grid);

        const chargeGeo = new THREE.SphereGeometry(0.8, 32, 32);
        const posMat = new THREE.MeshStandardMaterial({ color: 0xff4444, emissive: 0x550000, roughness: 0.2, metalness: 0.5 });

        function createCharge(x, z, visible = false) {
            const mesh = new THREE.Mesh(chargeGeo, posMat);
            mesh.position.set(x, 0, z);
            mesh.visible = visible;
            return mesh;
        }

        const arrowHelper = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), 1, 0xffff00);
        arrowHelper.visible = false;
        scene.add(arrowHelper);

        // --- ENERGY CLOUD SYSTEM ---
        // Generate a soft glow texture procedurally
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grd = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grd.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grd.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            grd.addColorStop(0.5, 'rgba(0, 206, 201, 0.4)'); // Cyan
            grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, 32, 32);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        const particleCount = 2000; // Increase count for density
        const cloudGeo = new THREE.PlaneGeometry(1, 1);
        const cloudMat = new THREE.MeshBasicMaterial({
            map: createGlowTexture(),
            color: 0xffffff,
            transparent: true,
            opacity: 0.8, // Base opacity, modulation happens via scale/color
            side: THREE.DoubleSide,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const energyCloud = new THREE.InstancedMesh(cloudGeo, cloudMat, particleCount);
        energyCloud.visible = false;
        // Allow per-instance color
        energyCloud.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(particleCount * 3), 3);

        scene.add(energyCloud);

        const dummy = new THREE.Object3D();
        const colorDummy = new THREE.Color();
        // Distribute particles in a volume around the origin
        const particlePositions = Array.from({ length: particleCount }, () => new THREE.Vector3(
            (Math.random() - 0.5) * 35,
            (Math.random() - 0.5) * 15,
            (Math.random() - 0.5) * 35
        ));

        // Electric Field Lines Group
        const fieldLinesGroup = new THREE.Group();
        scene.add(fieldLinesGroup);
        const fieldLineMat = new THREE.LineBasicMaterial({ color: 0xffdd59, transparent: true, opacity: 0.5 });


        // --- SCENE STATE MANAGEMENT ---
        let charges = [];
        let isAnimating = false;
        let totalEnergy = 0;

        function resetSimulation() {
            charges.forEach(c => scene.remove(c));
            charges = [];
            totalEnergy = 0;
            arrowHelper.visible = false;
            energyCloud.visible = false;
            fieldLinesGroup.clear();
            config.showEnergyDensity = false;
            config.showFieldLines = false;
            updateHUD();
        }

        function calculateTotalEnergy() {
            let energy = 0;
            if (charges.length < 2) return 0;
            for (let i = 0; i < charges.length; i++) {
                for (let j = i + 1; j < charges.length; j++) {
                    const dist = charges[i].position.distanceTo(charges[j].position);
                    if (dist > 0) energy += 10 / dist;
                }
            }
            return energy;
        }

        function addCharge(targetPos, animateFromInfinity = true) {
            if (isAnimating) return;
            isAnimating = true;

            const c = createCharge(animateFromInfinity ? 40 : targetPos.x, targetPos.z, true);
            scene.add(c);
            charges.push(c);
            config.animatingChargeIndex = charges.length - 1;

            if (charges.length > 1) {
                document.getElementById('energy-hud').style.opacity = 1;
            }

            if (animateFromInfinity) {
                const startPos = c.position.clone();
                const endPos = targetPos;
                let progress = 0;
                const prevTotalEnergy = calculateTotalEnergy();

                function animateMove() {
                    progress += 0.01;
                    if (progress >= 1) {
                        c.position.copy(endPos);
                        isAnimating = false;
                        arrowHelper.visible = false;
                        config.animatingChargeIndex = -1;
                        totalEnergy = calculateTotalEnergy();
                        updateHUD(0, totalEnergy);
                        updateVisuals();
                        if (document.querySelector('.action-btn')) document.querySelector('.action-btn').disabled = false;
                        if (document.getElementById('btn-next')) document.getElementById('btn-next').disabled = false;
                        return;
                    }

                    c.position.lerpVectors(startPos, endPos, progress);

                    let workDoneThisStep = 0;
                    let force = new THREE.Vector3();
                    for (let i = 0; i < charges.length - 1; i++) {
                        const other = charges[i];
                        const dir = new THREE.Vector3().subVectors(c.position, other.position);
                        const dist = dir.length();
                        dir.normalize();
                        force.add(dir.multiplyScalar(20 / (dist * dist)));
                        workDoneThisStep += 10 / dist;
                    }

                    arrowHelper.position.copy(c.position);
                    arrowHelper.setDirection(force.normalize().negate());
                    arrowHelper.setLength(Math.min(force.length() * 0.5, 5));
                    arrowHelper.visible = true;

                    updateHUD(workDoneThisStep, prevTotalEnergy);
                    updateVisuals();
                    requestAnimationFrame(animateMove);
                }
                animateMove();
            } else {
                isAnimating = false;
                config.animatingChargeIndex = -1;
                totalEnergy = calculateTotalEnergy();
                updateHUD(0, totalEnergy);
                updateVisuals();
            }
        }

        function updateHUD(work = 0, total = totalEnergy) {
            const hudWork = document.getElementById('val-work');
            const hudTotal = document.getElementById('val-total');
            const bar = document.getElementById('bar-work');
            const chargeListDiv = document.getElementById('charge-list');

            chargeListDiv.innerHTML = '';
            charges.forEach((charge, i) => {
                let status = 'FIXED';
                if (i === config.animatingChargeIndex) {
                    status = 'INCOMING...';
                }
                chargeListDiv.innerHTML += `<div class="hud-row"><span>Charge Q${i + 1}:</span> <span class="hud-val">${status}</span></div>`;
            });

            hudWork.innerText = work > 0 ? `+${work.toFixed(2)} J` : `0.00 J`;
            hudTotal.innerText = total.toFixed(2) + " J";

            const pct = Math.min((work / 10) * 100, 100);
            bar.style.width = pct + "%";
        }

        function calculateEField(pos) {
            const E = new THREE.Vector3();
            charges.forEach(c => {
                const rVec = new THREE.Vector3().subVectors(pos, c.position);
                const r = rVec.length();
                if (r > 0.5) {
                    E.add(rVec.normalize().multiplyScalar(1 / (r * r)));
                }
            });
            return E;
        }

        // --- FIX: Energy Cloud Logic ---
        function updateEnergyCloud() {
            if (!config.showEnergyDensity || charges.length === 0) {
                energyCloud.visible = false;
                return;
            }
            energyCloud.visible = true;

            for (let i = 0; i < particleCount; i++) {
                const pos = particlePositions[i];
                const E = calculateEField(pos);
                const magSq = E.lengthSq(); // Proportional to Energy Density

                // Adjust visual scale based on energy density
                // Higher energy = larger, brighter blob
                const scale = Math.min(Math.sqrt(magSq) * 4, 3.0);

                // Only show if field is significant enough
                if (scale < 0.1) {
                    dummy.scale.set(0, 0, 0);
                } else {
                    dummy.position.copy(pos);
                    dummy.lookAt(camera.position); // Billboard to face camera
                    dummy.scale.set(scale, scale, 1);

                    // Color mapping: Low energy = Cyan, High energy = White
                    const intensity = Math.min(magSq * 0.5, 1.0);
                    colorDummy.setHSL(0.5, 1.0, 0.5 + (intensity * 0.5)); // 0.5 is Cyan hue
                    energyCloud.setColorAt(i, colorDummy);
                }

                dummy.updateMatrix();
                energyCloud.setMatrixAt(i, dummy.matrix);
            }
            energyCloud.instanceMatrix.needsUpdate = true;
            if (energyCloud.instanceColor) energyCloud.instanceColor.needsUpdate = true;
        }

        function updateFieldLines() {
            fieldLinesGroup.clear();
            if (!config.showFieldLines || charges.length === 0) return;

            const numLinesPerCharge = 16;
            const stepSize = 0.5;
            const maxSteps = 100;

            charges.forEach(charge => {
                for (let i = 0; i < numLinesPerCharge; i++) {
                    const points = [];
                    const startVec = new THREE.Vector3().setFromSphericalCoords(0.9, Math.PI * Math.random(), 2 * Math.PI * Math.random());
                    let currentPos = charge.position.clone().add(startVec);
                    points.push(currentPos.clone());

                    for (let j = 0; j < maxSteps; j++) {
                        const E = calculateEField(currentPos);
                        if (E.length() < 0.001) break;
                        currentPos.add(E.normalize().multiplyScalar(stepSize));
                        points.push(currentPos.clone());
                        if (currentPos.length() > 30) break;
                    }
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, fieldLineMat);
                    fieldLinesGroup.add(line);
                }
            });
        }

        function updateVisuals() {
            if (config.showEnergyDensity) updateEnergyCloud();
            if (config.showFieldLines) updateFieldLines();
        }

        // --- ANIMATION LOOP ---
        function animateScene() {
            requestAnimationFrame(animateScene);
            orbit.update();
            if (config.showEnergyDensity && !isAnimating) updateEnergyCloud();
            renderer.render(scene, camera);
        }
        animateScene();


        // --- STORY ENGINE ---
        const steps = [
            {
                title: "An Empty Universe",
                text: "Imagine a universe completely devoid of charge and energy. Its total energy is, by definition, zero.<br><br>Now, let's bring our first positive charge, <strong>Q1</strong>, from infinitely far away. Since there are no existing electric fields to push against, it takes <strong>no work</strong> to place it.",
                controls: `<button class="action-btn" onclick="stepAction(0)">Place Charge Q1</button>`,
                action: () => addCharge(new THREE.Vector3(-4, 0, 0), false),
                setup: () => {
                    resetSimulation();
                    document.getElementById('energy-hud').style.opacity = 0;
                }
            },
            {
                title: "Work Against the Field",
                text: "Now Q1 exists, creating an electric field around it. Let's bring in a second positive charge, <strong>Q2</strong>. To move it closer to Q1, we must do work against their mutual repulsion.<br><br>The work we do is stored in the system as <em>potential energy</em>. Watch the HUD as Q2 approaches.",
                controls: `<button class="action-btn" onclick="stepAction(1)">Bring in Charge Q2</button>`,
                action: () => addCharge(new THREE.Vector3(4, 0, 0), true),
                setup: () => { if (charges.length === 0) addCharge(new THREE.Vector3(-4, 0, 0), false); }
            },
            {
                title: "Energy of Configuration",
                text: `The work done to assemble this pair becomes the potential energy $U$ of the system. This energy depends on the charges and the distance $r$ between them.
                   <div class="math-block">$$ U = W = \\frac{k Q_1 Q_2}{r} $$</div>
                   Now, let's add a third charge, <strong>Q3</strong>. We must do work against the fields of <em>both</em> Q1 and Q2. The total system energy will be the sum of all pairwise interactions.`,
                controls: `<button class="action-btn" onclick="stepAction(2)">Bring in Charge Q3</button>`,
                action: () => addCharge(new THREE.Vector3(0, 0, 5), true),
                setup: () => { if (charges.length < 2) { addCharge(new THREE.Vector3(-4, 0, 0), false); addCharge(new THREE.Vector3(4, 0, 0), false); } }
            },
            {
                title: "A Revolutionary Idea",
                text: `So far, we've treated energy as an abstract property of the *arrangement* of charges. But James Clerk Maxwell proposed something profound: the energy is not an abstract property, but is physically stored <strong>in the electric field itself.</strong><br><br>Where the field is strong, the energy is dense. Where the field is weak, the energy is sparse.`,
                controls: ``,
                setup: () => { }
            },
            {
                title: "Energy Density of the Field",
                text: `Maxwell showed that the energy density $u$ (energy per unit volume) at any point in space is proportional to the square of the electric field strength $E$ at that point.
                   <div class="math-block">$$ u = \\frac{1}{2} \\epsilon_0 E^2 $$</div>
                   This means we have two ways to calculate the total energy:
                   <br>1. Sum the work for each charge pair (what we did).
                   <br>2. Integrate the energy density $u$ over all of space.
                   <br><br>Remarkably, <strong>both methods give the exact same result.</strong>`,
                controls: `
                <div class="controls-grid">
                    <button id="btn-toggle-field" class="toggle-btn" onclick="toggleFieldLines(this)">Show E-Field Lines</button>
                    <button id="btn-toggle-density" class="toggle-btn" onclick="toggleEnergyDensity(this)">Show Energy Density</button>
                </div>`,
                setup: () => {
                    if (charges.length < 3) {
                        addCharge(new THREE.Vector3(-4, 0, 0), false);
                        addCharge(new THREE.Vector3(4, 0, 0), false);
                        addCharge(new THREE.Vector3(0, 0, 5), false);
                    }
                    updateVisuals();
                }
            },
            {
                title: "Conclusion",
                text: "This equivalence is a cornerstone of physics. It tells us that the electric field is not just a mathematical tool for calculating forces; it is a real, physical entity that carries energy and momentum.<br><br>This concept of energy stored in fields is fundamental to understanding light (electromagnetic waves) and modern physics, including Einstein's famous equation relating mass and energy.",
                controls: `<button onclick="loadStep(0)">Restart Experiment</button>`,
                setup: () => {
                    config.showFieldLines = true;
                    config.showEnergyDensity = true;
                    document.getElementById('btn-toggle-field')?.classList.add('active');
                    document.getElementById('btn-toggle-density')?.classList.add('active');
                    updateVisuals();
                }
            }
        ];

        let currentStep = 0;

        function loadStep(idx) {
            if (isAnimating) return;
            currentStep = idx;
            const s = steps[idx];

            document.getElementById('story-container').innerHTML = `
            <div class="chapter-title">${s.title}</div>
            <div class="text-content">${s.text}</div>
        `;
            document.getElementById('dynamic-controls').innerHTML = s.controls;

            renderMathInElement(document.getElementById('story-container'), {
                delimiters: [{ left: "$$", right: "$$", display: true }]
            });

            s.setup();

            document.getElementById('btn-next').disabled = (idx >= steps.length - 1);
        }

        function nextStep() { if (currentStep < steps.length - 1) loadStep(currentStep + 1); }
        function prevStep() { if (currentStep > 0) loadStep(currentStep - 1); }

        window.stepAction = (stepIndex) => {
            const actionFn = steps[stepIndex].action;
            if (actionFn) {
                actionFn();
                const btn = document.querySelector('button.action-btn');
                if (btn) btn.disabled = true;
            }
        };

        window.toggleEnergyDensity = (btn) => {
            config.showEnergyDensity = !config.showEnergyDensity;
            btn.classList.toggle('active', config.showEnergyDensity);
            energyCloud.visible = config.showEnergyDensity;
            if (config.showEnergyDensity) updateEnergyCloud();
        };

        window.toggleFieldLines = (btn) => {
            config.showFieldLines = !config.showFieldLines;
            btn.classList.toggle('active', config.showFieldLines);
            fieldLinesGroup.visible = config.showFieldLines;
            if (config.showFieldLines) updateFieldLines();
        };

        loadStep(0);

        window.addEventListener('resize', () => {
            camera.aspect = viewport.offsetWidth / viewport.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewport.offsetWidth, viewport.offsetHeight);
        });

    </script>
</body>

</html>
<!-- END: 1_field_energy.html -->

<!-- START: 2_Energy_Density.html -->


<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Maxwell's Notebook: Field Energy Density</title>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Load KaTeX for Math Rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body);"></script>

    <style>
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Maxwell Orange */
            --accent-hover: #e58e3c;
            --danger: #ff7675;
            --energy: #00cec9;
            /* Cyan for Energy Glow */
            --field-line: #ffdd59;
            /* Yellow for E-Field */
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* --- SIDEBAR --- */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 10;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.8);
        }

        header {
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid var(--border);
        }

        h1 {
            margin: 0;
            font-size: 18px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        #story-container {
            flex: 1;
            padding: 25px;
            overflow-y: auto;
        }

        .chapter-title {
            font-size: 22px;
            color: #fff;
            margin-bottom: 15px;
            border-left: 3px solid var(--accent);
            padding-left: 10px;
        }

        .text-content {
            line-height: 1.6;
            font-size: 14px;
            color: #ccc;
            text-align: justify;
            margin-bottom: 15px;
        }

        .text-content strong {
            color: #fff;
        }

        .text-content em {
            color: var(--accent);
            font-style: normal;
        }

        .math-block {
            background: #222;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #333;
            font-size: 1.1em;
            /* KaTeX will handle sizing */
            text-align: center;
            margin: 20px 0;
            color: var(--energy);
        }

        /* --- CONTROLS --- */
        #controls {
            background: #111;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        button {
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #444;
            padding: 12px;
            width: 100%;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
            text-transform: uppercase;
            font-size: 12px;
            margin-bottom: 10px;
        }

        button:hover {
            background: var(--accent);
            color: #111;
            border-color: var(--accent);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(1);
            box-shadow: none;
        }

        button.action-btn {
            border-color: var(--accent);
            color: var(--accent);
        }

        button.action-btn:hover {
            background: var(--accent);
            color: #111;
        }

        button.toggle-btn.active {
            background: var(--accent);
            color: #111;
        }

        input[type=range] {
            width: 100%;
            margin: 10px 0;
            accent-color: var(--accent);
        }

        label {
            font-size: 12px;
            text-transform: uppercase;
            color: #888;
            display: block;
            margin-top: 10px;
        }

        #nav {
            padding: 15px;
            display: flex;
            gap: 10px;
            background: #000;
            border-top: 1px solid var(--border);
        }

        .nav-btn {
            flex: 1;
        }

        .next-btn {
            background: var(--accent);
            color: #111;
            border: none;
        }

        .next-btn:hover {
            background: #ffb875;
        }

        /* --- VIEWPORT & OVERLAYS --- */
        main {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: radial-gradient(circle at center, #1a1a1a 0%, #000 100%);
        }

        /* Energy Counter HUD */
        #energy-hud {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            width: 240px;
            font-family: 'Segoe UI', sans-serif;
            pointer-events: none;
            opacity: 1;
            transition: opacity 0.5s;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
            color: #aaa;
        }

        .hud-val {
            font-weight: bold;
            color: #fff;
            font-family: monospace;
        }

        .hud-total {
            border-top: 1px solid #555;
            padding-top: 8px;
            color: var(--energy);
            font-size: 14px;
        }

        /* Bar for Field Strength */
        .bar-bg {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 5px;
            margin-bottom: 10px;
        }

        .bar-fill {
            height: 100%;
            background: var(--energy);
            width: 0%;
            transition: width 0.1s;
        }

        .bar-fill.warm {
            background: var(--accent);
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Chapter 12: Field Energy Density</div>
        </header>
        <div id="story-container"></div>
        <div id="controls">
            <div id="dynamic-controls"></div>
        </div>
        <div id="nav">
            <button class="nav-btn" onclick="prevStep()">Back</button>
            <button class="nav-btn next-btn" id="btn-next" onclick="nextStep()">Next</button>
        </div>
    </aside>

    <main id="viewport">
        <div id="energy-hud">
            <div class="hud-row"><span>Unit Volume (V):</span> <span class="hud-val">1.0 m続</span></div>
            <div class="hud-row"><span>Avg E-Field (E):</span> <span class="hud-val" id="val-e">0.0 N/C</span></div>
            <div class="bar-bg">
                <div class="bar-fill warm" id="bar-e"></div>
            </div>

            <div class="hud-row"><span>Work Done (W):</span> <span class="hud-val" id="val-work">0.0 J</span></div>

            <div class="hud-row hud-total" style="margin-top:10px">
                <span>Energy Density (u):</span> <span class="hud-val" id="val-u">0.00 J/m続</span>
            </div>
            <div class="bar-bg">
                <div class="bar-fill" id="bar-u"></div>
            </div>
        </div>
    </main>

    <script>
        // --- THREE.JS SETUP ---
        const viewport = document.getElementById('viewport');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, viewport.offsetWidth / viewport.offsetHeight, 0.1, 500);
        camera.position.set(10, 10, 20);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(viewport.offsetWidth, viewport.offsetHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        viewport.appendChild(renderer.domElement);
        const orbit = new THREE.OrbitControls(camera, renderer.domElement);
        orbit.enableDamping = true;
        orbit.target.set(0, 2, 0);

        // Lighting
        scene.add(new THREE.AmbientLight(0x404040));
        const pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(10, 20, 10);
        scene.add(pointLight);

        // Grid
        const grid = new THREE.GridHelper(40, 40, 0x333333, 0x111111);
        scene.add(grid);

        // --- SCENE OBJECTS ---

        // 1. The Source Charge (visualized as a sphere)
        const chargeGeo = new THREE.SphereGeometry(1, 32, 32);
        const chargeMat = new THREE.MeshStandardMaterial({
            color: 0xff4444, emissive: 0x550000,
            roughness: 0.2, metalness: 0.5
        });
        const sourceCharge = new THREE.Mesh(chargeGeo, chargeMat);
        sourceCharge.position.set(-6, 0, 0); // Positioned to the left
        scene.add(sourceCharge);

        // 2. The "Unit Volume" (A wireframe cube)
        const boxSize = 4;
        const boxGeo = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
        const boxMat = new THREE.MeshBasicMaterial({ color: 0x00cec9, wireframe: true, transparent: true, opacity: 0.3 });
        const controlVolume = new THREE.Mesh(boxGeo, boxMat);
        controlVolume.position.set(4, boxSize / 2, 0); // Positioned to the right
        scene.add(controlVolume);

        // Label for the Box
        // (Simple sprite text could go here, but omitted for code brevity)

        // 3. Volumetric Energy Cloud (Particles inside the box)
        const particleCount = 1000;
        const dummy = new THREE.Object3D();
        const instancedGeo = new THREE.PlaneGeometry(0.2, 0.2);
        const instancedMat = new THREE.MeshBasicMaterial({
            color: 0x00cec9, transparent: true, opacity: 0.8,
            blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide
        });
        const energyParticles = new THREE.InstancedMesh(instancedGeo, instancedMat, particleCount);
        energyParticles.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(particleCount * 3), 3);

        // Distribute particles strictly INSIDE the control volume
        const particleData = [];
        for (let i = 0; i < particleCount; i++) {
            const x = (Math.random() - 0.5) * boxSize;
            const y = (Math.random() - 0.5) * boxSize;
            const z = (Math.random() - 0.5) * boxSize;
            particleData.push({ localPos: new THREE.Vector3(x, y, z) });
            dummy.position.set(x, y, z); // Initial dummy pos
            dummy.updateMatrix();
            energyParticles.setMatrixAt(i, dummy.matrix);
        }
        controlVolume.add(energyParticles); // Add particles as child of the box

        // 4. Field Vectors inside the box
        const arrowCount = 27; // 3x3x3 grid
        const arrowHelperGroup = new THREE.Group();
        controlVolume.add(arrowHelperGroup);

        const arrowHelpers = [];
        for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
                for (let z = -1; z <= 1; z++) {
                    const dir = new THREE.Vector3(1, 0, 0);
                    const origin = new THREE.Vector3(x * (boxSize / 2.5), y * (boxSize / 2.5), z * (boxSize / 2.5));
                    const arrow = new THREE.ArrowHelper(dir, origin, 1, 0xffdd59, 0.4, 0.2);
                    arrowHelperGroup.add(arrow);
                    arrowHelpers.push({ arrow: arrow, origin: origin });
                }
            }
        }


        // --- SIMULATION LOGIC ---

        let chargeMagnitude = 0; // Starts at 0
        let isPulse = false;

        function updatePhysics() {
            // 1. Calculate Field from Source Charge at the center of the box
            // E = kQ / r^2
            // We will simulate the source charge strength

            let totalEnergyInBox = 0;
            let avgE = 0;
            const tempColor = new THREE.Color();

            // Update Particles (Energy Density)
            for (let i = 0; i < particleCount; i++) {
                const p = particleData[i];

                // World position of this particle
                const worldPos = p.localPos.clone().applyMatrix4(controlVolume.matrixWorld);
                const rVec = new THREE.Vector3().subVectors(worldPos, sourceCharge.position);
                const r = rVec.length();

                // E-field magnitude at this particle
                // Model: E = Q / r^2
                const E = (chargeMagnitude * 20) / (r * r);

                // Energy Density: u = 0.5 * eps * E^2
                const u = 0.5 * E * E;

                // Visualization scaling
                const scale = Math.min(u * 2, 2.0); // Cap size

                dummy.position.copy(p.localPos);
                dummy.lookAt(camera.position); // Billboarding (kinda, relative to box)
                dummy.scale.set(scale, scale, 1);
                dummy.updateMatrix();
                energyParticles.setMatrixAt(i, dummy.matrix);

                // Color: Cyan (low) -> White (high)
                tempColor.setHSL(0.5, 1.0, 0.5 + Math.min(u, 0.5));
                energyParticles.setColorAt(i, tempColor);

                totalEnergyInBox += u; // Summing up samples (integration approx)
            }

            energyParticles.instanceMatrix.needsUpdate = true;
            if (energyParticles.instanceColor) energyParticles.instanceColor.needsUpdate = true;

            // Update Field Arrows (Visual Guide)
            arrowHelpers.forEach(item => {
                const worldPos = item.origin.clone().applyMatrix4(controlVolume.matrixWorld);
                const rVec = new THREE.Vector3().subVectors(worldPos, sourceCharge.position);
                const r = rVec.length();
                const E_mag = (chargeMagnitude * 20) / (r * r);

                if (chargeMagnitude > 0.1) {
                    item.arrow.visible = true;
                    item.arrow.setDirection(rVec.normalize());
                    item.arrow.setLength(Math.min(E_mag * 0.5, 1.5)); // Visual length cap
                } else {
                    item.arrow.visible = false;
                }
                avgE += E_mag;
            });
            avgE /= arrowHelpers.length;

            // Update HUD
            const volume = boxSize * boxSize * boxSize; // 64 virtual units
            // Normalize numbers for display
            const displayE = avgE * 10;
            const displayU = (totalEnergyInBox / particleCount) * 100; // Scaled for readability
            const totalWork = displayU * volume; // Total Energy

            document.getElementById('val-e').innerText = displayE.toFixed(1) + " N/C";
            document.getElementById('bar-e').style.width = Math.min(displayE, 100) + "%";

            document.getElementById('val-u').innerText = displayU.toFixed(2) + " J/m続";
            document.getElementById('bar-u').style.width = Math.min(displayU, 100) + "%";

            document.getElementById('val-work').innerText = totalWork.toFixed(1) + " J";

            // Pulse Effect on Charge
            if (isPulse) {
                const s = 1 + Math.sin(Date.now() * 0.005) * 0.05;
                sourceCharge.scale.set(s, s, s);
                sourceCharge.material.emissiveIntensity = chargeMagnitude * 0.5 + 0.2;
            } else {
                sourceCharge.material.emissiveIntensity = 0;
            }
        }

        function setCharge(val) {
            chargeMagnitude = val;
            isPulse = val > 0;
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            orbit.update();
            updatePhysics();
            renderer.render(scene, camera);
        }
        animate();


        // --- STORY ENGINE ---
        const steps = [
            {
                title: "The Empty Volume",
                text: `Consider the wireframe box on the right. It represents a <strong>Unit Volume</strong> (1 m続) of empty space.<br><br>Currently, there is no electric field inside it. Because the space is empty and relaxed, the energy stored here is <strong>zero</strong>.`,
                controls: `<div style="text-align:center; color:#666; font-style:italic; padding:10px;">(No field present)</div>`,
                setup: () => { setCharge(0); }
            },
            {
                title: "Doing Work on the Field",
                text: `To create an electric field inside this box, we must perform <strong>work</strong>. We do this by bringing a large charge (the red sphere) nearby.<br><br>As we increase the charge, we "stress" the space inside the box. Use the slider to increase the Field Strength ($E$). Notice how the "Work Done" counter increases.`,
                controls: `
                <label>Source Charge Magnitude (Creates E-Field)</label>
                <input type="range" min="0" max="5" step="0.1" value="0" oninput="setCharge(this.value)">
            `,
                setup: () => { setCharge(0); }
            },
            {
                title: "Defining Energy Density",
                text: `The work we just did isn't lost. It is stored <strong>in the field itself</strong> inside that box.<br><br>We define the <strong>Energy Density ($u$)</strong> as the amount of stored energy per unit volume:
            <div class="math-block">$$ u = \\frac{\\text{Energy stored inside volume}}{\\text{Volume}} $$</div>
            The SI unit is Joules per cubic meter ($J/m^3$).`,
                controls: `
                <label>Source Charge Magnitude</label>
                <input type="range" min="0" max="5" step="0.1" value="2.5" oninput="setCharge(this.value)">
            `,
                setup: () => { setCharge(2.5); }
            },
            {
                title: "The Quadratic Relationship",
                text: `Maxwell calculated the exact formula for this density in a vacuum:
            <div class="math-block">$$ u = \\frac{1}{2} \\epsilon_0 E^2 $$</div>
            Notice the $E^2$. This means if you <strong>double</strong> the Field Strength, the Energy Density quadruples.<br><br>Try maximizing the slider. The energy density (cyan glow) becomes intense very quickly.`,
                controls: `
                 <label>Source Charge Magnitude</label>
                <input type="range" min="0" max="10" step="0.1" value="2.5" oninput="setCharge(this.value)">
            `,
                setup: () => { setCharge(2.5); }
            }
        ];

        let currentStep = 0;

        function loadStep(idx) {
            currentStep = idx;
            const s = steps[idx];

            document.getElementById('story-container').innerHTML = `
            <div class="chapter-title">${s.title}</div>
            <div class="text-content">${s.text}</div>
        `;
            document.getElementById('dynamic-controls').innerHTML = s.controls;

            renderMathInElement(document.getElementById('story-container'), {
                delimiters: [{ left: "$$", right: "$$", display: true }]
            });

            s.setup();
            document.getElementById('btn-next').disabled = (idx >= steps.length - 1);
        }

        function nextStep() { if (currentStep < steps.length - 1) loadStep(currentStep + 1); }
        function prevStep() { if (currentStep > 0) loadStep(currentStep - 1); }

        loadStep(0);

        window.addEventListener('resize', () => {
            camera.aspect = viewport.offsetWidth / viewport.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewport.offsetWidth, viewport.offsetHeight);
        });

    </script>
</body>

</html>
<!-- END: 2_Energy_Density.html -->

<!-- START: 3_Capacitance.html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Maxwell's Notebook: The Nature of Capacity</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- KaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body);"></script>

    <style>
        :root {
            --bg: #111;
            --panel: #1a1a1a;
            --text: #ddd;
            --accent: #ff9f43;
            --danger: #e74c3c;
            --charge: #3498db;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* --- SIDEBAR --- */
        aside {
            width: 450px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        header {
            padding: 25px;
            border-bottom: 1px solid var(--border);
        }

        h1 {
            margin: 0;
            font-size: 14px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            font-size: 15px;
            line-height: 1.7;
            color: #ccc;
        }

        .chapter-title {
            font-size: 22px;
            color: #fff;
            margin-bottom: 20px;
            font-weight: 300;
        }

        strong {
            color: #fff;
            font-weight: 600;
        }

        /* KaTeX Corrections */
        .katex-display {
            margin: 1em 0;
            overflow-x: auto;
            overflow-y: hidden;
        }

        /* --- CONTROLS --- */
        #controls {
            background: #000;
            padding: 25px;
            border-top: 1px solid var(--border);
        }

        button {
            background: #252525;
            color: #fff;
            border: 1px solid #444;
            padding: 14px;
            width: 100%;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
            text-transform: uppercase;
            font-size: 12px;
            margin-top: 15px;
            letter-spacing: 1px;
            border-radius: 4px;
        }

        button:hover {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
        }

        button:disabled {
            opacity: 0.3;
            cursor: default;
        }

        button.pump-btn {
            border-color: var(--charge);
            color: var(--charge);
        }

        button.pump-btn:hover {
            background: var(--charge);
            color: #fff;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
            margin: 10px 0;
            cursor: pointer;
        }

        label {
            font-size: 11px;
            text-transform: uppercase;
            color: #888;
            display: block;
            margin-top: 5px;
            letter-spacing: 1px;
        }

        #nav {
            padding: 20px;
            display: flex;
            gap: 15px;
            background: #080808;
            border-top: 1px solid var(--border);
        }

        .nav-btn {
            flex: 1;
            margin: 0;
        }

        .next-btn {
            background: var(--accent);
            color: #111;
            border: none;
        }

        .next-btn:hover {
            background: #ffb875;
        }

        /* --- VIEWPORT --- */
        main {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: radial-gradient(circle at center, #222 0%, #000 90%);
        }

        #flash-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #fff;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.05s;
        }

        #legend {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border: 1px solid #333;
            border-radius: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            pointer-events: none;
        }

        .glow-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #3498db;
            box-shadow: 0 0 10px #3498db;
        }

        #status-light {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #333;
            box-shadow: 0 0 5px #000;
            transition: background 0.2s, box-shadow 0.2s;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Lesson 3: The Single Conductor</div>
        </header>

        <div id="story-container"></div>

        <div id="controls">
            <div id="dynamic-controls"></div>
        </div>
        <div id="nav">
            <button class="nav-btn" onclick="prevStep()">Back</button>
            <button class="nav-btn next-btn" id="btn-next" onclick="nextStep()">Next</button>
        </div>
    </aside>

    <main id="viewport">
        <div id="status-light"></div>
        <div id="legend">
            <div class="glow-dot"></div>
            <span>Glow Intensity = Electric Field Strength</span>
        </div>
        <div id="flash-overlay"></div>
    </main>

    <script>
        // --- AUDIO SYSTEM ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let humOsc = null;
        let humGain = null;

        function initAudio() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            if (!humOsc) {
                humOsc = audioCtx.createOscillator();
                humGain = audioCtx.createGain();
                humOsc.type = 'sine';
                humOsc.frequency.value = 60; // Low hum
                humGain.gain.value = 0;
                humOsc.connect(humGain);
                humGain.connect(audioCtx.destination);
                humOsc.start();
            }
        }

        function updateHum(stressLevel) {
            if (!humGain) return;
            const pitch = 60 + (stressLevel * 200);
            const vol = Math.min(stressLevel * 0.1, 0.15);
            humOsc.frequency.setTargetAtTime(pitch, audioCtx.currentTime, 0.1);
            humGain.gain.setTargetAtTime(vol, audioCtx.currentTime, 0.1);
        }

        function playSparkSound() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.15);
            gain.gain.setValueAtTime(0.8, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.2);
        }

        // --- THREE.JS SETUP ---
        const viewport = document.getElementById('viewport');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, viewport.offsetWidth / viewport.offsetHeight, 0.1, 100);
        camera.position.set(0, 4, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(viewport.offsetWidth, viewport.offsetHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        viewport.appendChild(renderer.domElement);

        const orbit = new THREE.OrbitControls(camera, renderer.domElement);
        orbit.enableDamping = true; orbit.enablePan = false;
        orbit.minDistance = 5; orbit.maxDistance = 15;

        // --- OBJECTS ---
        const grid = new THREE.GridHelper(50, 50, 0x333333, 0x080808);
        grid.position.y = -2; scene.add(grid);

        const standGeo = new THREE.CylinderGeometry(0.1, 0.4, 4, 16);
        const standMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.5 });
        const stand = new THREE.Mesh(standGeo, standMat);
        scene.add(stand);

        const sphereGeo = new THREE.SphereGeometry(1, 64, 64);
        const sphereMat = new THREE.MeshPhysicalMaterial({
            color: 0x555555, metalness: 0.9, roughness: 0.1,
            emissive: 0x3498db, emissiveIntensity: 0
        });
        const conductor = new THREE.Mesh(sphereGeo, sphereMat);
        conductor.position.y = 2; scene.add(conductor);

        const haloGeo = new THREE.SphereGeometry(1.2, 32, 32);
        const haloMat = new THREE.MeshBasicMaterial({
            color: 0x3498db, transparent: true, opacity: 0.0, side: THREE.BackSide, blending: THREE.AdditiveBlending
        });
        const halo = new THREE.Mesh(haloGeo, haloMat);
        conductor.add(halo);

        const sparkGeo = new THREE.BufferGeometry();
        const sparkMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 3 });
        const spark = new THREE.Line(sparkGeo, sparkMat);
        spark.visible = false; scene.add(spark);

        const light = new THREE.PointLight(0xffffff, 1, 50);
        light.position.set(5, 10, 5); scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // --- SIMULATION LOGIC ---
        let sim = { charge: 0, radius: 1.0, stress: 0 };
        let isBroken = false;

        function updatePhysics() {
            conductor.scale.setScalar(sim.radius);
            halo.scale.setScalar(1.0 + (sim.stress * 0.1));

            sim.stress = sim.charge / (sim.radius * sim.radius * 6);

            // Visual Feedback
            const glow = Math.min(sim.stress, 1.2);
            conductor.material.emissiveIntensity = glow * 2;
            halo.material.opacity = glow * 0.5;

            // Status Light
            const status = document.getElementById('status-light');
            if (sim.stress > 0.9) {
                status.style.background = '#e74c3c';
                status.style.boxShadow = '0 0 15px #e74c3c';
            } else if (sim.stress > 0.1) {
                status.style.background = '#3498db';
                status.style.boxShadow = `0 0 ${glow * 10}px #3498db`;
            } else {
                status.style.background = '#333';
                status.style.boxShadow = 'none';
            }

            updateHum(sim.stress);

            if (sim.stress >= 1.0 && !isBroken) triggerBreakdown();
        }

        function triggerBreakdown() {
            isBroken = true;
            playSparkSound();
            const flash = document.getElementById('flash-overlay');
            flash.style.opacity = 0.8;
            setTimeout(() => flash.style.opacity = 0, 100);

            const points = [];
            points.push(new THREE.Vector3(0, 2 + sim.radius, 0));
            let curr = points[0].clone();
            for (let i = 0; i < 6; i++) {
                curr.y += 0.5 + Math.random();
                curr.x += (Math.random() - 0.5) * 3;
                curr.z += (Math.random() - 0.5) * 3;
                points.push(curr.clone());
            }
            sparkGeo.setFromPoints(points);
            spark.visible = true;

            setTimeout(() => {
                sim.charge = 0;
                spark.visible = false;
                isBroken = false;
                updatePhysics();
                if (currentStep === 1) document.getElementById('btn-next').disabled = false;
            }, 300);
        }

        function addCharge() { initAudio(); sim.charge += 1.0; updatePhysics(); }
        function setRadius(val) { sim.radius = parseFloat(val); updatePhysics(); }
        function resetSim() {
            sim.charge = 0; sim.stress = 0; isBroken = false; spark.visible = false;
            updatePhysics();
        }

        // --- LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            orbit.update();
            if (sim.stress > 0.5 && !isBroken) {
                conductor.position.x = (Math.random() - 0.5) * (sim.stress * 0.05);
                conductor.position.z = (Math.random() - 0.5) * (sim.stress * 0.05);
            } else {
                conductor.position.x = 0; conductor.position.z = 0;
            }
            if (spark.visible) spark.material.opacity = Math.random();
            renderer.render(scene, camera);
        }
        animate();

        // --- NARRATIVE CONTENT ---
        const steps = [
            {
                title: "Electrical Pressure",
                text: `Imagine this sphere is a container. We want to pack electrons onto its surface.
            <br><br>
            As we pump charge, we do work against repulsion. This builds up <strong>Electrical Potential (Voltage)</strong>. 
            <br><br>
            Watch the blue glowit represents the intensity of the electric field trying to escape the surface.`,
                controls: `
                <button class="pump-btn" onclick="addCharge()">Add Charge</button>
            `,
                setup: () => {
                    resetSim();
                    sim.radius = 1.0;
                    document.getElementById('btn-next').disabled = false;
                }
            },
            {
                title: "The Breaking Point",
                text: `The air acts as an insulator, but it has limits. If the Electric Field (Glow) becomes too intense, it rips air molecules apart.
            <br><br>
            <strong>Your Goal:</strong> Keep pumping charge until the system fails.`,
                controls: `
                <button class="pump-btn" onclick="addCharge()">Add Charge</button>
            `,
                setup: () => {
                    if (isBroken) resetSim();
                    sim.radius = 1.0;
                    document.getElementById('btn-next').disabled = true;
                }
            },
            {
                title: "Intuition: Cramped vs. Spacious",
                text: `We currently have some charge $Q$ on the sphere. The "glow" tells us the sphere is under high pressure (high Voltage).
            <br><br>
            <strong>What is Capacitance?</strong>
            It's a measure of "Storage Efficiency." It asks: <em>"How much voltage does it cost to store this charge?"</em>
            <br><br>
            <strong>Try this:</strong> Increase the sphere size below.
            <br>
            Note that even though the Charge ($Q$) stays exactly the same, the Glow/Voltage drops significantly. A larger sphere is less "cramped," so it has a higher capacity to accept charge without fighting back.`,
                controls: `
                <label>Sphere Size (Geometry)</label>
                <input type="range" min="0.8" max="2.0" step="0.1" value="1.0" oninput="setRadius(this.value)">
                <button class="pump-btn" onclick="addCharge()">Add More Charge</button>
            `,
                setup: () => {
                    sim.charge = 4.0;
                    sim.radius = 1.0;
                    isBroken = false;
                    updatePhysics();
                    document.getElementById('btn-next').disabled = false;
                }
            },
            {
                title: "Defining Capacitance",
                text: `We just saw that for a fixed Charge ($Q$), making the Radius ($R$) bigger reduced the Potential ($V$).
            <br><br>
            This gives us the definition of **Capacitance ($C$)**: The ratio of how much charge we hold vs. how much pressure it creates.
            $$ C = \\frac{Q}{V} $$
            <br>
            Let's derive the formula for a sphere:
            1. Potential on a sphere surface: $ V = \\frac{1}{4\\pi\\epsilon_0} \\frac{Q}{R} $
            2. Substitute that into the definition: $ C = \\frac{Q}{ (\\frac{1}{4\\pi\\epsilon_0} \\frac{Q}{R}) } $
            3. The $Q$ cancels out, leaving:
            $$ C = 4\\pi\\epsilon_0 R $$
            <br>
            <strong>Conclusion:</strong> Capacity doesn't depend on Charge. It depends purely on the geometry ($R$) of the object.`,
                controls: `<div style="text-align:center; color:#666; font-style:italic; padding:20px;">Lesson Complete</div>`,
                setup: () => {
                    sim.radius = 2.0;
                    sim.charge = 5.0;
                    updatePhysics();
                }
            }
        ];

        let currentStep = 0;

        function loadStep(idx) {
            currentStep = idx;
            const s = steps[idx];

            document.getElementById('story-container').innerHTML = `
            <div class="chapter-title">${s.title}</div>
            <div>${s.text}</div>
        `;
            document.getElementById('dynamic-controls').innerHTML = s.controls;

            renderMathInElement(document.getElementById('story-container'), {
                delimiters: [{ left: "$$", right: "$$", display: true }, { left: "$", right: "$", display: false }]
            });

            if (s.setup) s.setup();
        }

        function nextStep() { if (currentStep < steps.length - 1) loadStep(currentStep + 1); }
        function prevStep() { if (currentStep > 0) loadStep(currentStep - 1); }

        loadStep(0);

        window.addEventListener('resize', () => {
            camera.aspect = viewport.offsetWidth / viewport.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewport.offsetWidth, viewport.offsetHeight);
        });

    </script>
</body>

</html>
<!-- END: 3_Capacitance.html -->

<!-- START: 4_capacitance_revised.html -->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Maxwell's Notebook: Two Conductors</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- KaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body);"></script>

    <style>
        :root {
            --bg: #111;
            --panel: #1a1a1a;
            --text: #ddd;
            --accent: #ff9f43;
            --danger: #e74c3c;
            --charge-pos: #e74c3c;
            --charge-neg: #3498db;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* --- SIDEBAR --- */
        aside {
            width: 450px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        header {
            padding: 25px;
            border-bottom: 1px solid var(--border);
        }

        h1 {
            margin: 0;
            font-size: 14px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            font-size: 15px;
            line-height: 1.7;
            color: #ccc;
        }

        .chapter-title {
            font-size: 22px;
            color: #fff;
            margin-bottom: 20px;
            font-weight: 300;
        }

        strong {
            color: #fff;
            font-weight: 600;
        }

        /* KaTeX Corrections */
        .katex-display {
            margin: 1em 0;
            overflow-x: auto;
            overflow-y: hidden;
        }

        /* --- CONTROLS --- */
        #controls {
            background: #000;
            padding: 25px;
            border-top: 1px solid var(--border);
        }

        button {
            background: #252525;
            color: #fff;
            border: 1px solid #444;
            padding: 14px;
            width: 100%;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
            text-transform: uppercase;
            font-size: 12px;
            margin-top: 15px;
            letter-spacing: 1px;
            border-radius: 4px;
        }

        button:hover {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
        }

        button:disabled {
            opacity: 0.3;
            cursor: default;
        }

        button.pump-btn {
            border-color: var(--charge-pos);
            color: var(--charge-pos);
        }

        button.pump-btn:hover {
            background: var(--charge-pos);
            color: #fff;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
            margin: 10px 0;
            cursor: pointer;
        }

        label {
            font-size: 11px;
            text-transform: uppercase;
            color: #888;
            display: block;
            margin-top: 5px;
            letter-spacing: 1px;
        }

        #nav {
            padding: 20px;
            display: flex;
            gap: 15px;
            background: #080808;
            border-top: 1px solid var(--border);
        }

        .nav-btn {
            flex: 1;
            margin: 0;
        }

        .next-btn {
            background: var(--accent);
            color: #111;
            border: none;
        }

        .next-btn:hover {
            background: #ffb875;
        }

        /* --- VIEWPORT --- */
        main {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: radial-gradient(circle at center, #222 0%, #000 90%);
        }

        #flash-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #fff;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.05s;
        }

        #legend {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border: 1px solid #333;
            border-radius: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            pointer-events: none;
        }

        .glow-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e74c3c;
            box-shadow: 0 0 10px #e74c3c;
        }

        #status-light {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #333;
            box-shadow: 0 0 5px #000;
            transition: background 0.2s, box-shadow 0.2s;
        }

        .value-display {
            font-family: monospace;
            color: var(--accent);
            font-size: 14px;
            float: right;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Lesson 4: The Two Conductors</div>
        </header>

        <div id="story-container"></div>

        <div id="controls">
            <div id="dynamic-controls"></div>
        </div>
        <div id="nav">
            <button class="nav-btn" onclick="prevStep()">Back</button>
            <button class="nav-btn next-btn" id="btn-next" onclick="nextStep()">Next</button>
        </div>
    </aside>

    <main id="viewport">
        <div id="status-light"></div>
        <div id="legend">
            <div class="glow-dot"></div>
            <span>Red Glow = Potential Difference ($\Delta V$)</span>
        </div>
        <div id="flash-overlay"></div>
    </main>

    <script>
        // --- AUDIO SYSTEM ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function initAudio() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playSparkSound() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(400, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(1.0, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.2);
        }

        // --- THREE.JS SETUP ---
        const viewport = document.getElementById('viewport');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, viewport.offsetWidth / viewport.offsetHeight, 0.1, 100);
        camera.position.set(0, 5, 12);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(viewport.offsetWidth, viewport.offsetHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        viewport.appendChild(renderer.domElement);

        const orbit = new THREE.OrbitControls(camera, renderer.domElement);
        orbit.enableDamping = true; orbit.enablePan = false;
        orbit.minDistance = 5; orbit.maxDistance = 20;

        // --- OBJECTS ---
        const grid = new THREE.GridHelper(50, 50, 0x333333, 0x080808);
        grid.position.y = -2; scene.add(grid);

        // Conductor A (+Q)
        const sphereGeo = new THREE.SphereGeometry(1, 32, 32);
        const matA = new THREE.MeshPhysicalMaterial({
            color: 0x555555, metalness: 0.8, roughness: 0.2,
            emissive: 0xe74c3c, emissiveIntensity: 0
        });
        const conductorA = new THREE.Mesh(sphereGeo, matA);
        conductorA.position.set(-2, 0, 0);
        scene.add(conductorA);

        // Glow Halo A
        const haloGeo = new THREE.SphereGeometry(1.2, 32, 32);
        const haloMatA = new THREE.MeshBasicMaterial({
            color: 0xe74c3c, transparent: true, opacity: 0.0, side: THREE.BackSide, blending: THREE.AdditiveBlending
        });
        const haloA = new THREE.Mesh(haloGeo, haloMatA);
        conductorA.add(haloA);

        // Conductor B (-Q)
        const matB = new THREE.MeshPhysicalMaterial({
            color: 0x555555, metalness: 0.8, roughness: 0.2,
            emissive: 0x3498db, emissiveIntensity: 0
        });
        const conductorB = new THREE.Mesh(sphereGeo, matB);
        conductorB.position.set(2, 0, 0);
        scene.add(conductorB);

        // Glow Halo B
        const haloMatB = new THREE.MeshBasicMaterial({
            color: 0x3498db, transparent: true, opacity: 0.0, side: THREE.BackSide, blending: THREE.AdditiveBlending
        });
        const haloB = new THREE.Mesh(haloGeo, haloMatB);
        conductorB.add(haloB);

        // Connector Line (Field approximation)
        const lineGeo = new THREE.BufferGeometry();
        const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0 });
        const connector = new THREE.Line(lineGeo, lineMat);
        scene.add(connector);

        // Spark
        const sparkGeo = new THREE.BufferGeometry();
        const sparkMat = new THREE.LineBasicMaterial({ color: 0xffffaa, linewidth: 4 });
        const spark = new THREE.Line(sparkGeo, sparkMat);
        spark.visible = false; scene.add(spark);

        // --- LABELS ---
        function createLabelSprite() {
            // Set transparent to true and make it initially invisible to avoid white box
            const mat = new THREE.SpriteMaterial({ color: 0xffffff, transparent: true, opacity: 1 });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(3, 1.5, 1);
            sprite.position.y = 1.8;
            sprite.visible = false; // Hide until texture is ready
            return sprite;
        }

        function updateLabelTexture(sprite, text, colorStr) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            // Explicitly clear canvas to ensure transparency
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Text Style
            ctx.font = "Bold 50px Arial";
            ctx.fillStyle = colorStr;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            // Shadow for readability
            ctx.shadowColor = "black";
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            ctx.fillText(text, 128, 64);

            const texture = new THREE.CanvasTexture(canvas);
            sprite.material.map = texture;
            sprite.material.needsUpdate = true;
            sprite.visible = true; // Show now that texture is loaded
        }

        const labelA = createLabelSprite();
        conductorA.add(labelA);

        const labelB = createLabelSprite();
        conductorB.add(labelB);

        const light = new THREE.PointLight(0xffffff, 1, 50);
        light.position.set(0, 10, 5); scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // --- SIMULATION LOGIC ---
        let sim = {
            charge: 0,      // Q
            separation: 6,  // Distance between centers
            potentialDiff: 0, // V_a - V_b
            fieldStress: 0  // E field between them
        };
        let isBroken = false;
        const RADIUS = 1.0;

        function updatePhysics() {
            // Position spheres
            conductorA.position.x = -sim.separation / 2;
            conductorB.position.x = sim.separation / 2;

            // Update Labels
            updateLabelTexture(labelA, `+${sim.charge} Q`, "#e74c3c");
            updateLabelTexture(labelB, `-${sim.charge} Q`, "#3498db");

            // Calculate Physics
            const k = 1.0;
            const d = sim.separation;

            const term = (1 / RADIUS) - (1 / Math.max(d, 2.1));
            sim.potentialDiff = 2 * k * sim.charge * term;

            // Field Stress (Trigger for breakdown)
            const gap = Math.max(0.1, d - 2 * RADIUS);
            sim.fieldStress = sim.potentialDiff / gap;

            // Visuals
            const glow = Math.min(sim.potentialDiff * 0.3, 1.5);
            conductorA.material.emissiveIntensity = glow;
            haloA.material.opacity = glow * 0.4;
            conductorB.material.emissiveIntensity = glow;
            haloB.material.opacity = glow * 0.4;

            // Connector line
            const points = [conductorA.position.clone(), conductorB.position.clone()];
            lineGeo.setFromPoints(points);
            lineMat.opacity = Math.min(sim.charge * 0.1, 0.5);

            // Status Light
            const status = document.getElementById('status-light');
            const danger = sim.fieldStress;

            if (danger > 1.8) {
                status.style.background = '#e74c3c';
                status.style.boxShadow = '0 0 15px #e74c3c';
            } else {
                status.style.background = '#333';
                status.style.boxShadow = 'none';
            }

            // Breakdown Threshold
            if (sim.fieldStress > 2.0 && !isBroken) triggerBreakdown();

            const readout = document.getElementById('volts-readout');
            if (readout) readout.innerText = sim.potentialDiff.toFixed(2) + " V";
        }

        function triggerBreakdown() {
            isBroken = true;
            playSparkSound();
            const flash = document.getElementById('flash-overlay');
            flash.style.opacity = 0.8;
            setTimeout(() => flash.style.opacity = 0, 100);

            // Jagged line logic
            const points = [];
            const start = conductorA.position.clone();
            const end = conductorB.position.clone();
            const vector = end.clone().sub(start);
            const steps = 8;

            points.push(start);
            for (let i = 1; i < steps; i++) {
                const t = i / steps;
                const pt = start.clone().add(vector.clone().multiplyScalar(t));
                pt.y += (Math.random() - 0.5) * 1.5;
                pt.z += (Math.random() - 0.5) * 1.5;
                points.push(pt);
            }
            points.push(end);

            sparkGeo.setFromPoints(points);
            spark.visible = true;

            setTimeout(() => {
                sim.charge = 0;
                spark.visible = false;
                isBroken = false;
                updatePhysics();
                if (currentStep === 2) document.getElementById('btn-next').disabled = false;
            }, 300);
        }

        function addCharge() {
            initAudio();
            sim.charge += 1.0;
            updatePhysics();
        }

        function setSeparation(val) {
            sim.separation = parseFloat(val);
            updatePhysics();
        }

        // --- LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            orbit.update();
            if (spark.visible) spark.material.opacity = Math.random();
            renderer.render(scene, camera);
        }
        animate();

        // --- NARRATIVE CONTENT ---
        const steps = [
            {
                title: "Two Conductors",
                text: `In practical circuits, we don't just push charge onto a single isolated object. We move charge from one conductor to another.
            <br><br>
            Here we have two spheres. We will move electrons from the Red sphere to the Blue one. 
            <br><br>
            One becomes <strong>Positive ($+Q$)</strong>, the other <strong>Negative ($-Q$)</strong>.`,
                controls: `
                <button class="pump-btn" onclick="addCharge()">Separate Charge (+Q / -Q)</button>
            `,
                setup: () => {
                    sim.charge = 0; sim.separation = 6; isBroken = false;
                    updatePhysics();
                    document.getElementById('btn-next').disabled = false;
                }
            },
            {
                title: "Defining Capacitance",
                text: `As we separate charge, a <strong>Potential Difference ($\Delta V$)</strong> builds up between the spheres. This is the "Voltage" (represented by the red/blue glow intensity).
            <br><br>
            The new definition of Capacitance is:
            $$ C = \\frac{Q}{\\Delta V} $$
            <br>
            Ideally, we want high Capacity ($C$). This means we want to store a lot of Charge ($Q$) while keeping the Voltage ($\Delta V$) low, so it doesn't fight back as hard.`,
                controls: `
                <div style="margin-bottom:10px;">
                    Current Potential ($\Delta V$): <span id="volts-readout" class="value-display">0.00 V</span>
                </div>
                <button class="pump-btn" onclick="addCharge()">Increase Charge ($Q$)</button>
            `,
                setup: () => {
                    if (sim.charge < 1) sim.charge = 2;
                    updatePhysics();
                }
            },
            {
                title: "The Effect of Proximity",
                text: `Here is the key insight. The potential of the positive sphere is lowered by the presence of the nearby negative sphere (opposites attract, reducing the "pressure" to escape).
            <br><br>
            <strong>Experiment:</strong>
            1. Note the Glow/Voltage intensity.
            2. <strong>Drag the slider</strong> to bring the spheres closer.
            <br><br>
            Notice that as distance decreases, the Voltage ($\Delta V$) drops significantly, even though Charge ($Q$) is constant!
            <br><br>
            $$ \\text{Lower } \\Delta V \\implies \\text{Higher } C $$`,
                controls: `
                <label>Distance between Spheres</label>
                <input type="range" min="2.5" max="10.0" step="0.1" value="6.0" oninput="setSeparation(this.value)">
                <button class="pump-btn" onclick="addCharge()">Add More Charge</button>
            `,
                setup: () => {
                    sim.charge = 4.0;
                    sim.separation = 6.0;
                    updatePhysics();
                }
            },
            {
                title: "The Trade-off",
                text: `If bringing them closer increases Capacitance, why not let them touch?
            <br><br>
            <strong>Dielectric Breakdown:</strong>
            While the Voltage ($\Delta V$) drops as they get closer, the electric field <em>between</em> them ($E \\approx \\Delta V / d$) actually increases.
            <br><br>
            If they get too close for the amount of charge held, the air insulation fails. 
            <br><br>
            This explains why we want large plates close together. Small distance means huge Capacity, but lower breakdown voltage.`,
                controls: `
                <label>Distance (Risk Breakdown)</label>
                <input type="range" min="2.2" max="6.0" step="0.1" value="3.0" oninput="setSeparation(this.value)">
                <button class="pump-btn" onclick="addCharge()">Test Limits</button>
            `,
                setup: () => {
                    sim.charge = 5.0;
                    sim.separation = 4.0;
                    updatePhysics();
                }
            }
        ];

        let currentStep = 0;

        function loadStep(idx) {
            currentStep = idx;
            const s = steps[idx];

            document.getElementById('story-container').innerHTML = `
            <div class="chapter-title">${s.title}</div>
            <div>${s.text}</div>
        `;
            document.getElementById('dynamic-controls').innerHTML = s.controls;

            renderMathInElement(document.getElementById('story-container'), {
                delimiters: [{ left: "$$", right: "$$", display: true }, { left: "$", right: "$", display: false }]
            });

            if (s.setup) s.setup();
        }

        function nextStep() { if (currentStep < steps.length - 1) loadStep(currentStep + 1); }
        function prevStep() { if (currentStep > 0) loadStep(currentStep - 1); }

        loadStep(0);

        window.addEventListener('resize', () => {
            camera.aspect = viewport.offsetWidth / viewport.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewport.offsetWidth, viewport.offsetHeight);
        });

    </script>
</body>

</html>
<!-- END: 4_capacitance_revised.html -->

<!-- START: 5_parrallel_plate.html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Maxwell's Notebook: The Capacitor (2D)</title>
    <!-- Load KaTeX for Math Rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body);"></script>

    <style>
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Maxwell Orange */
            --accent-hover: #e58e3c;
            --energy: #00cec9;
            /* Cyan for Energy */
            --pos-charge: #ff5e57;
            --neg-charge: #48dbfb;
            --field: #ffdd59;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* --- SIDEBAR --- */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 10;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
        }

        header {
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid var(--border);
        }

        h1 {
            margin: 0;
            font-size: 18px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        #story-container {
            flex: 1;
            padding: 25px;
            overflow-y: auto;
        }

        .chapter-title {
            font-size: 22px;
            color: #fff;
            margin-bottom: 15px;
            border-left: 3px solid var(--accent);
            padding-left: 10px;
        }

        .text-content {
            line-height: 1.6;
            font-size: 14px;
            color: #ccc;
            text-align: justify;
            margin-bottom: 15px;
        }

        .math-block {
            background: #222;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #333;
            text-align: center;
            margin: 15px 0;
            color: var(--energy);
        }

        /* --- CONTROLS --- */
        #controls {
            background: #111;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .slider-container {
            margin-bottom: 15px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 5px;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--accent);
        }

        button {
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #444;
            padding: 12px;
            width: 100%;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
            text-transform: uppercase;
            font-size: 12px;
            margin-bottom: 10px;
        }

        button:hover {
            background: var(--accent);
            color: #111;
            border-color: var(--accent);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #nav {
            padding: 15px;
            display: flex;
            gap: 10px;
            background: #000;
            border-top: 1px solid var(--border);
        }

        .nav-btn {
            flex: 1;
        }

        .next-btn {
            background: var(--accent);
            color: #111;
            border: none;
        }

        .next-btn:hover {
            background: #ffb875;
        }

        /* --- VIEWPORT --- */
        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #1a1a1a 0%, #080808 100%);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            border-radius: 4px;
        }

        /* HUD OVERLAY */
        #hud {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            width: 200px;
            font-family: 'Segoe UI', sans-serif;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 12px;
            color: #aaa;
        }

        .hud-val {
            font-weight: bold;
            color: #fff;
            font-family: monospace;
        }

        .hud-hl {
            color: var(--accent);
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Chapter 12: Parallel Plate Capacitor (2D)</div>
        </header>
        <div id="story-container"></div>
        <div id="controls">
            <div id="dynamic-controls"></div>
        </div>
        <div id="nav">
            <button class="nav-btn" onclick="prevStep()">Back</button>
            <button class="nav-btn next-btn" id="btn-next" onclick="nextStep()">Next</button>
        </div>
    </aside>

    <main id="viewport">
        <canvas id="simCanvas"></canvas>
        <div id="hud">
            <div class="hud-row"><span>Voltage (V):</span> <span class="hud-val hud-hl" id="disp-v">0 V</span></div>
            <div class="hud-row"><span>Distance (d):</span> <span class="hud-val" id="disp-d">2.0 mm</span></div>
            <div class="hud-row"><span>Charge (Q):</span> <span class="hud-val" id="disp-q">0.0 C</span></div>
            <div class="hud-row"><span>E-Field (E):</span> <span class="hud-val" id="disp-e">0.0 N/C</span></div>
            <div style="border-top:1px solid #444; margin-top:5px; padding-top:5px;" class="hud-row">
                <span style="color:var(--energy)">Energy (U):</span> <span class="hud-val" style="color:var(--energy)"
                    id="disp-u">0.0 J</span>
            </div>
        </div>
    </main>

    <script>
        // --- SIMULATION CONFIG ---
        const config = {
            voltage: 0,       // 0 to 10
            distance: 100,    // Pixels (representing mm)
            plateWidth: 400,
            plateHeight: 20,
            showField: false,
            showCircuit: false,
            showEnergy: false
        };

        // --- CANVAS SETUP ---
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        // Physics State
        let physics = {
            C: 0,
            Q: 0,
            E: 0,
            U: 0
        };

        // Resize Canvas
        function resize() {
            const parent = document.getElementById('viewport');
            canvas.width = parent.offsetWidth - 40;
            canvas.height = parent.offsetHeight - 40;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- DRAWING FUNCTIONS ---

        function drawPlate(x, y, w, h, isTop) {
            // Metallic Gradient
            const grad = ctx.createLinearGradient(x, y, x, y + h);
            grad.addColorStop(0, '#555');
            grad.addColorStop(0.5, '#777');
            grad.addColorStop(1, '#555');

            ctx.fillStyle = grad;
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, 4);
            ctx.fill();
            ctx.stroke();

            // Terminal connection point
            ctx.fillStyle = '#333';
            ctx.beginPath();
            if (isTop) ctx.arc(x + w / 2, y, 4, 0, Math.PI * 2);
            else ctx.arc(x + w / 2, y + h, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawCharges(centerX, centerY, separation) {
            if (Math.abs(physics.Q) < 0.1) return;

            const count = Math.min(Math.abs(physics.Q) * 5, 40); // Visual limit
            const startX = centerX - config.plateWidth / 2 + 20;
            const width = config.plateWidth - 40;
            const step = width / (count > 0 ? count : 1);

            // Top Plate Position (Inner surface)
            const topY = centerY - separation / 2 + config.plateHeight + 8;
            // Bottom Plate Position (Inner surface)
            const botY = centerY + separation / 2 - config.plateHeight - 8;

            for (let i = 0; i <= count; i++) {
                const x = startX + i * step;

                // Top Charges (Opposite sign if V < 0, but lets assume standard polarity V>0 means Top+)
                const topColor = config.voltage >= 0 ? '#ff5e57' : '#48dbfb'; // Red (+) or Blue (-)
                const botColor = config.voltage >= 0 ? '#48dbfb' : '#ff5e57';
                const topSign = config.voltage >= 0 ? "+" : "-";
                const botSign = config.voltage >= 0 ? "-" : "+";

                // Draw Top
                ctx.fillStyle = topColor;
                ctx.shadowBlur = 5;
                ctx.shadowColor = topColor;
                ctx.beginPath(); ctx.arc(x, topY, 4, 0, Math.PI * 2); ctx.fill();
                ctx.shadowBlur = 0;
                ctx.font = "10px monospace"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.fillStyle = "#fff"; ctx.fillText(topSign, x, topY + 0.5);

                // Draw Bottom
                ctx.fillStyle = botColor;
                ctx.shadowBlur = 5;
                ctx.shadowColor = botColor;
                ctx.beginPath(); ctx.arc(x, botY, 4, 0, Math.PI * 2); ctx.fill();
                ctx.shadowBlur = 0;
                ctx.fillStyle = "#fff"; ctx.fillText(botSign, x, botY + 0.5);
            }
        }

        function drawField(centerX, centerY, separation) {
            if (!config.showField || Math.abs(physics.E) < 0.1) return;

            const startY = centerY - separation / 2 + config.plateHeight;
            const endY = centerY + separation / 2 - config.plateHeight;

            // Opacity based on Field Strength
            const alpha = Math.min(Math.abs(physics.E) / 5, 1);
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = '#ffdd59';
            ctx.lineWidth = 2;

            const count = 12; // Number of field lines
            const startX = centerX - config.plateWidth / 2 + 30;
            const spacing = (config.plateWidth - 60) / (count - 1);

            for (let i = 0; i < count; i++) {
                const x = startX + i * spacing;

                ctx.beginPath();
                ctx.moveTo(x, startY + 5);
                ctx.lineTo(x, endY - 5);
                ctx.stroke();

                // Arrowhead
                const arrowSize = 6;
                const dir = config.voltage >= 0 ? 1 : -1;
                const arrowY = config.voltage >= 0 ? endY - 8 : startY + 8;

                ctx.beginPath();
                ctx.moveTo(x, arrowY);
                ctx.lineTo(x - 4, arrowY - (dir * 6));
                ctx.lineTo(x + 4, arrowY - (dir * 6));
                ctx.closePath();
                ctx.fillStyle = '#ffdd59';
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
        }

        function drawEnergyGlow(centerX, centerY, separation) {
            if (!config.showEnergy || Math.abs(physics.Q) < 0.1) return;

            const startY = centerY - separation / 2 + config.plateHeight;
            const height = separation - (2 * config.plateHeight);

            // Density is proportional to E^2. 
            // We visualize this with opacity.
            let opacity = Math.min((physics.E * physics.E) / 50, 0.7);

            const grad = ctx.createLinearGradient(0, startY, 0, startY + height);
            grad.addColorStop(0, `rgba(0, 206, 201, 0)`);
            grad.addColorStop(0.2, `rgba(0, 206, 201, ${opacity})`); // Cyan
            grad.addColorStop(0.8, `rgba(0, 206, 201, ${opacity})`);
            grad.addColorStop(1, `rgba(0, 206, 201, 0)`);

            ctx.fillStyle = grad;
            // Limit glow to width of plates
            ctx.fillRect(centerX - config.plateWidth / 2, startY, config.plateWidth, height);
        }

        function drawCircuit(centerX, centerY, separation) {
            if (!config.showCircuit) return;

            const plateTopY = centerY - separation / 2;
            const plateBotY = centerY + separation / 2 + config.plateHeight;
            const batteryX = centerX - 300; // Place battery to the left

            ctx.strokeStyle = '#555';
            ctx.lineWidth = 3;
            ctx.beginPath();

            // Top Wire
            ctx.moveTo(centerX, plateTopY);
            ctx.lineTo(centerX, plateTopY - 50);
            ctx.lineTo(batteryX, plateTopY - 50);
            ctx.lineTo(batteryX, centerY - 20);

            // Bottom Wire
            ctx.moveTo(centerX, plateBotY);
            ctx.lineTo(centerX, plateBotY + 50);
            ctx.lineTo(batteryX, plateBotY + 50);
            ctx.lineTo(batteryX, centerY + 20);
            ctx.stroke();

            // Battery Symbol
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#fff';

            // Top Plate of Battery (Long line if V>0, actually simple symbol: Long Top, Short Bottom)
            ctx.beginPath();
            ctx.moveTo(batteryX - 20, centerY - 10);
            ctx.lineTo(batteryX + 20, centerY - 10);
            ctx.stroke();

            ctx.lineWidth = 6; // Thick short line
            ctx.beginPath();
            ctx.moveTo(batteryX - 10, centerY + 10);
            ctx.lineTo(batteryX + 10, centerY + 10);
            ctx.stroke();

            // Voltage Text
            ctx.fillStyle = '#aaa';
            ctx.font = "14px monospace";
            ctx.textAlign = "right";
            ctx.fillText("V_source", batteryX - 30, centerY + 5);
        }

        // --- MAIN LOOP ---

        function loop() {
            // Clear
            ctx.fillStyle = "#0a0a0a"; // slightly lighter than bg for contrast
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            // Calculate Physics
            // Simplify constants: epsilon_0 = 1, A = 100
            // C = A / d
            physics.C = (1000 / config.distance);
            physics.Q = physics.C * (config.voltage / 10); // Scale down V
            physics.E = (config.voltage * 200) / config.distance; // E = V/d
            physics.U = 0.5 * physics.C * Math.pow(config.voltage / 10, 2) * 100; // Scale up for display

            // Draw Sequence
            drawCircuit(cx, cy, config.distance);
            drawEnergyGlow(cx, cy, config.distance);

            // Draw Plates
            const halfD = config.distance / 2;
            drawPlate(cx - config.plateWidth / 2, cy - halfD, config.plateWidth, config.plateHeight, true);
            drawPlate(cx - config.plateWidth / 2, cy + halfD - config.plateHeight, config.plateWidth, config.plateHeight, false);

            drawCharges(cx, cy, config.distance);
            drawField(cx, cy, config.distance);

            // Update HUD
            if (config.showCircuit) {
                document.getElementById('disp-v').innerText = config.voltage.toFixed(1) + " V";
                document.getElementById('disp-d').innerText = (config.distance / 10).toFixed(1) + " mm";
                document.getElementById('disp-q').innerText = physics.Q.toFixed(1) + " nC";
                document.getElementById('disp-e').innerText = physics.E.toFixed(1) + " kV/m";
                document.getElementById('disp-u').innerText = physics.U.toFixed(2) + " uJ";
            }

            requestAnimationFrame(loop);
        }
        loop();


        // --- STORY ENGINE ---
        const steps = [
            {
                title: "The Conductors",
                text: "This is a cross-section of a capacitor. It consists of two parallel conductive plates separated by a distance $d$.<br><br>Initially, the plates are neutral. They contain equal amounts of positive and negative charge, so the net charge is zero. There is no interaction between them.",
                controls: ``,
                setup: () => {
                    config.voltage = 0;
                    config.distance = 120;
                    config.showCircuit = false;
                    config.showField = false;
                    config.showEnergy = false;
                    document.getElementById('hud').style.opacity = 0;
                }
            },
            {
                title: "Connecting the Source",
                text: "We connect a battery (voltage source) to the plates. The Battery Symbol: Look at the circuit diagram to the left. The long, thin line represents the Positive Terminal (+), and the short, thick line represents the Negative Terminal (-). <br><br>The battery acts like a charge pump.<br><br>It pulls electrons off the top plate (leaving it positive) and pushes them onto the bottom plate (making it negative).<br><br><strong>Try increasing the Voltage.</strong> Note that charges accumulate on the <em>inner surfaces</em> due to mutual attraction.",
                controls: `
                <div class="slider-container">
                    <div class="slider-label"><span>Voltage</span><span id="lbl-vol">0 V</span></div>
                    <input type="range" min="0" max="10" step="0.1" value="0" oninput="setVoltage(this.value)">
                </div>
            `,
                setup: () => {
                    config.showCircuit = true;
                    config.showField = false;
                    config.showEnergy = false;
                    document.getElementById('hud').style.opacity = 1;
                }
            },
            {
                title: "The Electric Field",
                text: "The separation of charge creates a Uniform Electric Field ($E$) between the plates, pointing from positive to negative.<br><br>The strength of this field is determined by the voltage and the distance: <div class='math-block'>$$ E = \\frac{V}{d} $$</div><br>Notice that inside the metal plates themselves, the field is zero.",
                controls: `
                <div class="slider-container">
                    <div class="slider-label"><span>Voltage</span><span id="lbl-vol">5.0 V</span></div>
                    <input type="range" min="0" max="10" step="0.1" value="5.0" oninput="setVoltage(this.value)">
                </div>
                <button onclick="toggleField()">Toggle Field Lines</button>
            `,
                setup: () => {
                    config.voltage = 5;
                    config.showCircuit = true;
                    config.showField = true;
                }
            },
            {
                title: "Variable Separation",
                text: "Capacitance ($C$) measures the ability to store charge for a given voltage. It depends purely on geometry.<br><div class='math-block'>$$ C = \\frac{\\epsilon_0 A}{d} $$</div><br><strong>Experiment:</strong> Decrease the distance $d$ while keeping Voltage constant.<br>1. Capacitance increases.<br>2. More charge $Q$ is pulled from the battery.<br>3. The Electric Field $E=V/d$ gets stronger.",
                controls: `
                <div class="slider-container">
                    <div class="slider-label"><span>Distance (d)</span><span id="lbl-dist">12.0 mm</span></div>
                    <input type="range" min="50" max="250" step="1" value="120" oninput="setDistance(this.value)">
                </div>
                <div class="slider-container">
                    <div class="slider-label"><span>Voltage (V)</span><span id="lbl-vol">5.0 V</span></div>
                    <input type="range" min="0" max="10" step="0.1" value="5.0" oninput="setVoltage(this.value)">
                </div>
            `,
                setup: () => {
                    config.showField = true;
                    config.voltage = 5;
                    config.distance = 120;
                }
            },
            {
                title: "Energy Density",
                text: "Where is the energy stored? It's not in the charges, but in the <strong>Space</strong> between them.<br><br>The energy density $u$ (Cyan Glow) is proportional to the square of the field strength: $$ u \\propto E^2 $$<br>Even in a vacuum, this field carries real energy. This is the principle behind how capacitors store power for camera flashes and defibrillators.",
                controls: `
                 <div class="slider-container">
                    <div class="slider-label"><span>Voltage (V)</span><span id="lbl-vol">5.0 V</span></div>
                    <input type="range" min="0" max="10" step="0.1" value="5.0" oninput="setVoltage(this.value)">
                </div>
                <div class="slider-container">
                    <div class="slider-label"><span>Distance (d)</span><span id="lbl-dist">12.0 mm</span></div>
                    <input type="range" min="50" max="250" step="1" value="120" oninput="setDistance(this.value)">
                </div>
            `,
                setup: () => {
                    config.showEnergy = true;
                    config.showField = true;
                    config.voltage = 6;
                    config.distance = 120;
                }
            }
        ];

        let currentStep = 0;

        function loadStep(idx) {
            currentStep = idx;
            const s = steps[idx];

            document.getElementById('story-container').innerHTML = `
            <div class="chapter-title">${s.title}</div>
            <div class="text-content">${s.text}</div>
        `;
            document.getElementById('dynamic-controls').innerHTML = s.controls;

            renderMathInElement(document.getElementById('story-container'), {
                delimiters: [{ left: "$$", right: "$$", display: true }]
            });

            s.setup();

            // Update labels
            if (document.getElementById('lbl-vol')) document.getElementById('lbl-vol').innerText = config.voltage + " V";
            if (document.getElementById('lbl-dist')) document.getElementById('lbl-dist').innerText = (config.distance / 10).toFixed(1) + " mm";

            document.getElementById('btn-next').disabled = (idx >= steps.length - 1);
        }

        // --- INTERACTION ---
        window.setVoltage = (v) => {
            config.voltage = parseFloat(v);
            const lbl = document.getElementById('lbl-vol');
            if (lbl) lbl.innerText = config.voltage.toFixed(1) + " V";
        };

        window.setDistance = (d) => {
            config.distance = parseFloat(d);
            const lbl = document.getElementById('lbl-dist');
            if (lbl) lbl.innerText = (config.distance / 10).toFixed(1) + " mm";
        };

        window.toggleField = () => {
            config.showField = !config.showField;
        };

        function nextStep() { if (currentStep < steps.length - 1) loadStep(currentStep + 1); }
        function prevStep() { if (currentStep > 0) loadStep(currentStep - 1); }

        loadStep(0);

    </script>
</body>

</html>
<!-- END: 5_parrallel_plate.html -->

<!-- START: 6_energy_in_cap.html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Maxwell's Notebook: Capacitance & Energy</title>
    <!-- Load KaTeX for Math Rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body);"></script>

    <style>
        :root {
            --bg: #0f0f0f;
            --panel: #181818;
            --text-main: #e0e0e0;
            --text-muted: #888;
            --accent: #ff9f43;
            /* Maxwell Orange / Battery */
            --energy: #00d2d3;
            /* Cyan for Electric Field */
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text-main);
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }

        /* --- SIDEBAR --- */
        aside {
            width: 380px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 5px 0 20px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
        }

        h1 {
            margin: 0;
            font-size: 18px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: var(--text-muted);
        }

        #content-area {
            flex: 1;
            padding: 25px;
            overflow-y: auto;
        }

        .chapter-marker {
            font-size: 11px;
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        h2 {
            margin: 0 0 15px 0;
            font-size: 22px;
            color: #fff;
        }

        p {
            line-height: 1.6;
            font-size: 14px;
            color: #ccc;
            margin-bottom: 15px;
        }

        .math-highlight {
            background: rgba(255, 255, 255, 0.03);
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid var(--energy);
            margin: 15px 0;
            text-align: center;
            font-size: 1.1em;
        }

        /* --- CONTROLS --- */
        #controls-wrapper {
            background: #111;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-header {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .control-val {
            color: var(--accent);
            font-family: monospace;
            font-weight: bold;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--accent);
        }

        .btn-row {
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 11px;
            transition: 0.2s;
        }

        .btn-next {
            background: var(--accent);
            color: #111;
        }

        .btn-back {
            background: transparent;
            border: 1px solid #444;
            color: #888;
        }

        .btn-action {
            background: #e74c3c;
            color: white;
            width: 100%;
            margin-top: 10px;
        }

        .btn-action:hover {
            background: #ff4757;
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.4);
        }

        /* --- CANVAS --- */
        main {
            flex: 1;
            position: relative;
            background: #050505;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            background: #000;
            border-radius: 8px;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Lesson 13: The Charging Circuit</div>
        </header>

        <div id="content-area"></div>

        <div id="controls-wrapper">
            <div id="dynamic-controls"></div>
            <div class="btn-row">
                <button class="btn-back" onclick="prevStep()">Back</button>
                <button class="btn-next" id="btn-next" onclick="nextStep()">Next</button>
            </div>
        </div>
    </aside>

    <main>
        <canvas id="simCanvas"></canvas>
    </main>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        let simState = {
            targetVoltage: 0,
            currentVoltage: 0,
            capacitance: 2.0,
            isDischarging: false,
            switchAngle: -Math.PI / 4, // Start open
            flashAlpha: 0
        };

        function resize() {
            canvas.width = window.innerWidth - 420;
            canvas.height = window.innerHeight - 40;
        }
        window.addEventListener('resize', resize);
        resize();

        function drawCircuit(v) {
            const cx = canvas.width * 0.3;
            const cy = canvas.height * 0.5;
            const w = 140; // Circuit loop half-width
            const h = 100; // Circuit loop half-height
            const plateW = 80;
            const plateGap = 50;

            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // 1. DRAW BATTERY (Left Side)
            const bx = cx - w;
            ctx.strokeStyle = '#ff9f43';
            ctx.lineWidth = 3;
            // Large plate (+)
            ctx.beginPath(); ctx.moveTo(bx - 20, cy - 10); ctx.lineTo(bx + 20, cy - 10); ctx.stroke();
            // Small plate (-)
            ctx.lineWidth = 5;
            ctx.beginPath(); ctx.moveTo(bx - 10, cy + 10); ctx.lineTo(bx + 10, cy + 10); ctx.stroke();

            ctx.fillStyle = '#ff9f43';
            ctx.font = '12px monospace';
            ctx.fillText("BATTERY", bx - 25, cy + 35);

            // 2. DRAW WIRES (The Loop)
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            ctx.beginPath();
            // Bottom wire
            ctx.moveTo(bx, cy + 10);
            ctx.lineTo(bx, cy + h);
            ctx.lineTo(cx, cy + h);
            ctx.lineTo(cx, cy + plateGap / 2);
            // Top wire (Battery to Switch)
            ctx.moveTo(bx, cy - 10);
            ctx.lineTo(bx, cy - h);
            ctx.lineTo(cx - 50, cy - h);
            ctx.stroke();

            // 3. THE SWITCH (Top Middle)
            const swX = cx - 50;
            const swY = cy - h;
            // Target: Closed (0 rad) if charging, else Open (-45 deg)
            const targetAngle = (simState.targetVoltage > 0 && !simState.isDischarging) ? 0 : -Math.PI / 4;
            simState.switchAngle += (targetAngle - simState.switchAngle) * 0.15;

            ctx.strokeStyle = '#fff';
            ctx.beginPath(); ctx.arc(swX, swY, 4, 0, Math.PI * 2); ctx.stroke(); // Pivot point

            ctx.save();
            ctx.translate(swX, swY);
            ctx.rotate(simState.switchAngle);
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(45, 0); ctx.lineWidth = 4; ctx.stroke();
            ctx.restore();

            // Terminal contact
            ctx.beginPath(); ctx.arc(swX + 50, swY, 4, 0, Math.PI * 2); ctx.stroke();

            // Wire from switch contact to capacitor
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(swX + 50, swY);
            ctx.lineTo(cx, swY);
            ctx.lineTo(cx, cy - plateGap / 2);
            ctx.stroke();

            // 4. DRAW CAPACITOR PLATES
            ctx.lineWidth = 6;
            ctx.strokeStyle = '#888';
            // Top
            ctx.beginPath(); ctx.moveTo(cx - plateW / 2, cy - plateGap / 2); ctx.lineTo(cx + plateW / 2, cy - plateGap / 2); ctx.stroke();
            // Bottom
            ctx.beginPath(); ctx.moveTo(cx - plateW / 2, cy + plateGap / 2); ctx.lineTo(cx + plateW / 2, cy + plateGap / 2); ctx.stroke();

            // 5. ENERGY GLOW
            if (v > 0.1) {
                const alpha = Math.min(v / 10, 0.8);
                const grad = ctx.createLinearGradient(0, cy - plateGap / 2, 0, cy + plateGap / 2);
                grad.addColorStop(0, `rgba(0, 210, 211, 0)`);
                grad.addColorStop(0.5, `rgba(0, 210, 211, ${alpha})`);
                grad.addColorStop(1, `rgba(0, 210, 211, 0)`);
                ctx.fillStyle = grad;
                ctx.fillRect(cx - plateW / 2, cy - plateGap / 2, plateW, plateGap);
            }
            ctx.fillStyle = '#fff';
            ctx.fillText("CAPACITOR", cx - 30, cy + plateGap + 20);
        }

        function drawGraph(v) {
            const gx = canvas.width * 0.65;
            const gy = canvas.height * 0.7;
            const gW = 200;
            const gH = 200;

            // Axes
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(gx, gy - gH); ctx.lineTo(gx, gy); ctx.lineTo(gx + gW, gy);
            ctx.stroke();

            const maxV = 10;
            const maxQ = maxV * simState.capacitance;
            const curQ = v * simState.capacitance;

            const px = gx + (curQ / maxQ) * gW;
            const py = gy - (v / maxV) * gH;

            // Area (Energy U)
            ctx.fillStyle = 'rgba(0, 210, 211, 0.2)';
            ctx.beginPath();
            ctx.moveTo(gx, gy);
            ctx.lineTo(px, py);
            ctx.lineTo(px, gy);
            ctx.closePath();
            ctx.fill();

            // Hypotenuse
            ctx.strokeStyle = '#00d2d3';
            ctx.beginPath(); ctx.moveTo(gx, gy); ctx.lineTo(px, py); ctx.stroke();

            // Labels
            ctx.fillStyle = '#888';
            ctx.font = '12px monospace';
            ctx.fillText("Voltage (V)", gx - 70, gy - gH);
            ctx.fillText("Charge (q)", gx + gW + 10, gy + 5);
            if (v > 1) {
                ctx.fillStyle = '#00d2d3';
                ctx.fillText("Energy U", gx + (px - gx) / 2 - 20, gy - 10);
            }
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (simState.isDischarging) {
                simState.currentVoltage *= 0.8; // Fast decay
                if (simState.currentVoltage < 0.1) {
                    simState.currentVoltage = 0;
                    simState.isDischarging = false;
                    simState.targetVoltage = 0;
                    const s = document.getElementById('slider-voltage');
                    if (s) s.value = 0;
                }
            } else {
                simState.currentVoltage += (simState.targetVoltage - simState.currentVoltage) * 0.1;
            }

            drawCircuit(simState.currentVoltage);
            drawGraph(simState.currentVoltage);

            // Flash effect
            if (simState.flashAlpha > 0) {
                ctx.fillStyle = `rgba(255,255,255,${simState.flashAlpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                simState.flashAlpha -= 0.05;
            }

            requestAnimationFrame(render);
        }

        const steps = [
            {
                title: "Work & Circuit",
                content: `<div class="chapter-marker">The Setup</div><h2>Charging Energy</h2><p>To store energy, a battery must perform <b>Work</b>. It pumps electrons through the wires to the capacitor plates.</p><p>Notice the <b>Switch</b>. When open, no charge flows. Adjust the slider to close the circuit.</p>`,
                controls: `<div class="control-header"><span>Battery Voltage</span><span id="val-v" class="control-val">0.0V</span></div><input id="slider-voltage" type="range" min="0" max="10" step="0.1" value="0" oninput="updateV(this.value)">`,
                onEnter: () => { simState.targetVoltage = 0; }
            },
            {
                title: "Geometric Proof",
                content: `<div class="chapter-marker">The Derivation</div><h2>The Area is Work</h2><p>The work required to add a tiny charge $dq$ at voltage $V$ is $dW = V dq$.</p><p>Since $V = q/C$, the total energy is the area under the triangle:</p><div class="math-highlight">$$ U = \\int_0^Q \\frac{q}{C} dq = \\frac{1}{2} \\frac{Q^2}{C} $$</div>`,
                controls: `<div class="control-header"><span>Battery Voltage</span><span id="val-v" class="control-val">6.0V</span></div><input id="slider-voltage" type="range" min="0" max="10" step="0.1" value="6" oninput="updateV(this.value)">`,
                onEnter: () => { updateV(6); }
            },
            {
                title: "Final Formula",
                content: `<div class="chapter-marker">The Result</div><h2>Energy Stored</h2><p>Using $Q = CV$, we get the most useful form of the energy equation:</p><div class="math-highlight">$$ U = \\frac{1}{2} C V^2 $$</div><p>This shows energy scales with the <b>square</b> of voltage. High voltage capacitors are extremely dangerous!</p>`,
                controls: `<div class="control-header"><span>Battery Voltage</span><span id="val-v" class="control-val">10.0V</span></div><input id="slider-voltage" type="range" min="0" max="10" step="0.1" value="10" oninput="updateV(this.value)">`,
                onEnter: () => { updateV(10); }
            },
            {
                title: "Discharge",
                content: `<div class="chapter-marker">Application</div><h2>Fast Discharge</h2><p>When the switch opens and the capacitor is connected to a load (like a flash bulb), it releases all that stored energy in milliseconds.</p><button class="btn-action" onclick="triggerDischarge()"> TRIGGER FLASH </button>`,
                controls: `<div class="control-header"><span>Charged Voltage</span><span id="val-v" class="control-val">10.0V</span></div><input id="slider-voltage" type="range" disabled value="10">`,
                onEnter: () => { updateV(10); }
            }
        ];

        let currentStep = 0;
        function loadStep(idx) {
            currentStep = idx;
            const s = steps[idx];
            const area = document.getElementById('content-area');
            area.innerHTML = s.content;
            renderMathInElement(area, { delimiters: [{ left: "$$", right: "$$", display: true }, { left: "$", right: "$", display: false }] });
            document.getElementById('dynamic-controls').innerHTML = s.controls;
            document.querySelector('.btn-back').disabled = idx === 0;
            document.getElementById('btn-next').innerText = idx === steps.length - 1 ? "Restart" : "Next";
            if (s.onEnter) s.onEnter();
        }

        window.updateV = (v) => {
            simState.targetVoltage = parseFloat(v);
            const d = document.getElementById('val-v');
            if (d) d.innerText = simState.targetVoltage.toFixed(1) + "V";
        };

        window.triggerDischarge = () => {
            simState.isDischarging = true;
            simState.flashAlpha = 0.8;
        };

        window.nextStep = () => {
            if (currentStep < steps.length - 1) loadStep(currentStep + 1);
            else loadStep(0);
        };

        window.addEventListener('load', () => {
            loadStep(0);
            render();
        });
    </script>
</body>

</html>
<!-- END: 6_energy_in_cap.html -->

<!-- START: 7_cylindrical_cap.html -->


<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Maxwell's Notebook: 3D Capacitor Geometry</title>
    <!-- Load KaTeX for Math Rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body);"></script>

    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        :root {
            --bg: #0f0f0f;
            --panel: #181818;
            --text-main: #e0e0e0;
            --text-muted: #888;
            --accent: #ff9f43;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text-main);
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }

        aside {
            width: 400px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 5px 0 20px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
        }

        h1 {
            margin: 0;
            font-size: 18px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: var(--text-muted);
        }

        #content-area {
            flex: 1;
            padding: 25px;
            overflow-y: auto;
        }

        .chapter-marker {
            font-size: 11px;
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        h2 {
            margin: 0 0 15px 0;
            font-size: 22px;
            color: #fff;
        }

        p {
            line-height: 1.6;
            font-size: 14px;
            color: #ccc;
            margin-bottom: 15px;
        }

        .math-highlight {
            background: rgba(255, 255, 255, 0.03);
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid var(--accent);
            margin: 15px 0;
            text-align: center;
            font-size: 1.1em;
        }

        #controls-wrapper {
            background: #111;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-header {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .control-val {
            color: var(--accent);
            font-family: monospace;
            font-weight: bold;
        }

        .btn-row {
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 11px;
            transition: 0.2s;
        }

        .btn-next {
            background: var(--accent);
            color: #111;
        }

        .btn-back {
            background: transparent;
            border: 1px solid #444;
            color: #888;
        }

        main {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Lesson 14: Geometry of Capacitance</div>
        </header>

        <div id="content-area"></div>

        <div id="controls-wrapper">
            <div id="dynamic-controls"></div>
            <div class="btn-row">
                <button class="btn-back" onclick="prevStep()">Back</button>
                <button class="btn-next" id="btn-next" onclick="nextStep()">Next</button>
            </div>
        </div>
    </aside>

    <main>
        <div id="canvas-container"></div>
    </main>

    <script>
        // --- THREE.JS SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);

        const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(25, 20, 25);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xff9f43, 2, 100);
        pointLight.position.set(15, 15, 15);
        scene.add(pointLight);

        const grid = new THREE.GridHelper(60, 40, 0x222222, 0x111111);
        scene.add(grid);

        // --- GEOMETRY ---
        const SEGMENTS = 500; // Higher segments for smoother spiral
        const STRIP_LENGTH = 45;
        const STRIP_WIDTH = 8;
        const PLATE_GAP = 0.6; // Increased gap to prevent Z-fighting

        const plateMat = new THREE.MeshStandardMaterial({ color: 0xff9f43, side: THREE.DoubleSide, metalness: 0.7, roughness: 0.2 });
        // Dielectric is slightly more opaque to define boundaries
        const dielectricMat = new THREE.MeshStandardMaterial({ color: 0x34495e, side: THREE.DoubleSide, transparent: true, opacity: 0.85 });

        function createRibbon(offsetY, material) {
            const geometry = new THREE.PlaneGeometry(STRIP_LENGTH, STRIP_WIDTH, SEGMENTS, 1);
            geometry.rotateX(-Math.PI / 2);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.y = offsetY;
            mesh.userData = {
                originalPos: geometry.attributes.position.clone(),
                yOffset: offsetY // Store the specific lane (Top, Mid, or Bot)
            };
            return mesh;
        }

        const plateTop = createRibbon(PLATE_GAP, plateMat);
        const dielectric = createRibbon(0, dielectricMat);
        const plateBot = createRibbon(-PLATE_GAP, plateMat);

        const capacitorGroup = new THREE.Group();
        capacitorGroup.add(plateTop, dielectric, plateBot);
        scene.add(capacitorGroup);

        let simState = { rollProgress: 0, targetRoll: 0 };

        function updateGeometry(mesh, progress) {
            const positions = mesh.geometry.attributes.position;
            const original = mesh.userData.originalPos;
            const yOffset = mesh.userData.yOffset; // Lane identifier

            const coreRadius = 2.0;
            const maxTheta = STRIP_LENGTH / coreRadius;

            for (let i = 0; i < positions.count; i++) {
                const ox = original.getX(i);
                const oy = original.getY(i); // This is the local Y (thickness)
                const oz = original.getZ(i);
                const u = (ox + STRIP_LENGTH / 2) / STRIP_LENGTH;

                if (progress < 0.001) {
                    positions.setXYZ(i, ox, oy, oz);
                } else {
                    // spiral wrapping
                    const theta = u * maxTheta * progress * 2.8;

                    // SPIRAL GROWTH (b): Increased to 0.25 to ensure layers don't overlap
                    // as they wrap around.
                    const b = 0.25;

                    // RADIUS CALCULATION:
                    // We add 'yOffset' to the radius. This ensures PlateTop is always 
                    // further from center than Dielectric, which is further than PlateBot.
                    const radius = coreRadius + (b * theta) + (yOffset * progress);

                    const tx = radius * Math.cos(-theta);
                    const ty = oz; // width becomes cylinder height
                    const tz = radius * Math.sin(-theta);

                    positions.setXYZ(i,
                        ox * (1 - progress) + tx * progress,
                        oy * (1 - progress) + ty * progress,
                        oz * (1 - progress) + tz * progress
                    );
                }
            }
            positions.needsUpdate = true;
            mesh.geometry.computeVertexNormals();
        }

        function animate() {
            requestAnimationFrame(animate);
            simState.rollProgress += (simState.targetRoll - simState.rollProgress) * 0.06;

            if (simState.rollProgress > 0.8) {
                capacitorGroup.rotation.y += 0.01;
            } else {
                capacitorGroup.rotation.y *= 0.92;
            }

            updateGeometry(plateTop, simState.rollProgress);
            updateGeometry(dielectric, simState.rollProgress);
            updateGeometry(plateBot, simState.rollProgress);
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = (window.innerWidth - 400) / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - 400, window.innerHeight);
        });

        // --- STEPS ---
        const steps = [
            {
                title: "The Formula",
                content: `<div class="chapter-marker">Introduction</div><h2>Linear Geometry</h2>
            <p>Capacitance ($C$) is determined by the Area ($A$) of conductors and the distance ($d$) between them:</p>
            <div class="math-highlight">$$ C = \\epsilon \\frac{A}{d} $$</div>
            <p>To maximize $C$, we need a massive area, but we must fit it into a tiny electronic device.</p>`,
                controls: `<div class="control-header"><span>Status</span><span class="control-val">Flat Plates</span></div>`,
                onEnter: () => { simState.targetRoll = 0; }
            },
            {
                title: "Spatial Constraints",
                content: `<div class="chapter-marker">The Problem</div><h2>Infinite Length</h2>
            <p>Stretching these plates to increase Area would make the capacitor meters long. This is impractical for a circuit board.</p>`,
                controls: `<div class="control-header"><span>Status</span><span class="control-val">Flat Ribbon</span></div>`,
                onEnter: () => { simState.targetRoll = 0.0; }
            },
            {
                title: "The Solution",
                content: `<div class="chapter-marker">The Transformation</div><h2>The Radial Wrap</h2>
            <p>We roll the "sandwich" into a <b>spiral cylinder</b>.</p>
            <p>Notice how the layers wrap without touching. This geometric trick allows us to pack several square meters of foil into a tiny can.</p>`,
                controls: `<div class="control-header"><span>Status</span><span class="control-val">Rolling...</span></div>`,
                onEnter: () => { simState.targetRoll = 1.0; }
            },
            {
                title: "Final Form",
                content: `<div class="chapter-marker">Engineering</div><h2>The Jelly Roll</h2>
            <p>This is the "Jelly Roll" construction found inside almost every electrolytic capacitor.</p>
            <p>The cylinder is then sealed in an aluminum casing, creating the familiar electronic component we see today.</p>`,
                controls: `<div class="control-header"><span>Status</span><span class="control-val">Complete Cylinder</span></div>`,
                onEnter: () => { simState.targetRoll = 1.0; }
            }
        ];

        let currentStep = 0;
        function loadStep(idx) {
            currentStep = idx;
            const s = steps[idx];
            const area = document.getElementById('content-area');
            area.innerHTML = s.content;
            renderMathInElement(area, { delimiters: [{ left: "$$", right: "$$", display: true }, { left: "$", right: "$", display: false }] });

            document.getElementById('dynamic-controls').innerHTML = s.controls;
            document.querySelector('.btn-back').style.opacity = idx === 0 ? "0.3" : "1";
            document.querySelector('.btn-back').disabled = idx === 0;
            document.getElementById('btn-next').innerText = idx === steps.length - 1 ? "Restart" : "Next";

            if (s.onEnter) s.onEnter();
        }

        window.nextStep = () => {
            if (currentStep < steps.length - 1) loadStep(currentStep + 1);
            else loadStep(0);
        };

        window.prevStep = () => {
            if (currentStep > 0) loadStep(currentStep - 1);
        };

        window.addEventListener('load', () => loadStep(0));

    </script>
</body>

</html>
<!-- END: 7_cylindrical_cap.html -->

<!-- START: 8_flash.html -->
<!DOCTYPE html>
<html>

<head>
    <title>Capacitor Lesson - Interactive Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #151515;
            font-family: 'Segoe UI', sans-serif;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        /* --- Interface Layout (Orange/Dark Theme) --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            --border: #333;
        }

        .interface-sidebar {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
            color: var(--text);
        }

        .interface-sidebar header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        .interface-sidebar h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .interface-sidebar .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        .story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .highlight {
            color: var(--accent);
        }

        .nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            text-transform: uppercase;
            font-weight: bold;
            transition: background 0.2s;
        }

        .nav-btn:hover {
            background: #444;
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .nav-btn.next {
            background: var(--accent);
            color: #151515;
        }

        .nav-btn.next:hover {
            background: #e08e3d;
        }

        /* Info Panel Overlay */
        #info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 220px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.8);
            border-radius: 5px;
            color: white;
            z-index: 5;
            pointer-events: none;
            /* Let clicks pass through to canvas if not on text */
            display: none;
        }

        #info-panel h3 {
            margin: 0 0 10px 0;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
            color: var(--accent);
        }

        #info-panel p {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 14px;
            color: #ccc;
        }

        #info-panel span {
            color: #fff;
            font-weight: bold;
        }

        /* Sim Container */
        .sim-container {
            position: absolute;
            top: 0;
            left: 420px;
            right: 0;
            bottom: 0;
            background: #151515;
        }
    </style>

    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/geometries/TextGeometry.js"></script>
</head>

<body>

    <!-- Sidebar Interface -->
    <div class="interface-sidebar">
        <header>
            <h1>Electric Fields</h1>
            <div class="subtitle">Capacitor Interactive Lesson</div>
        </header>

        <div class="story-container">
            <div class="chapter-title" id="story-title">Step 1: Introduction</div>
            <div class="story-text" id="story-content">
                <!-- Text injected via JS -->
            </div>
        </div>

        <div class="nav-footer">
            <button class="nav-btn" id="btn-back" onclick="changeStep(-1)">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="changeStep(1)">Next &rarr;</button>
        </div>
    </div>

    <!-- Simulation Area -->
    <div class="sim-container">
        <!-- Info Panel (Floating) -->
        <div id="info-panel">
            <h3 id="info-title">Component</h3>
            <div id="dynamic-info"></div>
        </div>
    </div>

    <script>
        // --- STORY DATA ---
        const STORY_STEPS = [
            {
                title: "Step 1: Introduction (The Setup)",
                text: `Class, look at the screen. We are going to apply what we just learned about Electric Fields.<br><br>
            On the left, we have a <strong>Battery</strong>. Don't think of it as a power source yetthink of it as an 'Electron Pump.' It creates a constant pressure (potential) to push charges.<br><br>
            In the middle, that blue cylinder? That is our <strong>Capacitor</strong>.<br>
            Inside that cylinder are two metal plates effectively separated by a gap. Electrons cannot jump across that gap.<br><br>
            On the right, we have a <strong>Lamp</strong>. Ideally, it needs moving charges to light up.`
            },
            {
                title: "Step 2: Charging",
                text: `Now, watch closely. Toggle the <strong>Left Switch</strong> to connect the pump (Battery) to the Capacitor.<br><br>
            <span class="highlight">Click the Left Switch to turn it ON (Close it).</span><br><br>
            Current flows, but stop and thinkit doesn't flow <em>through</em> the capacitor.
            Instead, the battery is ripping electrons off one plate and shoving them onto the other.<br><br>
            Positive charges are building up on the left plate; negative charges are piling up on the right plate.<br>
            What is happening inside that gap? <strong>An Electric Field is building up.</strong><br><br>
            We are storing energynot in the wires, but in the stress of that field holding those opposite charges apart.`
            },
            {
                title: "Step 3: The Disconnect",
                text: `Now, open the switch. The battery is gone.<br><br>
            <span class="highlight">Click the Left Switch again to turn it OFF (Open it).</span><br><br>
            Is the energy gone? <strong>No.</strong><br><br>
            The electrons on the negative plate are trapped. They desperately want to get back to the positive plate to neutralize, but they can't jump the gap. The electric field is still there, holding that energy, waiting for a path.`
            },
            {
                title: "Step 4: Discharging",
                text: `Now, we give them a path. Connect the Capacitor to the Lamp.<br><br>
            <span class="highlight">Click the Right Switch to turn it ON.</span><br><br>
            <strong>Boom! Light!</strong><br><br>
            Why? The electrons rush from the negative plate, through the wire, through the filament of the bulb, creating heat and light, to get back to the positive plate.<br><br>
            But watch... the light is getting dimmer... and dimmer...<br>
            Why? As the charges neutralize, the separation decreases. The Electric Field gets weaker. The 'push' gets softer.<br>
            Eventually, the plates are neutral again. The field is gone. The energy is spent.`
            },
            {
                title: "Step 5: Conclusion",
                text: `So, a <strong>Capacitor</strong> isn't a battery. It doesn't create energy.<br><br> 
            Its a bucket. We poured the electric field in, stored it, and then poured it out through the lamp.<br><br>
            <em>Feel free to experiment with the switches to repeat the cycle.</em>`
            }
        ];

        let currentStepIndex = 0;

        function renderStory() {
            const step = STORY_STEPS[currentStepIndex];
            document.getElementById('story-title').innerText = step.title;
            document.getElementById('story-content').innerHTML = step.text;

            document.getElementById('btn-back').disabled = (currentStepIndex === 0);
            document.getElementById('btn-next').innerText = (currentStepIndex === STORY_STEPS.length - 1) ? "Finish" : "Next \u2192";
        }

        function changeStep(delta) {
            if (currentStepIndex + delta >= 0 && currentStepIndex + delta < STORY_STEPS.length) {
                currentStepIndex += delta;
                renderStory();
            } else if (currentStepIndex + delta >= STORY_STEPS.length) {
                alert("End of Lesson. Feel free to explore the sandbox!");
            }
        }

        // Initialize Story
        renderStory();

        // --- SIMULATION DATA (Battery -> Switch -> Cap -> Switch -> Lamp) ---
        window.STANDALONE_DATA = {
            "components": [
                { "id": 0, "type": "battery", "position": { "x": -12, "y": 0, "z": 0 }, "isOn": true },
                { "id": 1, "type": "switch", "position": { "x": -6, "y": 0, "z": -4 }, "isOn": false }, // Charge Switch
                { "id": 2, "type": "capacitor", "position": { "x": 0, "y": 0, "z": 0 }, "isOn": true },
                { "id": 3, "type": "switch", "position": { "x": 6, "y": 0, "z": -4 }, "isOn": false }, // Discharge Switch
                { "id": 4, "type": "bulb", "position": { "x": 12, "y": 0, "z": 0 }, "isOn": true }
            ],
            "wires": [
                { "start": { "componentId": 0, "nodeIndex": 0 }, "end": { "componentId": 1, "nodeIndex": 0 }, "controlPoints": [{ "x": -12, "y": 3, "z": -4 }] },
                { "start": { "componentId": 1, "nodeIndex": 1 }, "end": { "componentId": 2, "nodeIndex": 0 }, "controlPoints": [{ "x": 0, "y": 3, "z": -4 }] },
                { "start": { "componentId": 2, "nodeIndex": 1 }, "end": { "componentId": 0, "nodeIndex": 1 }, "controlPoints": [{ "x": -6, "y": 0, "z": 4 }] },
                { "start": { "componentId": 2, "nodeIndex": 0 }, "end": { "componentId": 3, "nodeIndex": 0 }, "controlPoints": [{ "x": 0, "y": 4, "z": -4 }] },
                { "start": { "componentId": 3, "nodeIndex": 1 }, "end": { "componentId": 4, "nodeIndex": 0 }, "controlPoints": [{ "x": 12, "y": 3, "z": -4 }] },
                { "start": { "componentId": 4, "nodeIndex": 1 }, "end": { "componentId": 2, "nodeIndex": 1 }, "controlPoints": [{ "x": 6, "y": 0, "z": 4 }] }
            ]
        };

        // --- 3D SIMULATION ENGINE ---
        const scene = new THREE.Scene();
        const simContainer = document.querySelector('.sim-container');
        const width = simContainer.clientWidth;
        const height = simContainer.clientHeight;

        const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
        camera.position.set(0, 25, 30); // Overhead View

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        simContainer.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 0, 0);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        const gridHelper = new THREE.GridHelper(50, 50, 0x333333, 0x222222);
        scene.add(gridHelper);

        let components = [], wires = [];
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedComponent = null;

        const nodeMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, visible: false });

        function createComponent(data) {
            const mesh = new THREE.Group();
            mesh.position.set(data.position.x, data.position.y, data.position.z);

            let compObj = {
                id: data.id,
                type: data.type,
                mesh: mesh,
                nodes: [],
                isOn: data.isOn,
                voltage: 0,
                charge: 0,
                capacitance: 0.1,
                isPowered: false,
                polarityDirection: 1
            };

            if (data.type === 'battery') {
                compObj.voltage = 9.0;
                const body = new THREE.Mesh(new THREE.BoxGeometry(2, 3, 2), new THREE.MeshStandardMaterial({ color: 0x333333 }));
                body.position.y = 1.5;
                const t1 = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.5), new THREE.MeshStandardMaterial({ color: 0xcccccc }));
                t1.position.set(0, 3.25, 0);
                mesh.add(body, t1);
                addLabel(mesh, "+", new THREE.Vector3(0, 2, 1.1), 0xffffff);
                addNode(compObj, new THREE.Vector3(0, 3.5, 0));
                addNode(compObj, new THREE.Vector3(0, 0, 0));
            }
            else if (data.type === 'capacitor') {
                const body = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 3, 32), new THREE.MeshStandardMaterial({ color: 0x0077be }));
                body.position.y = 1.5;
                mesh.add(body);
                addLabel(mesh, "1.0F", new THREE.Vector3(0, 1.5, 1.6), 0xffffff);
                addNode(compObj, new THREE.Vector3(0, 3, 0));
                addNode(compObj, new THREE.Vector3(0, 0, 0));
            }
            else if (data.type === 'bulb') {
                const base = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.5), new THREE.MeshStandardMaterial({ color: 0x555555 }));
                base.position.y = 0.25;
                const glass = new THREE.Mesh(new THREE.SphereGeometry(1.2, 32, 32), new THREE.MeshStandardMaterial({ color: 0x444444, transparent: true, opacity: 0.8 }));
                glass.position.y = 1.2;
                glass.name = 'glass';
                mesh.add(base, glass);
                addNode(compObj, new THREE.Vector3(0, 0, 0));
                addNode(compObj, new THREE.Vector3(0, 2.4, 0));
            }
            else if (data.type === 'switch') {
                const base = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 2), new THREE.MeshStandardMaterial({ color: 0x444444 }));
                const lever = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 0.5), new THREE.MeshStandardMaterial({ color: 0xff9f43 }));

                // --- FIX: Initial Visual State ---
                // If ON (Closed): Lever is Flat (Rot 0), Low (0.2)
                // If OFF (Open): Lever is Tilted (Rot PI/6), High (1.0)
                if (compObj.isOn) {
                    lever.rotation.z = 0;
                    lever.position.set(0, 0.2, 0);
                } else {
                    lever.rotation.z = Math.PI / 6;
                    lever.position.set(0, 1.0, 0);
                }

                lever.name = 'lever';
                mesh.add(base, lever);
                addNode(compObj, new THREE.Vector3(-1.4, 0, 0));
                addNode(compObj, new THREE.Vector3(1.4, 0, 0));
            }

            mesh.userData = compObj;
            scene.add(mesh);
            components.push(compObj);
            return compObj;
        }

        function addNode(comp, loc) {
            const n = new THREE.Mesh(new THREE.SphereGeometry(0.2), nodeMat);
            n.position.copy(loc);
            n.userData = { component: comp };
            comp.mesh.add(n);
            comp.nodes.push(n);
        }

        function addLabel(parent, text, pos, color) {
            const loader = new THREE.FontLoader();
            loader.load('https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                const geo = new THREE.TextGeometry(text, { font: font, size: 0.6, height: 0.1 });
                geo.center();
                const mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: color }));
                mesh.position.copy(pos);
                parent.add(mesh);
            });
        }

        function createWire(d) {
            const c1 = components.find(c => c.id === d.start.componentId);
            const c2 = components.find(c => c.id === d.end.componentId);
            if (!c1 || !c2) return;
            const n1 = c1.nodes[d.start.nodeIndex];
            const n2 = c2.nodes[d.end.nodeIndex];

            const pathPoints = [
                n1.getWorldPosition(new THREE.Vector3()),
                ...d.controlPoints.map(p => new THREE.Vector3(p.x, p.y, p.z)),
                n2.getWorldPosition(new THREE.Vector3())
            ];

            const curve = new THREE.CatmullRomCurve3(pathPoints);
            const geo = new THREE.TubeGeometry(curve, 20, 0.1, 8, false);
            const mat = new THREE.MeshStandardMaterial({ color: 0xb87333 });
            const mesh = new THREE.Mesh(geo, mat);

            scene.add(mesh);
            wires.push({ startNode: n1, endNode: n2, mesh: mesh });
        }

        const data = window.STANDALONE_DATA;
        data.components.forEach(createComponent);
        setTimeout(() => { data.wires.forEach(createWire); }, 100);

        // --- INTERACTION ---
        function onMouseDown(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            const hit = intersects.find(i => i.object.parent && i.object.parent.userData && i.object.parent.userData.id !== undefined);

            if (hit) {
                const comp = hit.object.parent.userData;
                selectedComponent = comp;
                updateInfoPanel(comp);

                if (comp.type === 'switch') {
                    comp.isOn = !comp.isOn;
                    // --- FIX: Animation Logic ---
                    // If ON (Closed): Lever goes Flat (Rot 0)
                    // If OFF (Open): Lever goes Tilted (Rot PI/6)
                    const lever = comp.mesh.getObjectByName('lever');
                    lever.rotation.z = comp.isOn ? 0 : Math.PI / 6;
                    lever.position.y = comp.isOn ? 0.2 : 1.0;
                }
            } else {
                selectedComponent = null;
                document.getElementById('info-panel').style.display = 'none';
            }
        }

        function updateInfoPanel(comp) {
            const panel = document.getElementById('info-panel');
            const content = document.getElementById('dynamic-info');
            const title = document.getElementById('info-title');

            if (!comp) { panel.style.display = 'none'; return; }

            panel.style.display = 'block';
            title.innerText = comp.type.toUpperCase();

            let html = '';
            if (comp.type === 'battery') {
                html += `<p>Voltage <span>${comp.voltage.toFixed(1)} V</span></p>`;
            } else if (comp.type === 'capacitor') {
                html += `<p>Charge <span>${comp.charge.toFixed(3)} C</span></p>`;
                html += `<p>Voltage <span>${comp.voltage.toFixed(2)} V</span></p>`;
                html += `<p>Status <span>${comp.isPowered ? 'Active' : 'Idle'}</span></p>`;
            } else if (comp.type === 'bulb') {
                html += `<p>Status <span>${comp.isPowered ? 'ON' : 'OFF'}</span></p>`;
            } else if (comp.type === 'switch') {
                html += `<p>State <span>${comp.isOn ? 'CLOSED (On)' : 'OPEN (Off)'}</span></p>`;
            }
            content.innerHTML = html;
        }

        renderer.domElement.addEventListener('pointerdown', onMouseDown);

        // --- SIMULATION LOGIC ---
        function simulate(dt) {
            const bat = components.find(c => c.id === 0);
            const swCharge = components.find(c => c.id === 1);
            const cap = components.find(c => c.id === 2);
            const swDischarge = components.find(c => c.id === 3);
            const bulb = components.find(c => c.id === 4);

            let isCharging = false;
            if (swCharge.isOn) isCharging = true;

            if (isCharging) {
                let chargeRate = (bat.voltage - cap.voltage) * 2.0;
                if (chargeRate < 0) chargeRate = 0;
                cap.charge = Math.min(cap.charge + chargeRate * dt, cap.capacitance * bat.voltage);
            }

            let isDischarging = false;
            if (swDischarge.isOn) isDischarging = true;

            bulb.isPowered = false;

            if (isDischarging && cap.voltage > 0.1) {
                let R = 10;
                let current = cap.voltage / R;
                cap.charge = Math.max(0, cap.charge - current * dt);

                bulb.isPowered = true;
                let brightness = Math.min(current / 0.5, 1.0);
                bulb.mesh.getObjectByName('glass').material.emissive.setHex(0xffaa00);
                bulb.mesh.getObjectByName('glass').material.emissiveIntensity = brightness;
            } else {
                bulb.mesh.getObjectByName('glass').material.emissive.setHex(0x000000);
            }

            cap.voltage = cap.charge / cap.capacitance;
            cap.isPowered = (Math.abs(cap.charge) > 0.01);

            if (selectedComponent) updateInfoPanel(selectedComponent);
        }

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            simulate(dt);
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            const w = simContainer.clientWidth;
            const h = simContainer.clientHeight;
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
        });

        animate();
    </script>
</body>

</html>
<!-- END: 8_flash.html -->

<!-- START: t.html -->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Maxwell's Notebook: Capacitor Discharge & Fuses</title>
    <!-- Load KaTeX for Math Rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body);"></script>

    <style>
        :root {
            --bg: #0f0f0f;
            --panel: #181818;
            --text-main: #e0e0e0;
            --text-muted: #888;
            --accent: #ff9f43;
            /* Maxwell Orange / Battery */
            --energy: #00d2d3;
            /* Cyan for Electric Field */
            --border: #333;
            --fuse: #e74c3c;
            /* Red for fuse */
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text-main);
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }

        /* --- SIDEBAR --- */
        aside {
            width: 380px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 5px 0 20px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
        }

        h1 {
            margin: 0;
            font-size: 18px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: var(--text-muted);
        }

        #content-area {
            flex: 1;
            padding: 25px;
            overflow-y: auto;
        }

        .chapter-marker {
            font-size: 11px;
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        h2 {
            margin: 0 0 15px 0;
            font-size: 22px;
            color: #fff;
        }

        p {
            line-height: 1.6;
            font-size: 14px;
            color: #ccc;
            margin-bottom: 15px;
        }

        .math-highlight {
            background: rgba(255, 255, 255, 0.03);
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid var(--energy);
            margin: 15px 0;
            text-align: center;
            font-size: 1.1em;
        }

        /* --- CONTROLS --- */
        #controls-wrapper {
            background: #111;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-header {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .control-val {
            color: var(--accent);
            font-family: monospace;
            font-weight: bold;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--accent);
        }

        .btn-row {
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 11px;
            transition: 0.2s;
        }

        .btn-next {
            background: var(--accent);
            color: #111;
        }

        .btn-back {
            background: transparent;
            border: 1px solid #444;
            color: #888;
        }

        .btn-action {
            background: var(--fuse);
            color: white;
            width: 100%;
            margin-top: 10px;
        }

        .btn-action:hover {
            background: #ff4757;
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.4);
        }

        /* --- CANVAS --- */
        main {
            flex: 1;
            position: relative;
            background: #050505;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            background: #000;
            border-radius: 8px;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Lesson 14: Discharge & Fuses</div>
        </header>

        <div id="content-area"></div>

        <div id="controls-wrapper">
            <div id="dynamic-controls"></div>
            <div class="btn-row">
                <button class="btn-back" onclick="prevStep()">Back</button>
                <button class="btn-next" id="btn-next" onclick="nextStep()">Next</button>
            </div>
        </div>
    </aside>

    <main>
        <canvas id="simCanvas"></canvas>
    </main>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        let simState = {
            voltage: 0,
            capacitance: 1.0,     // Farads (scaled for visibility)
            resistance: 10,       // Ohms (load)
            fuseRating: 5,        // Amps
            isDischarging: false,
            fuseBlown: false,
            time: 0,
            flashAlpha: 0,
            sparkAlpha: 0
        };

        function resize() {
            canvas.width = window.innerWidth - 420;
            canvas.height = window.innerHeight - 40;
        }
        window.addEventListener('resize', resize);
        resize();

        function drawCircuit(v) {
            const cx = canvas.width * 0.35;
            const cy = canvas.height * 0.5;
            const plateW = 80;
            const plateGap = 50;
            const fuseX = cx - 120;
            const fuseY = cy - 80;

            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // 1. CAPACITOR
            ctx.lineWidth = 6;
            ctx.strokeStyle = '#888';
            ctx.beginPath(); ctx.moveTo(cx - plateW / 2, cy - plateGap / 2); ctx.lineTo(cx + plateW / 2, cy - plateGap / 2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx - plateW / 2, cy + plateGap / 2); ctx.lineTo(cx + plateW / 2, cy + plateGap / 2); ctx.stroke();

            ctx.fillStyle = '#fff';
            ctx.font = '12px monospace';
            ctx.fillText("CAPACITOR", cx - 35, cy + plateGap + 20);

            // Energy glow
            if (v > 0.1 && !simState.fuseBlown) {
                const alpha = Math.min(v / 10, 0.8);
                const grad = ctx.createLinearGradient(0, cy - plateGap / 2, 0, cy + plateGap / 2);
                grad.addColorStop(0, `rgba(0, 210, 211, 0)`);
                grad.addColorStop(0.5, `rgba(0, 210, 211, ${alpha})`);
                grad.addColorStop(1, `rgba(0, 210, 211, 0)`);
                ctx.fillStyle = grad;
                ctx.fillRect(cx - plateW / 2, cy - plateGap / 2, plateW, plateGap);
            }

            // 2. WIRES (Loop)
            ctx.strokeStyle = simState.fuseBlown ? '#333' : '#444';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(cx, cy - plateGap / 2);
            ctx.lineTo(cx, cy - 120);
            ctx.lineTo(fuseX + 60, cy - 120);
            ctx.lineTo(fuseX + 60, fuseY);
            ctx.moveTo(cx, cy + plateGap / 2);
            ctx.lineTo(cx, cy + 120);
            ctx.lineTo(fuseX + 60, cy + 120);
            ctx.lineTo(fuseX + 60, fuseY + 40);
            ctx.stroke();

            // 3. FUSE
            ctx.strokeStyle = simState.fuseBlown ? '#222' : '#e74c3c';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(fuseX, fuseY);
            ctx.lineTo(fuseX + 120, fuseY);
            ctx.stroke();

            if (!simState.fuseBlown) {
                ctx.fillStyle = '#e74c3c';
                ctx.font = 'bold 14px monospace';
                ctx.fillText("FUSE", fuseX + 30, fuseY - 15);
            } else {
                ctx.fillStyle = '#aaa';
                ctx.font = 'bold 14px monospace';
                ctx.fillText("BLOWN", fuseX + 30, fuseY - 15);
            }

            // Spark when blowing
            if (simState.sparkAlpha > 0) {
                ctx.globalAlpha = simState.sparkAlpha;
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 4;
                for (let i = 0; i < 8; i++) {
                    const ang = Math.PI * 2 * i / 8;
                    const len = 20 + Math.random() * 20;
                    ctx.beginPath();
                    ctx.moveTo(fuseX + 60, fuseY);
                    ctx.lineTo(fuseX + 60 + Math.cos(ang) * len, fuseY + Math.sin(ang) * len);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }

            // 4. LOAD (Resistor symbol)
            const loadX = fuseX + 60;
            const loadY = fuseY + 20;
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(loadX - 30, loadY - 20);
            ctx.lineTo(loadX - 10, loadY - 20);
            ctx.lineTo(loadX - 5, loadY - 10);
            ctx.lineTo(loadX + 5, loadY + 10);
            ctx.lineTo(loadX + 10, loadY + 20);
            ctx.lineTo(loadX + 30, loadY + 20);
            ctx.stroke();

            ctx.fillStyle = '#fff';
            ctx.fillText("LOAD (R)", loadX - 20, loadY + 50);

            // Current arrow
            if (simState.isDischarging && !simState.fuseBlown) {
                const i = v / simState.resistance;
                ctx.strokeStyle = '#ff9f43';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx + 100, cy);
                ctx.lineTo(cx + 100, cy - 100);
                ctx.stroke();

                ctx.fillStyle = '#ff9f43';
                ctx.font = 'bold 16px monospace';
                ctx.fillText(`I = ${i.toFixed(1)} A`, cx + 120, cy - 80);
            }
        }

        function drawGraph(v) {
            const gx = canvas.width * 0.65;
            const gy = canvas.height * 0.6;
            const gW = 220;
            const gH = 180;

            // Axes
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(gx, gy + 20); ctx.lineTo(gx, gy - gH); ctx.lineTo(gx + gW, gy - gH);
            ctx.stroke();

            ctx.fillStyle = '#888';
            ctx.font = '12px monospace';
            ctx.fillText("Time ", gx + gW + 10, gy - gH + 10);
            ctx.fillText("Voltage (V)", gx - 70, gy - gH - 10);

            // Exponential decay curve
            const tau = simState.resistance * simState.capacitance;
            const points = 50;
            ctx.strokeStyle = '#00d2d3';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i <= points; i++) {
                const t = (i / points) * 5 * tau;
                const vt = simState.isDischarging ? 10 * Math.exp(-t / tau) : 10;
                const x = gx + (t / (5 * tau)) * gW;
                const y = gy - gH + (vt / 10) * gH;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Current point
            ctx.fillStyle = '#ff9f43';
            ctx.beginPath();
            ctx.arc(gx + (simState.time / (5 * tau)) * gW, gy - gH + (v / 10) * gH, 6, 0, Math.PI * 2);
            ctx.fill();
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (simState.isDischarging && !simState.fuseBlown) {
                const tau = simState.resistance * simState.capacitance;
                simState.voltage = 10 * Math.exp(-simState.time / tau);
                simState.time += 0.05;

                const current = simState.voltage / simState.resistance;
                if (current > simState.fuseRating) {
                    simState.fuseBlown = true;
                    simState.isDischarging = false;
                    simState.sparkAlpha = 1.0;
                    simState.flashAlpha = 0.6;
                }

                if (simState.voltage < 0.01) {
                    simState.voltage = 0;
                    simState.isDischarging = false;
                }
            }

            drawCircuit(simState.voltage);
            drawGraph(simState.voltage);

            // Flash & spark fade
            if (simState.flashAlpha > 0) {
                ctx.fillStyle = `rgba(255,255,255,${simState.flashAlpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                simState.flashAlpha -= 0.03;
            }
            if (simState.sparkAlpha > 0) {
                simState.sparkAlpha -= 0.04;
            }

            requestAnimationFrame(render);
        }

        const steps = [
            {
                title: "Stored Energy",
                content: `<div class="chapter-marker">Setup</div><h2>Charged Capacitor</h2><p>A capacitor charged to 10 V stores energy $ U = \\frac{1}{2} C V^2 $.</p><p>When we close the switch, it will discharge through the load resistor.</p><p>The voltage decays exponentially: $$ V(t) = V_0 e^{-t / \\tau} $$ where $\\tau = RC$.</p>`,
                controls: `<div class="control-header"><span>Initial Voltage</span><span class="control-val">10.0 V</span></div>`,
                onEnter: () => { resetSim(); simState.voltage = 10; }
            },
            {
                title: "Normal Discharge",
                content: `<div class="chapter-marker">Safe Case</div><h2>Gentle Release</h2><p>With a moderate load resistance, current stays low.</p><p>The fuse (rated 5 A) remains intact.</p><button class="btn-action" onclick="startDischarge()">DISCHARGE SAFELY</button>`,
                controls: `<div class="control-header"><span>Load Resistance</span><span id="val-r" class="control-val">10 立</span></div><input type="range" min="5" max="50" value="10" step="1" oninput="updateR(this.value)">`,
                onEnter: () => { simState.resistance = 10; updateR(10); }
            },
            {
                title: "Peak Current",
                content: `<div class="chapter-marker">Danger</div><h2>Instantaneous Current</h2><p>At t=0, the capacitor acts like a short circuit. Initial current is $$ I_0 = \\frac{V_0}{R} $$</p><p>If R is very small, I can be huge  hundreds or thousands of amps!</p>`,
                controls: `<div class="control-header"><span>Load Resistance</span><span id="val-r" class="control-val">1 立</span></div><input type="range" min="0.1" max="10" value="1" step="0.1" oninput="updateR(this.value)">`,
                onEnter: () => { simState.resistance = 1; updateR(1); }
            },
            {
                title: "Conclusion",
                content: `<div class="chapter-marker">Protection</div><h2>The Fuse Blows</h2><p>A fuse is a thin wire that melts when current exceeds its rating.</p><p>It breaks the circuit instantly, protecting equipment and preventing fire.</p><button class="btn-action" onclick="startDischarge()">DISCHARGE (FUSE SAVES)</button>`,
                controls: `<div class="control-header"><span>Fuse Rating</span><span class="control-val">5 A</span></div><div class="control-header"><span>Peak Current</span><span id="val-i" class="control-val">10.0 A</span></div>`,
                onEnter: () => {
                    simState.resistance = 1;
                    updateR(1);
                    document.getElementById('btn-next').innerText = "Next Lesson";
                    document.getElementById('btn-next').disabled = false;
                }
            }
        ];

        let currentStep = 0;

        function loadStep(idx) {
            currentStep = idx;
            const s = steps[idx];
            const area = document.getElementById('content-area');
            area.innerHTML = s.content;
            renderMathInElement(area, { delimiters: [{ left: "$$", right: "$$", display: true }, { left: "$", right: "$", display: false }] });
            document.getElementById('dynamic-controls').innerHTML = s.controls || '';
            document.querySelector('.btn-back').disabled = idx === 0;

            const btn = document.getElementById('btn-next');
            if (currentStep === steps.length - 1) {
                btn.innerHTML = "Next Lesson";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next";
                btn.disabled = false;
            }

            if (s.onEnter) s.onEnter();
        }

        function resetSim() {
            simState.voltage = 10;
            simState.isDischarging = false;
            simState.fuseBlown = false;
            simState.time = 0;
            simState.flashAlpha = 0;
            simState.sparkAlpha = 0;
        }

        window.updateR = (val) => {
            simState.resistance = parseFloat(val);
            const peakI = 10 / simState.resistance;
            document.getElementById('val-r').innerText = simState.resistance.toFixed(1) + " 立";
            const iEl = document.getElementById('val-i');
            if (iEl) iEl.innerText = peakI.toFixed(1) + " A";
        };

        window.startDischarge = () => {
            if (!simState.isDischarging && !simState.fuseBlown) {
                simState.isDischarging = true;
                simState.time = 0;
            }
        };

        window.nextStep = () => {
            if (currentStep < steps.length - 1) {
                loadStep(currentStep + 1);
            } else {
                window.top.location.href = '/theapplefalls/lesson/1_polarization_in_insulators';
            }
        };

        window.prevStep = () => {
            if (currentStep > 0) loadStep(currentStep - 1);
        };

        window.addEventListener('load', () => {
            loadStep(0);
            render();
        });
    </script>
</body>

</html>
<!-- END: t.html -->