<!-- START OF FILE test.html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Franklin's Fluid Theory</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        /* HEADER */
        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        /* STORY CONTENT */
        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .highlight {
            color: var(--accent);
        }

        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        /* PULSE ANIMATION */
        @keyframes pulse-orange {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 159, 67, 0.7);
                transform: scale(1);
            }

            70% {
                box-shadow: 0 0 0 8px rgba(255, 159, 67, 0);
                transform: scale(1.02);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(255, 159, 67, 0);
                transform: scale(1);
            }
        }

        /* Applied to buttons or inputs */
        .pulse {
            animation: pulse-orange 2s infinite;
        }

        /* Specific fix for buttons to remove conflicting background styles when pulsing */
        button.pulse {
            border-color: var(--accent);
            color: #fff;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
        }

        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        /* NEXT BUTTON STYLING FIX */
        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            border: none;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
            transform: none;
            animation: none;
        }

        /* MAIN CANVAS */
        main {
            flex: 1;
            position: relative;
            background: #151515;
            overflow: hidden;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #333;
            padding: 15px;
            border-radius: 5px;
            pointer-events: none;
            font-family: 'Courier New', monospace;
            opacity: 0;
            transition: opacity 1s;
            user-select: none;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            width: 160px;
            margin-bottom: 5px;
        }

        .hud-val {
            font-weight: bold;
            color: #fff;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Franklin's Lab</h1>
            <div class="subtitle">Chapter 1: The Invisible Fluid</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- Material Selectors -->
            <div class="control-row" id="ctrl-materials">
                <label>1. Select Material & Tool</label>
                <div style="display:flex; gap:10px;">
                    <button id="btn-glass" onclick="uiSetMaterial('glass')">Glass & Silk</button>
                    <button id="btn-rubber" onclick="uiSetMaterial('rubber')">Rubber & Fur</button>
                </div>
            </div>

            <!-- Action Button -->
            <div class="control-row" id="ctrl-action">
                <label>2. Action</label>
                <button id="btn-rub" onclick="uiRubRod()">Generate Friction</button>
            </div>

            <!-- Slider -->
            <div class="control-row" id="ctrl-move">
                <label>3. Move Rod</label>
                <input type="range" id="slider-dist" min="0" max="100" value="0" step="1">
            </div>

            <!-- Reset -->
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #333; padding-top:10px;">
                <label>Tools</label>
                <button onclick="groundObject('rod'); groundObject('ball')">Ground (Discharge) All</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next Chapter &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <!-- HUD Removed as per user request -->
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const state = {
            mat: 'glass',
            rodCharge: 0,
            ballCharge: 0,
            rodPosition: 0, // 0 to 100
            isAnimating: false
        };

        const colors = {
            glass: 0x74b9ff, // Blueish
            rubber: 0xff5252, // Reddish
            silk: 0xffffff,   // White cloth
            fur: 0x8e5434,    // Brown fur
            skin: 0xffcd94,
            coat: 0xffffff
        };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x151515);

        // Adjust camera for sidebar width
        const sidebarWidth = 420;
        const d = 14;
        const aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(20, 20, 20);
        camera.lookAt(0, 2, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('world').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- ENVIRONMENT ---
        const table = new THREE.Mesh(new THREE.BoxGeometry(25, 1, 15), new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 }));
        table.position.y = -0.5;
        table.receiveShadow = true;
        scene.add(table);
        const grid = new THREE.GridHelper(25, 25, 0x333333, 0x1a1a1a);
        grid.position.y = 0.01;
        scene.add(grid);

        // --- STAND & BALL ---
        const standGroup = new THREE.Group();
        standGroup.position.set(-5, 0, 0);
        scene.add(standGroup);
        const sBase = new THREE.Mesh(new THREE.BoxGeometry(3, 0.5, 3), new THREE.MeshStandardMaterial({ color: 0x8e5434 }));
        sBase.position.y = 0.25;
        const sPole = new THREE.Mesh(new THREE.BoxGeometry(0.4, 10, 0.4), new THREE.MeshStandardMaterial({ color: 0x8e5434 }));
        sPole.position.y = 5;
        const sArm = new THREE.Mesh(new THREE.BoxGeometry(5, 0.3, 0.3), new THREE.MeshStandardMaterial({ color: 0x8e5434 }));
        sArm.position.set(2.5, 9.8, 0);
        standGroup.add(sBase, sPole, sArm);

        // String & Ball
        const stringGroup = new THREE.Group();
        stringGroup.position.set(0, 9.6, 0);
        scene.add(stringGroup);
        const stringGeo = new THREE.CylinderGeometry(0.02, 0.02, 5, 8);
        stringGeo.translate(0, -2.5, 0);
        const string = new THREE.Mesh(stringGeo, new THREE.MeshBasicMaterial({ color: 0x888888 }));
        stringGroup.add(string);
        const ballRadius = 0.6;
        const ball = new THREE.Mesh(new THREE.IcosahedronGeometry(ballRadius, 1), new THREE.MeshStandardMaterial({ color: 0xeeeeee }));
        ball.position.y = -5;
        ball.castShadow = true;
        stringGroup.add(ball);

        // --- THE ROD ---
        const rodGroup = new THREE.Group();
        scene.add(rodGroup);
        const rodRadius = 0.4;
        const rodMesh = new THREE.Mesh(
            new THREE.CylinderGeometry(rodRadius, rodRadius, 5, 32),
            new THREE.MeshStandardMaterial({ color: colors.glass, transparent: true, opacity: 0.9 })
        );
        rodMesh.rotation.z = Math.PI / 2;
        rodMesh.castShadow = true;
        rodGroup.add(rodMesh);
        rodGroup.position.set(6, 5, 0);

        // --- THE SCIENTIST ---
        const scientist = new THREE.Group();
        scene.add(scientist);
        scientist.position.set(6, 0, 8);
        scientist.rotation.y = Math.PI;

        const matSkin = new THREE.MeshStandardMaterial({ color: colors.skin });
        const matCoat = new THREE.MeshStandardMaterial({ color: colors.coat });
        const matDark = new THREE.MeshStandardMaterial({ color: 0x333333 });

        // Body
        const legL = new THREE.Mesh(new THREE.BoxGeometry(0.7, 2.5, 0.8), matDark); legL.position.set(-0.7, 1.25, 0);
        const legR = new THREE.Mesh(new THREE.BoxGeometry(0.7, 2.5, 0.8), matDark); legR.position.set(0.7, 1.25, 0);
        scientist.add(legL, legR);
        const torso = new THREE.Mesh(new THREE.BoxGeometry(2.2, 3, 1.2), matCoat); torso.position.y = 4;
        scientist.add(torso);
        const head = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.8, 1.5), matSkin); head.position.y = 6.5;
        scientist.add(head);

        // --- ARMS ---

        // Right Arm (Holds the Cloth/Fur)
        // NOTE: In the scientist's local space (facing -Z), -1.3 X is his RIGHT side.
        const armGroup = new THREE.Group();
        armGroup.position.set(-1.3, 5, 0);
        scientist.add(armGroup);

        const arm = new THREE.Mesh(new THREE.BoxGeometry(0.6, 2.5, 0.6), matCoat);
        arm.geometry.translate(0, -1.25, 0);
        armGroup.add(arm);
        const hand = new THREE.Mesh(new THREE.BoxGeometry(0.65, 0.7, 0.65), matSkin);
        hand.position.y = -2.8;
        armGroup.add(hand);

        // Left Arm (Inactive)
        // NOTE: In the scientist's local space, 1.3 X is his LEFT side.
        const armLGroup = new THREE.Group();
        armLGroup.position.set(1.3, 5, 0);
        scientist.add(armLGroup);

        const armL = new THREE.Mesh(new THREE.BoxGeometry(0.6, 2.5, 0.6), matCoat);
        armL.geometry.translate(0, -1.25, 0);
        armLGroup.add(armL);
        const handL = new THREE.Mesh(new THREE.BoxGeometry(0.65, 0.7, 0.65), matSkin);
        handL.position.y = -2.8;
        armLGroup.add(handL);

        // --- PROPS IN RIGHT HAND ---
        // 1. Silk Cloth (White, Smooth)
        const silkGeo = new THREE.BoxGeometry(1.4, 1.4, 0.3);
        const silkMat = new THREE.MeshStandardMaterial({ color: colors.silk, roughness: 0.5 });
        const silkProp = new THREE.Mesh(silkGeo, silkMat);
        // Position adjusted to be visible in hand
        silkProp.position.set(0, -3.2, 0.2);
        silkProp.rotation.x = Math.PI / 4;
        armGroup.add(silkProp);

        // 2. Cat Fur (Brown, Rough)
        const furGeo = new THREE.BoxGeometry(1.6, 1.6, 0.5);
        const furMat = new THREE.MeshStandardMaterial({ color: colors.fur, roughness: 1.0 });
        const furProp = new THREE.Mesh(furGeo, furMat);
        // Position adjusted to be visible in hand
        furProp.position.set(0, -3.2, 0.2);
        furProp.rotation.x = Math.PI / 4;
        furProp.visible = false; // Hidden by default
        armGroup.add(furProp);

        // Particles system
        const particles = [];
        function spawnParticle(x, y, z, type) {
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const col = type === 'pos' ? colors.glass : colors.rubber;
            const mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: col }));
            mesh.position.set(x, y, z);
            scene.add(mesh);
            particles.push({ mesh: mesh, vel: new THREE.Vector3((Math.random() - 0.5) * 0.2, Math.random() * 0.2, (Math.random() - 0.5) * 0.2), life: 1.0 });
        }

        // --- GLOBAL API FUNCTIONS ---

        window.setMaterial = (m) => {
            if (state.isAnimating) return;
            state.mat = m;

            // 1. Change Rod Color
            rodMesh.material.color.setHex(m === 'glass' ? colors.glass : colors.rubber);

            // 2. Change Prop in Hand immediately
            if (m === 'glass') {
                silkProp.visible = true;
                furProp.visible = false;
            } else {
                silkProp.visible = false;
                furProp.visible = true;
            }

            // Reset charge when changing material
            state.rodCharge = 0;
            updateEmissives();
        };

        window.setRodDistance = (val) => {
            state.rodPosition = Math.max(0, Math.min(100, val));
        }

        window.rubRod = () => {
            if (state.isAnimating) return;
            let delta = 0;
            let type = '';

            // Physics Logic based on materials
            if (state.mat === 'glass') {
                // Glass loses electrons (Positive)
                delta = 30; type = 'pos';
            } else if (state.mat === 'rubber') {
                // Rubber gains electrons (Negative)
                delta = -30; type = 'neg';
            }

            state.isAnimating = true;

            const startZ = 8; const targetZ = 4;
            let startTime = null;

            function animLoop(time) {
                if (!startTime) startTime = time;
                const elapsed = time - startTime;

                if (elapsed < 500) { // Walk in
                    const t = elapsed / 500;
                    scientist.position.z = startZ - (startZ - targetZ) * t;
                    scientist.position.y = Math.abs(Math.sin(t * 10)) * 0.3;
                    armGroup.rotation.x = -Math.PI / 2 * t;
                } else if (elapsed < 1500) { // Rubbing Motion
                    scientist.position.z = targetZ; scientist.position.y = 0;
                    const rubT = (elapsed - 500) / 100;
                    armGroup.rotation.x = -Math.PI / 2 + Math.sin(rubT) * 0.3; armGroup.rotation.z = Math.cos(rubT) * 0.1;
                    if (delta !== 0 && Math.random() > 0.8) spawnParticle(6 + (Math.random() - 0.5) * 3, 5.5, 0, type);
                } else if (elapsed < 2000) { // Walk out
                    const t = (elapsed - 1500) / 500;
                    scientist.position.z = targetZ + (startZ - targetZ) * t;
                    scientist.position.y = Math.abs(Math.sin(t * 10)) * 0.3;
                    armGroup.rotation.x = -Math.PI / 2 * (1 - t);
                } else {
                    state.isAnimating = false;
                    scientist.position.z = startZ;
                    armGroup.rotation.set(0, 0, 0);
                    state.rodCharge = Math.max(-100, Math.min(100, state.rodCharge + delta));
                    updateEmissives();
                    checkAdvance();
                    return;
                }
                requestAnimationFrame(animLoop);
            }
            requestAnimationFrame(animLoop);
        };

        window.groundObject = (obj) => {
            if (state.isAnimating) return;
            let currentCharge = (obj === 'rod') ? state.rodCharge : state.ballCharge;
            if (Math.abs(currentCharge) < 2) return;

            state.isAnimating = true;
            const startZ = 8;
            const startX = 6;
            const targetX = (obj === 'rod') ? rodGroup.position.x : 0;
            const targetZ = 3;

            // Hide props when grounding with hand (optional, but looks cleaner)
            const wasSilk = silkProp.visible;
            const wasFur = furProp.visible;
            silkProp.visible = false; furProp.visible = false;

            let startTime = null;
            function groundAnim(time) {
                if (!startTime) startTime = time;
                const elapsed = time - startTime;

                if (elapsed < 600) {
                    const t = elapsed / 600;
                    scientist.position.x = startX + (targetX - startX) * t;
                    scientist.position.z = startZ - (startZ - targetZ) * t;
                    scientist.position.y = Math.abs(Math.sin(t * 12)) * 0.3;
                    scientist.lookAt(targetX, 0, 0);
                }
                else if (elapsed < 1400) {
                    scientist.position.set(targetX, 0, targetZ);
                    scientist.lookAt(targetX, 0, 0);
                    if (elapsed < 1000) {
                        const t = (elapsed - 600) / 400;
                        armGroup.rotation.x = -Math.PI / 2.5 * t;
                    } else {
                        const t = (elapsed - 1000) / 400;
                        armGroup.rotation.x = -Math.PI / 2.5 * (1 - t);
                    }
                    if (elapsed > 1000 && Math.abs(currentCharge) > 0) {
                        if (obj === 'rod') state.rodCharge = 0;
                        if (obj === 'ball') state.ballCharge = 0;
                        updateEmissives();
                        spawnParticle(targetX, 4, 0, currentCharge > 0 ? 'pos' : 'neg');
                        currentCharge = 0;
                        updateHUD();
                    }
                }
                else if (elapsed < 2000) {
                    const t = (elapsed - 1400) / 600;
                    scientist.position.x = targetX + (startX - targetX) * t;
                    scientist.position.z = targetZ + (startZ - targetZ) * t;
                    scientist.position.y = Math.abs(Math.sin(t * 12)) * 0.3;
                    scientist.rotation.set(0, Math.PI, 0);
                    armGroup.rotation.x = 0;
                }
                else {
                    state.isAnimating = false;
                    scientist.position.set(startX, 0, startZ);
                    scientist.rotation.set(0, Math.PI, 0);
                    // Restore props
                    silkProp.visible = wasSilk; furProp.visible = wasFur;
                    return;
                }
                requestAnimationFrame(groundAnim);
            }
            requestAnimationFrame(groundAnim);
        };

        function updateEmissives() {
            const r = state.rodCharge;
            const b = state.ballCharge;

            rodMesh.material.emissive.setHex(r > 0 ? colors.glass : (r < 0 ? colors.rubber : 0x000000));
            rodMesh.material.emissiveIntensity = Math.abs(r) / 100 * 0.5;

            ball.material.emissive.setHex(b > 0 ? colors.glass : (b < 0 ? colors.rubber : 0x000000));
            ball.material.emissiveIntensity = Math.abs(b) / 100 * 0.5;
        }

        // --- PHYSICS LOOP ---
        let theta = 0;
        let omega = 0;

        function animate() {
            requestAnimationFrame(animate);

            const ballX = Math.sin(theta) * 5;
            // UPDATED MAPPING: Maps 0-100% to go from x=10 down to x=1.0 (touching distance)
            const desiredRodX = 10 - (state.rodPosition / 100) * 9.0;
            // UPDATED COLLISION: Ball Radius (0.6) + Rod Radius (0.4) = 1.0
            const minRodX = ballX + 1.0;
            const clampedTargetX = Math.max(desiredRodX, minRodX);

            if (!state.isAnimating) {
                rodGroup.position.x += (clampedTargetX - rodGroup.position.x) * 0.2;
            }

            const dx = rodGroup.position.x - ballX;
            const distSq = dx * dx;
            const dist = Math.sqrt(distSq);
            let force = 0;

            // Simple Electrostatic Force Logic
            if (Math.abs(state.ballCharge) < 5 && Math.abs(state.rodCharge) > 5) {
                force = Math.abs(state.rodCharge) * 0.03 / (distSq + 0.1);
            }
            else {
                const prod = state.ballCharge * state.rodCharge;
                const mag = Math.abs(prod) * 0.02 / (distSq + 0.1);
                if (prod > 0) force = -mag;
                else force = mag;
            }

            const gravity = -0.5 * Math.sin(theta);
            omega += (gravity + force) * 0.05;
            omega *= 0.96;
            theta += omega;
            theta = Math.max(-1.2, Math.min(1.2, theta));
            stringGroup.rotation.z = theta;

            // Conduction
            // UPDATED THRESHOLD: Slightly larger than 1.0 to ensure triggering when clamped
            if (dist < 1.2) {
                if (Math.abs(state.rodCharge - state.ballCharge) > 5) {
                    spawnParticle(ballX, 4.6, 0, state.rodCharge > 0 ? 'pos' : 'neg');
                    const avg = (state.rodCharge + state.ballCharge) / 2;
                    state.rodCharge = avg;
                    state.ballCharge = avg;
                    omega -= 0.05;
                    updateEmissives();
                    checkAdvance();
                }
            }

            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.mesh.position.add(p.vel);
                p.mesh.rotation.x += 0.1; p.life -= 0.02; p.mesh.scale.setScalar(p.life);
                if (p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
            }

            renderer.render(scene, camera);
        }

        animate();


        // ==========================================
        // PART 2: THE STORY ENGINE (UPDATED)
        // ==========================================

        function uiSetMaterial(mat) {
            setMaterial(mat);
            document.getElementById('btn-glass').style.borderColor = mat === 'glass' ? '#fff' : '#444';
            document.getElementById('btn-rubber').style.borderColor = mat === 'rubber' ? '#fff' : '#444';

            // Update button text logic
            const rubBtn = document.getElementById('btn-rub');
            if (mat === 'glass') rubBtn.innerText = "Rub with Silk";
            else rubBtn.innerText = "Rub with Fur";

            if (currentChapter === 1 || currentChapter === 5) pulse('btn-rub', true);
        }

        function uiRubRod() {
            rubRod();
            pulse('btn-rub', false);
        }

        document.getElementById('slider-dist').addEventListener('input', (e) => {
            setRodDistance(parseInt(e.target.value));
            pulse('slider-dist', false);
            checkAdvance();
        });

        // --- STORY CHAPTERS (NARRATIVE UPDATED) ---
        let currentChapter = 0;

        const lessons = [
            {
                title: "Prologue: The Invisible Ocean",
                text: "Welcome to 1752. Benjamin Franklin has a bold new idea.<br><br>He believes electricity is not a creation, but a <strong>Single Invisible Fluid</strong> that exists in everythingâ€”you, me, and this glass rod.<br><br>Right now, the rod has a normal amount of fluid. It is 'Neutral'.",
                setup: () => {
                    lockAll();
                    state.rodCharge = 0; state.ballCharge = 0; state.rodPosition = 0;
                    setMaterial('glass');
                    updateEmissives();
                    document.getElementById('slider-dist').value = 0;
                },
                check: () => true
            },
            {
                title: "Step 1: The Greedy Silk",
                text: "To create a charge, we must move this fluid. <br><br>Franklin has noticed that <strong>Silk</strong> is greedy. When it touches glass, it wipes the electrical fluid away.<br><br>I have placed the Silk Cloth in his right hand. Click <strong>Rub with Silk</strong> to strip the fluid from the rod.",
                setup: () => {
                    unlock('ctrl-action');
                    pulse('btn-rub', true);
                },
                check: () => state.rodCharge > 10
            },
            {
                title: "Step 2: A 'Thirsty' Rod",
                text: "The rod has lost its fluid! Franklin calls this state <strong>Positive</strong>.<br><br>Because the rod is missing fluid, it is desperate to get it back. It pulls on everything nearby.<br><br>Slowly drag the <strong>Slider</strong> to move the rod closer to the neutral ball.",
                setup: () => {
                    unlock('ctrl-move');
                    pulse('slider-dist', true);
                    if (state.rodCharge < 10) state.rodCharge = 50;
                    updateEmissives();
                },
                check: () => state.rodPosition > 50
            },
            {
                title: "Step 3: Sharing the Deficit",
                text: "The ball is attracted because the rod is trying to pull fluid out of it.<br><br>Move the slider to <strong>100%</strong>. Let them touch.<br><br>When they touch, the rod will steal fluid from the ball, leaving the ball deficient (Positive) as well.",
                setup: () => {
                    unlock('ctrl-move');
                    pulse('slider-dist', true);
                },
                check: () => Math.abs(state.ballCharge) > 5
            },
            {
                title: "Step 4: Repulsion",
                text: "<strong>BOOM!</strong> They flew apart!<br><br>Now both objects are 'thirsty' (Positive). They both want fluid, but neither has any to give. They reject each other.<br><br>We have discovered a law: <span class='highlight'>Like charges repel.</span>",
                setup: () => {
                    unlock('ctrl-move');
                },
                check: () => true
            },
            {
                title: "Step 5: The Generous Fur",
                text: "Let us try the opposite. We have reset the experiment.<br><br>Select the <strong>Rubber Rod</strong>. Notice the scientist now holds <strong>Cat Fur</strong>.<br><br>Fur is different. It is overflowing with fluid. If you rub it against rubber, the fur <em>gives</em> fluid to the rod.",
                setup: () => {
                    state.ballCharge = 0;
                    state.rodCharge = 0;
                    state.rodPosition = 0;
                    document.getElementById('slider-dist').value = 0;
                    updateEmissives();

                    lockAll();
                    unlock('ctrl-materials');
                    unlock('ctrl-action');
                    pulse('btn-rubber', true);
                },
                check: () => state.rodCharge < -10
            },
            {
                title: "Conclusion: The Negative State",
                text: "The Rubber Rod now has <em>too much</em> fluid. Franklin calls this <strong>Negative</strong>.<br><br>If you touch the ball now, the rod will pour its excess fluid into the ball.<br><br>But where did this idea of a 'fluid' come from? To find the origin, we must travel back 2,000 years to Ancient Greece.<br><br><strong>Click Next to travel to 600 BC.</strong>",
                setup: () => {
                    unlock('ctrl-move');
                    pulse('slider-dist', true);
                },
                check: () => true
            }
        ];

        // --- NAVIGATION LOGIC ---

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];

            document.querySelector('header .subtitle').innerText = `Module 1: Chapter 1 - Step ${idx + 1} of ${lessons.length}`;
            const container = document.getElementById('chapter-content');
            container.innerHTML = `<div class="chapter-title">${l.title}</div><div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');
            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Chapter &rarr;";
            } else {
                btn.innerHTML = "Next &rarr;";
            }

            btn.disabled = !l.check();
            document.querySelectorAll('.pulse').forEach(e => e.classList.remove('pulse'));
            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                // Navigate to Thales via React route
                window.top.location.href = '/theapplefalls/lesson/scene2_thales';
            }
        }

        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }

        function checkAdvance() {
            const btn = document.getElementById('btn-next');
            if (lessons[currentChapter].check()) {
                if (btn.disabled) {
                    btn.disabled = false;
                    btn.classList.add('pulse');
                }
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }
        function pulse(id, on) {
            const el = document.getElementById(id);
            if (on) el.classList.add('pulse'); else el.classList.remove('pulse');
        }

        // Init
        loadLesson(0);

        // Window Resize
        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -d * newAspect; camera.right = d * newAspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

    </script>
</body>

</html>