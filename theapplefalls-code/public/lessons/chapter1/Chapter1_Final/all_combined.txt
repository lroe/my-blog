<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Coulomb's Torsion Balance Experiment</title>
    <!-- Using Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #0f1014;
            --panel: #181a1f;
            --text: #e0e6ed;
            --accent: #ff9f43; /* Warm Orange */
            --accent-hover: #ffb773;
            --border: #2c313a;
            --electron: #00d2d3; /* Cyan */
            --proton: #ff6b6b;    /* Red */
        }

        body { margin: 0; height: 100vh; display: flex; background: var(--bg); color: var(--text); font-family: 'Segoe UI', Roboto, Helvetica, sans-serif; overflow: hidden; }

        /* LEFT PANEL */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0,0,0,0.6);
            z-index: 10;
        }

        header { padding: 25px; border-bottom: 1px solid var(--border); background: rgba(0,0,0,0.1); }
        h1 { margin: 0; font-size: 22px; color: var(--accent); text-transform: uppercase; letter-spacing: 2px; font-weight: 700; }
        .subtitle { font-size: 13px; color: #8892b0; margin-top: 5px; font-style: italic; }

        #story-container { flex: 1; padding: 30px; overflow-y: auto; display: flex; flex-direction: column; }
        
        .chapter-title { 
            font-size: 20px; 
            font-weight: 600; 
            color: #fff; 
            margin-bottom: 15px; 
            border-left: 4px solid var(--accent); 
            padding-left: 15px; 
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .story-text { 
            line-height: 1.8; 
            font-size: 15px; 
            color: #bdc3c7; 
            margin-bottom: 20px; 
        }
        
        .story-text strong { color: #fff; font-weight: 600; }
        
        /* CONTROLS AREA */
        #controls-area { background: #131519; padding: 25px; border-top: 1px solid var(--border); }
        .control-row { margin-bottom: 20px; opacity: 0.4; pointer-events: none; transition: 0.4s; filter: grayscale(1); position: relative; }
        .control-row.active { opacity: 1; pointer-events: all; filter: grayscale(0); }
        
        label { display: flex; justify-content: space-between; font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px; font-weight: 700; }
        label span { color: var(--accent); }

        button {
            background: #2c313a; color: #aaa; border: 1px solid #3d4450;
            padding: 12px 15px; cursor: pointer; border-radius: 6px;
            font-size: 13px; transition: all 0.2s; width: 100%;
            text-transform: uppercase; font-weight: bold; letter-spacing: 0.5px;
        }
        button:hover { background: #3d4450; color: #fff; border-color: #555; }
        button:active { transform: translateY(1px); }

        input[type=range] { width: 100%; accent-color: var(--accent); cursor: pointer; height: 6px; background: #333; border-radius: 3px; }

        /* NAVIGATION FOOTER */
        #nav-footer { padding: 20px 25px; display: flex; justify-content: space-between; border-top: 1px solid var(--border); background: #111; }
        .nav-btn { width: 48%; background: #222; color: #fff; border: none; }
        .nav-btn.next { background: var(--accent); color: #151515; font-weight: 800; }
        .nav-btn.next:hover { background: var(--accent-hover); color: #000; box-shadow: 0 0 15px rgba(255, 159, 67, 0.4); }
        .nav-btn.next:disabled { background: #222; color: #555; cursor: not-allowed; opacity: 0.5; box-shadow: none; }

        /* MAIN CANVAS */
        main { flex: 1; position: relative; background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%); overflow: hidden; }
        
        .scene-tag {
            position: absolute;
            color: rgba(255,255,255,0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }

        /* DATA DISPLAY OVERLAY */
        #data-overlay {
            position: absolute;
            bottom: 20px; right: 20px;
            background: rgba(0,0,0,0.6);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--border);
            color: #aaa;
            font-family: monospace;
            font-size: 12px;
            pointer-events: none;
        }
        .data-row { display: flex; justify-content: space-between; width: 220px; margin-bottom: 5px; }
        .data-val { color: #fff; font-weight: bold; }

    </style>
</head>
<body>

    <aside>
        <header>
            <h1>Charles Coulomb</h1>
            <div class="subtitle">Deriving the Law</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- Control 1: Charge Q1 -->
            <div class="control-row" id="ctrl-q1">
                <label>Fixed Sphere Charge (Q1) <span id="val-q1">0 µC</span></label>
                <input type="range" id="slider-q1" min="-50" max="50" value="0" step="1">
            </div>

            <!-- Control 2: Charge Q2 -->
            <div class="control-row" id="ctrl-q2">
                <label>Beam Sphere Charge (Q2) <span id="val-q2">0 µC</span></label>
                <input type="range" id="slider-q2" min="-50" max="50" value="0" step="1">
            </div>
            
            <!-- Control 3: Distance -->
             <div class="control-row" id="ctrl-dist">
                <label>Probe Distance (r) <span id="val-dist">21 cm</span></label>
                <input type="range" id="slider-dist" min="21" max="40" value="21" step="0.5">
            </div>

            <!-- Reset -->
             <div class="control-row active" id="ctrl-reset" style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; filter: grayscale(0);">
                <button onclick="resetSim()">Reset Experiment</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Laboratory View</div>
        <div id="data-overlay">
            <div class="data-row"><span>Torsion Torque:</span> <span class="data-val" id="disp-torque">0.00 Nm</span></div>
            <div class="data-row" style="border-top: 1px solid #444; padding-top: 5px; margin-top:5px;"><span>Twist Angle (θ):</span> <span class="data-val" id="disp-angle" style="color: var(--accent); font-size: 14px;">0.00°</span></div>
        </div>
    </main>

<script>
    // ==========================================
    // PART 1: SIMULATION STATE & VARIABLES
    // ==========================================
    
    // CALIBRATED CONFIGURATION
    // We adjust constants so that:
    // 1. Q=20, Q=20, Dist=21 -> Angle approx 35 deg
    // 2. Q=20, Q=40, Dist=21 -> Angle approx 70 deg (Doubling)
    const config = {
        charge1: 0,      
        charge2: 0,      
        distance: 21,    
        k: 3.5,          // Adjusted for linear response
        torsionK: 50,    // Adjusted stiffness
        damping: 0.94,   
        angle: 0,        
        velocity: 0      
    };

    let currentChapter = 0;

    function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
    function unlock(id) { document.getElementById(id).classList.add('active'); }

    const lessons = [
        {
            title: "Lesson 1: The Measurement Tool",
            text: "We want to find the equation for electric force. But we cannot see force directly.<br><br>This apparatus uses a wire that resists twisting. <strong>Hooke's Law</strong> tells us that the angle of twist (θ) is directly proportional to the Force.<br><br>Therefore: <strong>If the angle doubles, the Force has doubled.</strong><br><br>Click Next to begin the derivation.",
            setup: () => {
                lockAll();
                unlock('ctrl-reset');
            },
            check: () => true
        },
        {
            title: "Lesson 2: Establishing a Baseline",
            text: "First, let's create a baseline measurement.<br><br>1. Ensure Distance is at <strong>21 cm</strong>.<br>2. Set Fixed Sphere (Q1) to <strong>+20 µC</strong>.<br>3. Set Beam Sphere (Q2) to <strong>+20 µC</strong>.<br><br>Wait for the beam to settle. The angle should appear in the <strong>30° to 40°</strong> range.",
            setup: () => {
                unlock('ctrl-q1');
                unlock('ctrl-q2');
            },
            check: () => config.charge1 === 20 && config.charge2 === 20 && config.distance === 21
        },
        {
            title: "Lesson 3: Testing Charge (q)",
            text: "Now, let's discover how Charge affects Force.<br><br>Keep the distance fixed at 21cm. <strong>Double</strong> the Beam Sphere (Q2) charge to <strong>+40 µC</strong>.<br><br>Look at the new Angle. It should now be in the <strong>65° to 75°</strong> range.<br><br>Because the angle roughly doubled when the charge doubled, we know that Force is directly proportional to Charge.",
            setup: () => {
                unlock('ctrl-q2'); 
                document.getElementById('ctrl-q1').classList.remove('active');
                document.getElementById('ctrl-dist').classList.remove('active');
            },
            check: () => config.charge2 >= 40
        },
        {
            title: "Lesson 4: Testing Distance (r)",
            text: "Now for the critical discovery. Reset charges to <strong>+40 µC</strong> and <strong>+40 µC</strong>.<br><br>Currently, Distance is 21cm. Slowly increase the distance slider to <strong>30cm or 40cm</strong>.<br><br>Observe the Angle. Does it drop linearly? No, it plummets rapidly.<br><br><em>Observation: Force drops by the square of the distance (1/r²).</em>",
            setup: () => {
                unlock('ctrl-q1');
                unlock('ctrl-q2');
                unlock('ctrl-dist');
            },
            check: () => config.distance > 30 && config.charge1 > 30 && config.charge2 > 30
        },
        {
            title: "Lesson 5: The Equation",
            text: "By combining your two observations, you have derived Coulomb's Law:<br><br>1. Force $\\propto$ $(q1 \\cdot q2)$<br>2. Force $\\propto$ $1/r^2$<br><br>Putting it together:<br><strong>F = k · (q1 · q2) / r²</strong><br><br>Click Next for the conclusion.",
            setup: () => {
                unlock('ctrl-q1');
                unlock('ctrl-q2');
                unlock('ctrl-dist');
                unlock('ctrl-reset');
            },
            check: () => true 
        },
        {
            title: "Conclusion",
            text: "<strong>Excellent work.</strong><br><br>You have successfully replicated Charles Coulomb's 1785 experiment. You observed that force increases with charge and decreases drastically with distance.<br><br>This fundamental law explains everything from the structure of the atom to the behavior of static electricity.<br><br>Feel free to continue experimenting with different values.",
            setup: () => {
                unlock('ctrl-q1');
                unlock('ctrl-q2');
                unlock('ctrl-dist');
                unlock('ctrl-reset');
            },
            check: () => false
        }
    ];

    function checkAdvance() {
        if(currentChapter >= lessons.length - 1) return;
        const btn = document.getElementById('btn-next');
        btn.disabled = !lessons[currentChapter].check();
    }

    // ==========================================
    // PART 2: THREE.JS SETUP
    // ==========================================

    const scene = new THREE.Scene();
    const sidebarWidth = 420;
    let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
    const viewSize = 45; 
    
    const camera = new THREE.OrthographicCamera(
        -viewSize * aspect / 2, viewSize * aspect / 2,
        viewSize / 2, -viewSize / 2,
        1, 1000
    );
    camera.position.set(30, 35, 30); 
    camera.lookAt(0, 5, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
    document.getElementById('world').appendChild(renderer.domElement);

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(20, 50, 20);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    scene.add(dirLight);

    // Materials
    function createTileTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#1e2126'; ctx.fillRect(0, 0, 512, 512);
        ctx.strokeStyle = '#111316'; ctx.lineWidth = 4;
        ctx.beginPath();
        for(let i=0; i<=512; i+=64) {
            ctx.moveTo(i, 0); ctx.lineTo(i, 512);
            ctx.moveTo(0, i); ctx.lineTo(512, i);
        }
        ctx.stroke();
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(10, 10);
        return tex;
    }

    const matFloor = new THREE.MeshStandardMaterial({ map: createTileTexture(), roughness: 0.8, metalness: 0.2 });
    const matBase = new THREE.MeshStandardMaterial({ color: 0x2c3e50, roughness: 0.3 });
    const matGlass = new THREE.MeshPhongMaterial({ color: 0xaec6cf, opacity: 0.1, transparent: true, shininess: 90, side: THREE.DoubleSide });
    const matMetal = new THREE.MeshStandardMaterial({ color: 0x95a5a6, roughness: 0.2, metalness: 0.8 });
    const matBeam = new THREE.MeshStandardMaterial({ color: 0xe67e22, roughness: 0.6 });
    const matWire = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const matPos = new THREE.MeshStandardMaterial({ color: 0xff6b6b, emissive: 0x550000 });
    const matNeg = new THREE.MeshStandardMaterial({ color: 0x00d2d3, emissive: 0x004444 });
    const matNeu = new THREE.MeshStandardMaterial({ color: 0x7f8c8d });

    // Scene Objects
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), matFloor);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -2;
    floor.receiveShadow = true;
    scene.add(floor);

    const baseMesh = new THREE.Mesh(new THREE.CylinderGeometry(16, 18, 2, 8), matBase);
    baseMesh.position.y = -1;
    baseMesh.receiveShadow = true;
    scene.add(baseMesh);

    // Scale
    const scaleGroup = new THREE.Group();
    const ringGeo = new THREE.RingGeometry(14, 15, 64);
    ringGeo.rotateX(-Math.PI/2);
    const ringMesh = new THREE.Mesh(ringGeo, new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.3 }));
    scaleGroup.add(ringMesh);
    for(let i=0; i<360; i+=10) {
        const tickGeo = new THREE.BoxGeometry(0.2, 0.1, 2);
        const tick = new THREE.Mesh(tickGeo, new THREE.MeshBasicMaterial({color: 0xaaaaaa}));
        tick.position.set(Math.cos(i*Math.PI/180)*14.5, 0.1, Math.sin(i*Math.PI/180)*14.5);
        tick.lookAt(0,0,0);
        scaleGroup.add(tick);
    }
    scaleGroup.position.y = 0.1;
    scene.add(scaleGroup);

    // Apparatus
    const glassCase = new THREE.Mesh(new THREE.CylinderGeometry(14, 14, 25, 32, 1, true), matGlass);
    glassCase.position.y = 12.5;
    scene.add(glassCase);
    const glassCap = new THREE.Mesh(new THREE.CylinderGeometry(14, 14, 1, 32), matBase);
    glassCap.position.y = 25.5;
    scene.add(glassCap);

    const wire = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 25), matWire);
    wire.position.y = 12.5;
    scene.add(wire);

    // Torsion Beam
    const torsionGroup = new THREE.Group();
    scene.add(torsionGroup);

    const beam = new THREE.Mesh(new THREE.BoxGeometry(20, 0.4, 0.4), matBeam);
    beam.position.y = 10;
    beam.castShadow = true;
    torsionGroup.add(beam);

    const sphereGeo = new THREE.IcosahedronGeometry(1.5, 1);
    const sphereBeam = new THREE.Mesh(sphereGeo, matNeu);
    sphereBeam.position.set(10, 10, 0); // Radius 10
    sphereBeam.castShadow = true;
    torsionGroup.add(sphereBeam);

    const sphereWeight = new THREE.Mesh(new THREE.IcosahedronGeometry(1.5, 0), matMetal);
    sphereWeight.position.set(-10, 10, 0);
    sphereWeight.castShadow = true;
    torsionGroup.add(sphereWeight);

    // Probe
    const probeGroup = new THREE.Group();
    scene.add(probeGroup);

    const sphereFixed = new THREE.Mesh(sphereGeo, matNeu);
    sphereFixed.castShadow = true;
    probeGroup.add(sphereFixed);

    const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 15), matMetal);
    handle.position.y = 8;
    probeGroup.add(handle);

    // Force Line
    const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0)]);
    const lineMat = new THREE.LineDashedMaterial({ color: 0xffffff, dashSize: 0.5, gapSize: 0.3, scale: 1 });
    const forceLine = new THREE.Line(lineGeo, lineMat);
    scene.add(forceLine);

    // ==========================================
    // PART 3: PHYSICS LOOP (UPDATED)
    // ==========================================

    function updateMaterial(mesh, charge) {
        if (Math.abs(charge) < 0.1) mesh.material = matNeu;
        else if (charge > 0) mesh.material = matPos;
        else mesh.material = matNeg;
        
        if (mesh.material.emissive) {
            const intensity = Math.min(Math.abs(charge) / 50, 1);
            mesh.material.emissiveIntensity = 0.5 + intensity;
        }
    }

    function animate() {
        requestAnimationFrame(animate);

        // 1. Move Probe
        const probeX = config.distance;
        probeGroup.position.set(probeX, 10, 5); 
        probeGroup.lookAt(0, 10, 0);

        // 2. Physics Calculation
        // NOTE: To ensure the "Double Charge = Double Angle" lesson works visibly,
        // we calculate Force based on the SLIDER distance (r), not the physical twisted distance.
        // This mimics the "Initial Force" before the beam swings away (or assumes small angle approx).
        
        let r = config.distance; 
        
        // Safety clamp for math (force doesn't go infinity)
        if(r < 1) r = 1;

        // Coulomb Force: F = k * q1 * q2 / r^2
        let force = (config.k * config.charge1 * config.charge2) / (r * r);
        
        // Torque: Force x Radius (10 units). 
        // We treat Force as always perpendicular to the arm for the sake of the lesson's linearity.
        const torqueElec = force * 10; 

        // Restoring Torque from wire (Hooke's Law): T = -k * theta
        const torqueSpring = -config.torsionK * config.angle;

        // Damping
        const torqueDamp = -config.damping * config.velocity * 50;

        const netTorque = torqueElec + torqueSpring + torqueDamp;

        config.velocity += netTorque * 0.001; 
        config.angle += config.velocity;

        // Limits
        if (config.angle > 2.5) config.angle = 2.5;
        if (config.angle < -0.5) config.angle = -0.5;

        // 3. Update Visuals
        torsionGroup.rotation.y = config.angle;
        updateMaterial(sphereFixed, config.charge1);
        updateMaterial(sphereBeam, config.charge2);

        // Visual Force Line
        const pBeam = new THREE.Vector3(); sphereBeam.getWorldPosition(pBeam);
        const pFixed = new THREE.Vector3(); sphereFixed.getWorldPosition(pFixed);
        
        if (Math.abs(force) > 0.1) {
            forceLine.visible = true;
            const pts = forceLine.geometry.attributes.position.array;
            pts[0] = pBeam.x; pts[1] = pBeam.y; pts[2] = pBeam.z;
            pts[3] = pFixed.x; pts[4] = pFixed.y; pts[5] = pFixed.z;
            forceLine.geometry.attributes.position.needsUpdate = true;
            forceLine.computeLineDistances();
        } else {
            forceLine.visible = false;
        }

        // 4. Update UI
        document.getElementById('disp-torque').innerText = Math.abs(torqueElec).toFixed(2) + " Nm";
        document.getElementById('disp-angle').innerText = (config.angle * (180/Math.PI)).toFixed(1) + "°";

        renderer.render(scene, camera);
        checkAdvance();
    }

    // ==========================================
    // PART 4: CONTROLS
    // ==========================================

    const slQ1 = document.getElementById('slider-q1');
    const slQ2 = document.getElementById('slider-q2');
    const slDist = document.getElementById('slider-dist');

    slQ1.addEventListener('input', (e) => {
        config.charge1 = parseFloat(e.target.value);
        document.getElementById('val-q1').innerText = config.charge1 + " µC";
    });
    slQ2.addEventListener('input', (e) => {
        config.charge2 = parseFloat(e.target.value);
        document.getElementById('val-q2').innerText = config.charge2 + " µC";
    });
    slDist.addEventListener('input', (e) => {
        config.distance = parseFloat(e.target.value);
        document.getElementById('val-dist').innerText = config.distance + " cm";
    });

    window.addEventListener('resize', () => {
        aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        camera.left = -viewSize * aspect / 2;
        camera.right = viewSize * aspect / 2;
        camera.top = viewSize / 2;
        camera.bottom = -viewSize / 2;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
    });

    function resetSim() {
        config.charge1 = 0;
        config.charge2 = 0;
        config.distance = 21; 
        config.angle = 0;
        config.velocity = 0;
        
        slQ1.value = 0; slQ1.dispatchEvent(new Event('input'));
        slQ2.value = 0; slQ2.dispatchEvent(new Event('input'));
        slDist.value = 21; slDist.dispatchEvent(new Event('input'));

        loadLesson(0);
    }

    function loadLesson(idx) {
        currentChapter = idx;
        const l = lessons[idx];
        document.querySelector('header .subtitle').innerText = `Step ${idx+1} of ${lessons.length}`;
        document.getElementById('chapter-content').innerHTML = 
            `<div class="chapter-title">${l.title}</div>
             <div class="story-text">${l.text}</div>`;
        
        const btn = document.getElementById('btn-next');
        
        if (currentChapter === lessons.length -1) {
            btn.innerHTML = "Experiment Complete";
        } else {
            btn.innerHTML = "Next &rarr;";
            btn.disabled = !l.check();
        }
        
        l.setup();
    }

    function nextLesson() {
        if(currentChapter < lessons.length - 1) loadLesson(currentChapter + 1);
    }
    function prevLesson() {
        if(currentChapter > 0) loadLesson(currentChapter - 1);
    }

    // Init
    loadLesson(0);
    animate();

</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Galvani: The Living Spark</title>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43; /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body { margin: 0; height: 100vh; display: flex; background: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; overflow: hidden; }

        /* LEFT PANEL */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0,0,0,0.5);
            z-index: 10;
        }

        /* HEADER */
        header { padding: 20px; border-bottom: 1px solid var(--border); background: rgba(0,0,0,0.2); }
        h1 { margin: 0; font-size: 20px; color: var(--accent); text-transform: uppercase; letter-spacing: 2px; }
        .subtitle { font-size: 12px; color: #777; margin-top: 5px; font-style: italic; }

        /* STORY CONTENT */
        #story-container { flex: 1; padding: 30px; overflow-y: auto; display: flex; flex-direction: column; }
        .chapter-title { font-size: 24px; font-weight: 300; color: #fff; margin-bottom: 20px; border-left: 4px solid var(--accent); padding-left: 15px; }
        .story-text { line-height: 1.8; font-size: 15px; color: #ccc; margin-bottom: 20px; }
        .story-text strong { color: #fff; font-weight: 600; }
        .instruction-inline { color: var(--accent); font-weight: bold; }
        
        /* CONTROLS AREA */
        #controls-area { background: #181818; padding: 20px; border-top: 1px solid var(--border); }
        .control-row { margin-bottom: 15px; opacity: 0.5; pointer-events: none; transition: 0.3s; filter: grayscale(1); }
        .control-row.active { opacity: 1; pointer-events: all; filter: grayscale(0); }
        
        label { display: block; font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }

        button {
            background: #333; color: #aaa; border: 1px solid #444;
            padding: 10px 15px; cursor: pointer; border-radius: 4px;
            font-size: 13px; transition: all 0.2s; width: 100%;
            text-transform: uppercase; font-weight: bold;
        }
        button:hover { background: #444; color: #fff; }
        button:disabled { background: #222; color: #444; cursor: default; }

        /* NAVIGATION FOOTER */
        #nav-footer { padding: 20px; display: flex; justify-content: space-between; border-top: 1px solid var(--border); background: #222; }
        .nav-btn { width: 48%; background: #333; color: #fff; border: none; }
        .nav-btn.next { background: var(--accent); color: #151515; }
        .nav-btn.next:hover { background: var(--accent-hover); color: #000; }
        .nav-btn.next:disabled { background: #333; color: #555; cursor: not-allowed; opacity: 0.5; }

        /* MAIN CANVAS */
        main { flex: 1; position: relative; background: #151515; overflow: hidden; }
    </style>
</head>
<body>

    <aside>
        <header>
            <h1>Galvani's Lab</h1>
            <div class="subtitle">Module: The Bio-Electric Spark</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- Tool Selectors -->
            <div class="control-row" id="ctrl-tools">
                <label>1. Select Material</label>
                <div style="display:flex; gap:10px;">
                    <button id="btn-copper" style="border-color: var(--accent); color:white;">Copper Probe</button>
                    <button id="btn-zinc" onclick="uiInfo()">Zinc Plate</button>
                </div>
            </div>

            <!-- Action Button -->
            <div class="control-row" id="ctrl-action">
                <label>2. Experiment</label>
                <button id="btn-action" onclick="uiAction()">Apply Probe</button>
            </div>

             <!-- Reset -->
            <div class="control-row" id="ctrl-reset" style="margin-top:10px; border-top:1px solid #333; padding-top:10px;">
                <label>System</label>
                <button onclick="resetScene()">Reset Lab</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <!-- Canvas renders here -->
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE (GALVANI LAB)
        // ==========================================
        
        const state = {
            animState: 'IDLE', // IDLE, MOVE_IN, SHOCK, MOVE_OUT
            timer: 0,
            twitchIntensity: 0,
            hasShocked: false
        };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x151515);

        // Adjust camera for sidebar width
        const sidebarWidth = 420;
        const d = 12; // Zoom level
        const aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        
        // Isometric View 
        camera.position.set(20, 20, 20); 
        camera.lookAt(0, 2, 0); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('world').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- MATERIALS ---
        const mats = {
            skin: new THREE.MeshStandardMaterial({ color: 0xffccaa }), 
            coat: new THREE.MeshStandardMaterial({ color: 0x34495e }), 
            pants: new THREE.MeshStandardMaterial({ color: 0x5e3449 }), 
            wig: new THREE.MeshStandardMaterial({ color: 0xecf0f1 }),   
            wood: new THREE.MeshStandardMaterial({ color: 0x8B4513 }),
            metal: new THREE.MeshStandardMaterial({ color: 0xbdc3c7, metalness: 0.6, roughness: 0.3 }),
            frogGreen: new THREE.MeshStandardMaterial({ color: 0x2ecc71 }),
            floor: new THREE.MeshStandardMaterial({ color: 0x222222 })
        };

        // --- HELPER: VOXEL BUILDER ---
        function createBox(material, w, h, d, x, y, z, parent) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mesh = new THREE.Mesh(geo, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            if (parent) parent.add(mesh);
            else scene.add(mesh);
            return mesh;
        }

        // --- SCENE OBJECTS ---
        
        // 1. Floor
        createBox(mats.floor, 100, 1, 100, 0, -0.5, 0);

        // 2. Table
        const tableGroup = new THREE.Group();
        createBox(mats.wood, 8, 0.5, 5, 0, 3, 0, tableGroup); 
        // Legs
        const legH = 3; const legY = 1.5;
        createBox(mats.wood, 0.5, legH, 0.5, -3.5, legY, -2, tableGroup);
        createBox(mats.wood, 0.5, legH, 0.5, 3.5, legY, -2, tableGroup);
        createBox(mats.wood, 0.5, legH, 0.5, -3.5, legY, 2, tableGroup);
        createBox(mats.wood, 0.5, legH, 0.5, 3.5, legY, 2, tableGroup);
        scene.add(tableGroup);

        // 3. Luigi Galvani
        const luigiGroup = new THREE.Group();
        luigiGroup.position.set(-0.5, 0.5, -5.9);
        luigiGroup.rotation.y = 0.56; 
        scene.add(luigiGroup);

        // Legs
        createBox(mats.pants, 1, 3, 1.1, -0.7, 1.8, 0, luigiGroup);      
        createBox(mats.pants, 1, 3, 1.1, 0.7, 1.8, 0, luigiGroup);       
        // Body
        createBox(mats.coat, 2.8, 3.2, 1.6, 0, 4.8, 0, luigiGroup); 
        // Head
        const headGroup = new THREE.Group();
        headGroup.position.set(0, 6.4, 0);
        luigiGroup.add(headGroup);
        createBox(mats.skin, 1.6, 1.8, 1.6, 0, 0.9, 0, headGroup); 
        // Wig
        createBox(mats.wig, 2.0, 1.0, 2.0, 0, 1.8, -0.1, headGroup); 
        createBox(mats.wig, 0.6, 1.5, 2.0, -0.9, 0.8, 0.1, headGroup); 
        createBox(mats.wig, 0.6, 1.5, 2.0, 0.9, 0.8, 0.1, headGroup);  

        // Right Arm (Active Pivot)
        const armPivot = new THREE.Group();
        armPivot.position.set(-1.6, 6.0, 0); // Shoulder
        luigiGroup.add(armPivot);
        const armMesh = new THREE.Group();
        armMesh.position.set(0, -1.2, 0); 
        armPivot.add(armMesh);
        createBox(mats.coat, 0.9, 2.8, 0.9, 0, 0, 0, armMesh); 
        createBox(mats.skin, 0.8, 0.8, 0.8, 0, -1.8, 0, armMesh); // Hand
        // The Probe
        const probe = createBox(mats.metal, 0.15, 4.5, 0.15, 0, -3.0, 0.6, armMesh);
        probe.rotation.x = Math.PI / 2 + 0.2; 

        // 4. The Frog
        const frogGroup = new THREE.Group();
        frogGroup.position.set(-0.1, 3.6, -1.5);
        frogGroup.rotation.y = -1.84;
        scene.add(frogGroup);
        createBox(mats.frogGreen, 1.5, 0.4, 2, 0, 0, 0, frogGroup); // Body
        
        const legL = new THREE.Group(); legL.position.set(-0.8, 0, 0.8); frogGroup.add(legL);
        createBox(mats.frogGreen, 0.4, 0.3, 1.2, -0.2, 0, 0.4, legL).rotation.y = -0.5;

        const legR = new THREE.Group(); legR.position.set(0.8, 0, 0.8); frogGroup.add(legR);
        createBox(mats.frogGreen, 0.4, 0.3, 1.2, 0.2, 0, 0.4, legR).rotation.y = 0.5;

        // 5. Spark Effect
        const sparkGeo = new THREE.SphereGeometry(0.3, 8, 8);
        const sparkMat = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
        const spark = new THREE.Mesh(sparkGeo, sparkMat);
        spark.position.set(0, 3.8, 0);
        spark.visible = false;
        scene.add(spark);
        const sparkLight = new THREE.PointLight(0xffff00, 0, 5);
        sparkLight.position.set(0, 4, 0);
        scene.add(sparkLight);

        // --- ANIMATION CONFIG ---
        const poseIdle = { x: 0, y: -0.2, z: 0.3 };
        const poseTouch = { x: -0.5, y: -0.8, z: -0.3 }; 
        armPivot.rotation.set(poseIdle.x, poseIdle.y, poseIdle.z);

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. Luigi Idle
            if(state.animState === 'IDLE') {
                luigiGroup.position.y = 0.5 + Math.sin(time * 0.5) * 0.02;
                armPivot.rotation.z = poseIdle.z + Math.sin(time) * 0.02;
                armPivot.rotation.x = poseIdle.x; 
            }

            // 2. Action Sequence
            if(state.animState === 'MOVE_IN') {
                armPivot.rotation.x = THREE.MathUtils.lerp(armPivot.rotation.x, poseTouch.x, 5 * delta);
                armPivot.rotation.y = THREE.MathUtils.lerp(armPivot.rotation.y, poseTouch.y, 5 * delta);
                armPivot.rotation.z = THREE.MathUtils.lerp(armPivot.rotation.z, poseTouch.z, 5 * delta);

                if(Math.abs(armPivot.rotation.y - poseTouch.y) < 0.05) {
                    state.animState = 'SHOCK';
                    state.timer = 0;
                    state.hasShocked = true;
                    // FIX: Ensure UI knows we have shocked
                    checkAdvance();
                }
            } 
            else if (state.animState === 'SHOCK') {
                state.timer += delta;
                
                // Spark Visuals
                spark.visible = true;
                spark.rotation.y += 10 * delta;
                spark.scale.setScalar(1 + Math.sin(time * 20)*0.5);
                sparkLight.intensity = 2 + Math.random() * 2;

                // Frog Twitching
                state.twitchIntensity = 100;
                const twitch = Math.sin(time * 50) * 0.8;
                legL.rotation.z = twitch;
                legR.rotation.z = -twitch;
                frogGroup.position.y = 3.6 + Math.abs(Math.sin(time * 50)) * 0.1; 

                if(state.timer > 1.5) { 
                    state.animState = 'MOVE_OUT';
                    // Reset Frog
                    spark.visible = false;
                    sparkLight.intensity = 0;
                    legL.rotation.z = 0;
                    legR.rotation.z = 0;
                    frogGroup.position.y = 3.6;
                    state.twitchIntensity = 0;
                }
            }
            else if (state.animState === 'MOVE_OUT') {
                armPivot.rotation.x = THREE.MathUtils.lerp(armPivot.rotation.x, poseIdle.x, 3 * delta);
                armPivot.rotation.y = THREE.MathUtils.lerp(armPivot.rotation.y, poseIdle.y, 3 * delta);
                armPivot.rotation.z = THREE.MathUtils.lerp(armPivot.rotation.z, poseIdle.z, 3 * delta);

                if(Math.abs(armPivot.rotation.y - poseIdle.y) < 0.05) {
                    state.animState = 'IDLE';
                    document.getElementById('btn-action').disabled = false;
                    document.getElementById('btn-action').innerText = "Apply Probe Again";
                    // Ensure check runs again when idle
                    checkAdvance(); 
                }
            }

            renderer.render(scene, camera);
        }

        animate();


        // ==========================================
        // PART 2: THE STORY ENGINE (UI)
        // ==========================================

        window.uiInfo = () => {
             alert("For this demonstration, the standard Copper probe is sufficient. Galvani realized it was the *contact* that mattered.");
        };

        window.uiAction = () => {
            if(state.animState === 'IDLE') {
                state.animState = 'MOVE_IN';
                document.getElementById('btn-action').disabled = true;
                document.getElementById('btn-action').innerText = "Observing...";
                // FIX: Immediately check button state on click
                checkAdvance(); 
            }
        };

        window.resetScene = () => {
            state.animState = 'IDLE';
            state.hasShocked = false;
            loadLesson(0);
        }

        // --- STORY CHAPTERS ---
        let currentChapter = 0;

        const lessons = [
            {
                title: "Prologue: The Laboratory",
                text: "1780. Bologna, Italy.<br><br>Luigi Galvani stands before his workbench. He has been studying the effects of electricity on biological tissue using common frogs.<br><br>He wonders: Is electricity a fluid in the air, or does it exist <em>within</em> living things?",
                setup: () => {
                    lockAll();
                    state.hasShocked = false;
                    document.getElementById('btn-action').innerText = "Prepare Probe";
                },
                check: () => true 
            },
            {
                title: "Step 1: The Connection",
                text: "The frog's legs are severed, but the crural nerves are exposed. Galvani holds a charged metal probe.<br><br>To begin the experiment, <span class='instruction-inline'>Click 'APPLY PROBE'</span> to complete the circuit.",
                setup: () => {
                    unlock('ctrl-action');
                    document.getElementById('btn-action').innerText = "Apply Probe";
                },
                // FIX: Valid if animating OR if it has already shocked. 
                // This prevents the button from disabling if the user waits too long.
                check: () => state.animState !== 'IDLE' || state.hasShocked
            },
            {
                title: "Step 2: Animal Electricity",
                text: "Watch closely.<br><br>As the metal touches the nerve, a circuit is completed. Violent muscle contractions occur! The dead legs kick as if alive!<br><br>Galvani calls this <strong>'Animal Electricity'</strong>.",
                setup: () => {
                    // Logic handled in animate loop
                },
                check: () => state.hasShocked
            },
            {
                title: "Conclusion: The Atomic Shift",
                text: "Galvani believed the electricity came from the frog. However, Alessandro Volta later proved it was the interaction between <strong>Dissimilar Metals</strong> (Copper and Zinc) acting on the wet tissue.<br><br>This wasn't just biology—it was <strong>Electron Flow</strong>.<br><br>Let us now leave the biological world and zoom into the atomic level to see how electrons actually move in metals.",
                setup: () => {
                   document.getElementById('btn-action').innerText = "Experiment Complete";
                   lockAll();
                   document.getElementById('btn-next').innerText = "Start Induction Module";
                },
                check: () => true
            }
        ];

        // --- NAVIGATION LOGIC ---

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            
            document.querySelector('header .subtitle').innerText = `Scene 1: Chapter ${idx + 1}`;
            const container = document.getElementById('chapter-content');
            container.innerHTML = `<div class="chapter-title">${l.title}</div><div class="story-text">${l.text}</div>`;
            
            // Auto check if button should be enabled
            const nextBtn = document.getElementById('btn-next');
            
            // Reset button text standard
            if(idx !== lessons.length - 1) {
                nextBtn.innerText = "Next \u2192";
            }

            if(l.check()) {
                nextBtn.disabled = false;
            } else {
                nextBtn.disabled = true;
            }
            
            l.setup();
        }

        function nextLesson() {
            // Check if we are at the last lesson (Conclusion)
            if (currentChapter === lessons.length - 1) {
                // Navigate to the next HTML page
                window.location.href = '#'; 
                alert("Navigation: Moving to Induction Module...");
            } else {
                if(currentChapter < lessons.length - 1) loadLesson(currentChapter + 1);
            }
        }
        
        function prevLesson() {
            if(currentChapter > 0) loadLesson(currentChapter - 1);
        }

        function checkAdvance() {
            const btn = document.getElementById('btn-next');
            // Re-evaluate the check logic for the current lesson
            if(lessons[currentChapter].check()) {
                btn.disabled = false;
            } else {
                // Optional: Disable it back if logic dictates (usually we only want to enable)
                // btn.disabled = true;
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        // Init
        loadLesson(0);

        // Window Resize
        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -d * newAspect; camera.right = d * newAspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Thales: The First Spark</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43; /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body { margin: 0; height: 100vh; display: flex; background: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; overflow: hidden; }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0,0,0,0.5);
            z-index: 10;
        }

        /* HEADER */
        header { padding: 20px; border-bottom: 1px solid var(--border); background: rgba(0,0,0,0.2); }
        h1 { margin: 0; font-size: 20px; color: var(--accent); text-transform: uppercase; letter-spacing: 2px; }
        .subtitle { font-size: 12px; color: #777; margin-top: 5px; font-style: italic; }

        /* STORY CONTENT */
        #story-container { flex: 1; padding: 30px; overflow-y: auto; display: flex; flex-direction: column; }
        .chapter-title { font-size: 24px; font-weight: 300; color: #fff; margin-bottom: 20px; border-left: 4px solid var(--accent); padding-left: 15px; }
        .story-text { line-height: 1.8; font-size: 15px; color: #ccc; margin-bottom: 20px; }
        .story-text strong { color: #fff; font-weight: 600; }
        .highlight { color: var(--accent); }

        /* CONTROLS AREA */
        #controls-area { background: #181818; padding: 20px; border-top: 1px solid var(--border); }
        .control-row { margin-bottom: 15px; opacity: 0.5; pointer-events: none; transition: 0.3s; filter: grayscale(1); }
        .control-row.active { opacity: 1; pointer-events: all; filter: grayscale(0); }
        
        label { display: block; font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }

        button {
            background: #333; color: #aaa; border: 1px solid #444;
            padding: 10px 15px; cursor: pointer; border-radius: 4px;
            font-size: 13px; transition: all 0.2s; width: 100%;
            text-transform: uppercase; font-weight: bold;
        }
        button:hover { background: #444; color: #fff; }

        /* PULSE ANIMATION */
        @keyframes pulse-orange {
            0% { box-shadow: 0 0 0 0 rgba(255, 159, 67, 0.7); transform: scale(1); }
            70% { box-shadow: 0 0 0 8px rgba(255, 159, 67, 0); transform: scale(1.02); }
            100% { box-shadow: 0 0 0 0 rgba(255, 159, 67, 0); transform: scale(1); }
        }
        .pulse { animation: pulse-orange 2s infinite; }
        button.pulse { border-color: var(--accent); color: #fff; }

        /* NAVIGATION FOOTER */
        #nav-footer { padding: 20px; display: flex; justify-content: space-between; border-top: 1px solid var(--border); background: #222; }
        .nav-btn { width: 48%; background: #333; color: #fff; border: none; }
        .nav-btn.next { background: var(--accent); color: #151515; }
        .nav-btn.next:hover { background: var(--accent-hover); color: #000; }
        .nav-btn.next:disabled { background: #333; color: #555; cursor: not-allowed; opacity: 0.5; box-shadow: none; transform: none; animation: none; }

        /* MAIN CANVAS */
        main { flex: 1; position: relative; background: #151515; overflow: hidden; }
        
        /* HUD */
        #hud {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0,0,0,0.8); border: 1px solid #333;
            padding: 15px; border-radius: 5px; pointer-events: none;
            font-family: 'Courier New', monospace;
            opacity: 0; transition: opacity 1s; user-select: none;
        }
        .hud-row { display: flex; justify-content: space-between; width: 160px; margin-bottom: 5px; }
        .hud-val { font-weight: bold; color: #fff; }

    </style>
</head>
<body>

    <aside>
        <header>
            <h1>THALES</h1>
            <div class="subtitle">Scene 1: The Amber Soul</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- Material Selectors -->
            <div class="control-row" id="ctrl-materials">
                <label>1. Select Material</label>
                <div style="display:flex; gap:10px;">
                    <button id="btn-glass" onclick="uiSetMaterial('amber')">Amber & Wool</button>
                    <button id="btn-rubber" onclick="uiSetMaterial('stone')">Lodestone</button>
                </div>
            </div>

            <!-- Action Button -->
            <div class="control-row" id="ctrl-action">
                <label>2. Action</label>
                <button id="btn-rub" onclick="uiAction()">Enter Scene</button>
            </div>

            <!-- Slider Removed as requested -->
            
             <!-- Reset -->
            <div class="control-row" id="ctrl-reset" style="margin-top:10px; border-top:1px solid #333; padding-top:10px;">
                <label>Tools</label>
                <button onclick="resetScene()">Reset Scene</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next Chapter &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div id="hud">
            <div class="hud-row" style="border-bottom:1px solid #444; padding-bottom:5px; margin-bottom:10px; color:#888">AMBER PROPERTIES</div>
            <div class="hud-row"><span>Charge:</span> <span id="val-rod" class="hud-val">0</span></div>
            <div class="hud-row"><span>Attraction:</span> <span id="val-ball" class="hud-val">0</span></div>
        </div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE (THALES & AMBER)
        // ==========================================
        
        const state = {
            mode: 'amber', // 'amber' or 'stone'
            amberCharge: 0,
            thalesState: 'idle', // idle, walking, rubbing, waiting
            time: 0
        };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        scene.fog = new THREE.Fog(0x1a1a1a, 10, 50);

        // Adjust camera for sidebar width
        const sidebarWidth = 420;
        const d = 12;
        const aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        
        // Isometric View adjusted to see Thales' Face
        camera.position.set(-14, 16, -14); 
        camera.lookAt(0, 1, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('world').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffdfba, 0.8);
        dirLight.position.set(-10, 20, -5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- ENVIRONMENT OBJECTS ---
        let thalesGroup, rightArm, woolMesh, amberMesh, amberLight;
        let particles = [];
        let papers = [];

        // Floor
        const floorGroup = new THREE.Group();
        const tileGeo = new THREE.BoxGeometry(1.9, 0.2, 1.9);
        const tileMatDark = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
        const tileMatGrey = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 });
        for(let x = -5; x < 5; x++) {
            for(let z = -5; z < 5; z++) {
                const mat = (Math.abs(x + z) % 2 === 0) ? tileMatDark : tileMatGrey;
                const tile = new THREE.Mesh(tileGeo, mat);
                tile.position.set(x * 2, -0.1, z * 2);
                tile.receiveShadow = true;
                floorGroup.add(tile);
            }
        }
        scene.add(floorGroup);

        // Pedestal
        const pedestal = new THREE.Mesh(
            new THREE.CylinderGeometry(1, 1.2, 2.0, 6),
            new THREE.MeshStandardMaterial({ color: 0x5c5c5c, flatShading: true })
        );
        pedestal.position.set(0, 1.0, 0);
        pedestal.castShadow = true;
        pedestal.receiveShadow = true;
        scene.add(pedestal);

        // Amber Gem
        const amberGeo = new THREE.DodecahedronGeometry(0.6, 0);
        const amberMat = new THREE.MeshPhysicalMaterial({
            color: 0xffaa00, emissive: 0xffaa00, emissiveIntensity: 0.1,
            metalness: 0.0, roughness: 0.1, transmission: 0.6, thickness: 1.0,
            transparent: true, opacity: 0.9
        });
        amberMesh = new THREE.Mesh(amberGeo, amberMat);
        amberMesh.position.set(0, 2.3, 0);
        amberMesh.castShadow = true;
        scene.add(amberMesh);

        amberLight = new THREE.PointLight(0xffaa00, 0, 5);
        amberLight.position.set(0, 2.3, 0);
        scene.add(amberLight);

        // Particles (Straw/Feathers) on Pedestal
        const pGeo = new THREE.PlaneGeometry(0.1, 0.2);
        const pMat = new THREE.MeshBasicMaterial({ color: 0xeebb88, side: THREE.DoubleSide });
        for(let i=0; i<15; i++) {
            const p = new THREE.Mesh(pGeo, pMat);
            const angle = Math.random() * Math.PI * 2;
            const rad = Math.random() * 0.8;
            p.position.set(Math.cos(angle) * rad, 2.01, Math.sin(angle) * rad);
            p.rotation.x = Math.PI / 2;
            p.userData = { 
                origPos: p.position.clone(),
                speed: 0.02 + Math.random() * 0.03,
                offset: Math.random() * 100
            };
            scene.add(p);
            particles.push(p);
        }

        // Paper on Floor
        const paperGeo = new THREE.PlaneGeometry(0.2, 0.25);
        const paperMat = new THREE.MeshStandardMaterial({ color: 0xfdf5e6, side: THREE.DoubleSide });
        for(let i=0; i<8; i++) {
            const p = new THREE.Mesh(paperGeo, paperMat);
            const angle = Math.random() * Math.PI * 2;
            const dist = 1.5 + Math.random() * 2.0;
            p.position.set(Math.cos(angle)*dist, 0.05, Math.sin(angle)*dist);
            p.rotation.x = -Math.PI / 2;
            p.userData = {
                origPos: p.position.clone(),
                speed: 0.01 + Math.random() * 0.02,
                wobble: Math.random() * 10
            };
            scene.add(p);
            papers.push(p);
        }

        // --- THALES CHARACTER ---
        thalesGroup = new THREE.Group();
        const skinMat = new THREE.MeshStandardMaterial({ color: 0xeebb99, flatShading: true });
        const robeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, flatShading: true });
        const hairMat = new THREE.MeshStandardMaterial({ color: 0x888888, flatShading: true });
        
        // 1. Body
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.7, 2.5, 7), robeMat);
        body.position.y = 1.25; body.castShadow = true;
        thalesGroup.add(body);

        // 2. Head Group (For easier rotation/features)
        const headGroup = new THREE.Group();
        headGroup.position.y = 2.7;
        thalesGroup.add(headGroup);

        // Main Head Skull
        const headMesh = new THREE.Mesh(new THREE.IcosahedronGeometry(0.35, 1), skinMat);
        headMesh.castShadow = true;
        headGroup.add(headMesh);

        // --- FACE DETAILS ---
        
        // Eyes
        const eyeGeo = new THREE.SphereGeometry(0.06, 8, 8);
        const eyeWhiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const pupilGeo = new THREE.SphereGeometry(0.025, 8, 8);
        const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

        const leftEye = new THREE.Group();
        const leMesh = new THREE.Mesh(eyeGeo, eyeWhiteMat);
        const lePupil = new THREE.Mesh(pupilGeo, pupilMat);
        lePupil.position.z = 0.05;
        leftEye.add(leMesh, lePupil);
        leftEye.position.set(-0.12, 0.05, 0.32);
        
        const rightEye = leftEye.clone();
        rightEye.position.set(0.12, 0.05, 0.32);
        
        headGroup.add(leftEye, rightEye);

        // Nose
        const noseMesh = new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.15, 4), skinMat);
        noseMesh.rotation.x = -Math.PI/4; // Angle slightly up
        noseMesh.position.set(0, 0.0, 0.37);
        headGroup.add(noseMesh);

        // Ears
        const earGeo = new THREE.CylinderGeometry(0.06, 0.04, 0.15, 6);
        earGeo.rotateZ(Math.PI/2);
        const leftEar = new THREE.Mesh(earGeo, skinMat);
        leftEar.position.set(-0.35, 0, 0);
        const rightEar = leftEar.clone();
        rightEar.position.set(0.35, 0, 0);
        headGroup.add(leftEar, rightEar);

        // Mouth (Visible small line/box)
        const mouthMesh = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.02, 0.02), new THREE.MeshBasicMaterial({color: 0x553333}));
        mouthMesh.position.set(0, -0.12, 0.34);
        headGroup.add(mouthMesh);

        // Beard (Adjusted)
        const beard = new THREE.Mesh(new THREE.ConeGeometry(0.35, 0.5, 5), hairMat);
        beard.position.set(0, -0.3, 0.1); 
        beard.rotation.x = Math.PI;
        headGroup.add(beard);

        // 3. Arms
        rightArm = new THREE.Group();
        rightArm.position.set(0.5, 2.3, 0);
        const armMesh = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.1, 0.2), skinMat);
        armMesh.position.y = -0.55;
        rightArm.add(armMesh);
        // Wool in hand
        woolMesh = new THREE.Mesh(new THREE.DodecahedronGeometry(0.35, 0), new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 1 }));
        woolMesh.position.set(0, -1.1, 0);
        rightArm.add(woolMesh);
        thalesGroup.add(rightArm);
        const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.9, 0.2), skinMat);
        leftArm.position.set(-0.5, 1.85, 0);
        thalesGroup.add(leftArm);

        // Initial Position
        thalesGroup.position.set(-6, 0, 6);
        thalesGroup.lookAt(0, 0, 0);
        scene.add(thalesGroup);

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            state.time += delta;

            // 1. Thales Logic
            if(state.thalesState === 'walking') {
                const target = new THREE.Vector3(0.65, 0, 0.65);
                if(thalesGroup.position.distanceTo(target) > 0.1) {
                    const dir = target.clone().sub(thalesGroup.position).normalize();
                    thalesGroup.position.add(dir.multiplyScalar(3 * delta));
                    thalesGroup.lookAt(0,0,0);
                    // Bobbing
                    thalesGroup.position.y = Math.abs(Math.sin(state.time * 12)) * 0.1;
                    rightArm.rotation.x = Math.sin(state.time * 12) * 0.3;
                } else {
                    thalesGroup.position.y = 0;
                    state.thalesState = 'waiting_to_rub';
                    checkAdvance();
                }
            } else if (state.thalesState === 'rubbing') {
                 const rubAngleX = -1.4 + Math.sin(state.time * 15) * 0.15; 
                 const rubAngleZ = -0.4;
                 
                 // Arm raise transition
                 if(rightArm.rotation.x > -1.2) {
                     rightArm.rotation.x -= 3 * delta;
                     if(rightArm.rotation.z > rubAngleZ) rightArm.rotation.z -= 1 * delta;
                 } else {
                     rightArm.rotation.x = rubAngleX;
                     rightArm.rotation.z = rubAngleZ;
                     // Generate Charge
                     state.amberCharge = Math.min(100, state.amberCharge + 0.4); // Slower charge buildup
                     updateAmberVisuals();
                 }
            } else if (state.thalesState === 'finished_rubbing') {
                // Return arm to idle
                if(rightArm.rotation.x < 0) rightArm.rotation.x += 2 * delta;
                if(rightArm.rotation.z < 0) rightArm.rotation.z += 2 * delta;
            }

            // 2. Physics / Particles Logic
            // ATTRACTION IS NOW AUTOMATIC BASED ON CHARGE
            const effectivePull = (state.amberCharge / 100); 
            
            // Animate Particles
            const amberPos = new THREE.Vector3(0, 2.3, 0);
            
            [...particles, ...papers].forEach((p, i) => {
                const isPaper = papers.includes(p);
                const dist = p.position.distanceTo(amberPos);
                
                // Threshold: Only fly up if pull is strong enough (approx > 20% charge)
                // And gravity works inversely to pull
                if (effectivePull > 0.2 && dist > 0.4) {
                    // Flying UP logic
                    const dir = amberPos.clone().sub(p.position).normalize();
                    const speed = (p.userData.speed || 0.02) * (effectivePull * 5);
                    p.position.add(dir.multiplyScalar(speed));
                    p.rotation.x += 0.1;
                    p.rotation.y += 0.1;
                    
                    // Add noise
                    p.position.y += Math.sin(state.time * 10 + i) * 0.005;
                } else if (effectivePull > 0.2 && dist <= 0.4) {
                    // Stuck to Amber
                    p.position.copy(amberPos).add(new THREE.Vector3(
                        Math.sin(state.time*2 + i)*0.4,
                        Math.cos(state.time*3 + i)*0.4,
                        Math.sin(state.time + i)*0.4
                    ));
                } else {
                    // Gravity / Return to floor logic if charge drops (or is 0)
                    if(p.position.y > p.userData.origPos.y) {
                        p.position.y -= 0.05;
                        p.position.x += (p.userData.origPos.x - p.position.x) * 0.05;
                        p.position.z += (p.userData.origPos.z - p.position.z) * 0.05;
                    }
                }
            });

            renderer.render(scene, camera);
            updateHUD();
        }
        
        function updateAmberVisuals() {
            const intensity = state.amberCharge / 100;
            amberLight.intensity = intensity * 2;
            amberMesh.material.emissiveIntensity = 0.1 + (intensity * 0.9);
            
            // Check for story advance (auto check if charge is high enough)
            if(state.amberCharge > 80) checkAdvance();
        }

        animate();


        // ==========================================
        // PART 2: THE STORY ENGINE (THALES EDITION)
        // ==========================================

        function updateHUD() {
            const rVal = document.getElementById('val-rod'); // Amber Charge
            const bVal = document.getElementById('val-ball'); // Attraction Power
            
            rVal.innerText = Math.round(state.amberCharge) + "%";
            rVal.style.color = '#ffaa00';
            
            // Attraction logic for HUD
            bVal.innerText = Math.round(state.amberCharge) + "%"; 
            bVal.style.color = '#fff';
        }

        // --- GLOBAL UI FUNCTIONS ---
        
        window.uiSetMaterial = (mat) => {
            if(mat === 'stone') {
                alert("The Lodestone (Magnetite) is heavy and cold. It attracts iron, but not chaff. Let us stick to the Amber.");
                return;
            }
            // Just UI feedback
            document.getElementById('btn-glass').style.borderColor = '#fff';
            document.getElementById('btn-rubber').style.borderColor = '#444';
        };

        window.uiAction = () => {
            pulse('btn-rub', false);
            
            // Action depends on chapter
            if(currentChapter === 1) {
                // Approach
                state.thalesState = 'walking';
                document.getElementById('btn-rub').innerText = "Walking...";
                document.getElementById('btn-rub').disabled = true;
            } else if (currentChapter === 2 || currentChapter === 3) {
                // Rub
                state.thalesState = 'rubbing';
                document.getElementById('btn-rub').innerText = "Rubbing...";
            }
        };

        window.resetScene = () => {
            state.amberCharge = 0;
            state.thalesState = 'idle';
            thalesGroup.position.set(-6, 0, 6);
            rightArm.rotation.set(0,0,0);
            updateAmberVisuals();
            loadLesson(currentChapter); 
        }

        // --- STORY CHAPTERS ---
        let currentChapter = 0;

        const lessons = [
            {
                title: "Prologue: The Ancient Shore",
                text: "600 BC. Miletus. <br><br>Long before batteries or bulbs, Thales, one of the Seven Sages of Greece, walks the shores. He finds a strange, golden fossilized resin: <strong>Amber</strong>.<br><br>The Greeks call it <em>Elektron</em>.",
                setup: () => {
                    lockAll();
                    document.getElementById('hud').style.opacity = 0;
                    resetScene();
                    state.mode = 'amber';
                    document.getElementById('btn-rub').innerText = "Approach Pedestal";
                    document.getElementById('btn-glass').style.borderColor = '#fff';
                },
                check: () => true 
            },
            {
                title: "Step 1: The Experiment",
                text: "The stone sits on the pedestal, cold and dormant. It has a 'soul', Thales believes, but it sleeps.<br><br>To wake it, we must bring our philosopher closer to the specimen.<br><br>Click <strong>Approach Pedestal</strong>.",
                setup: () => {
                    document.getElementById('hud').style.opacity = 1;
                    unlock('ctrl-action');
                    pulse('btn-rub', true);
                    document.getElementById('btn-rub').innerText = "Approach Pedestal";
                    document.getElementById('btn-rub').disabled = false;
                },
                check: () => state.thalesState === 'waiting_to_rub'
            },
            {
                title: "Step 2: Friction",
                text: "Thales holds a piece of wool. He discovered that rubbing the amber vigorously creates a change.<br><br>This is not magnetism (which moves iron). This is something new.<br><br>Click and hold <strong>Rub Amber</strong> to generate the 'Electric Fluid'. Watch the Charge meter.",
                setup: () => {
                    unlock('ctrl-action');
                    document.getElementById('btn-rub').disabled = false;
                    document.getElementById('btn-rub').innerText = "Rub Amber";
                    pulse('btn-rub', true);
                },
                check: () => state.amberCharge > 40
            },
            {
                title: "Step 3: The Attraction",
                text: "Keep rubbing! As the charge increases, observe the floor.<br><br>There is no need to adjust anything else—the force of the amber acts automatically.<br><br>The light paper and straw are lifted against gravity by the invisible 'Soul' of the stone.",
                setup: () => {
                    state.thalesState = 'rubbing'; 
                    document.getElementById('btn-rub').innerText = "Rubbing...";
                    document.getElementById('btn-rub').disabled = false;
                },
                check: () => state.amberCharge > 85
            },
            {
                title: "Epilogue: The First Spark",
                text: "Incredible! The light chaff flies upward to cling to the stone.<br><br>Thales thought the amber had a soul. He was wrong about the soul, but right about the force.<br><br>He had discovered <strong>Static Electricity</strong>. It would take 2,000 years for humanity to understand it fully.",
                setup: () => {
                   state.thalesState = 'finished_rubbing';
                   document.getElementById('btn-rub').innerText = "Charged";
                },
                check: () => true
            }
        ];

        // --- NAVIGATION LOGIC ---

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            
            document.querySelector('header .subtitle').innerText = `Scene 1: Chapter ${idx}`;
            const container = document.getElementById('chapter-content');
            container.innerHTML = `<div class="chapter-title">${l.title}</div><div class="story-text">${l.text}</div>`;
            
            document.getElementById('btn-next').disabled = !l.check();
            document.querySelectorAll('.pulse').forEach(e => e.classList.remove('pulse'));
            l.setup();
        }

        function nextLesson() {
            if(currentChapter < lessons.length - 1) loadLesson(currentChapter + 1);
        }
        
        function prevLesson() {
            if(currentChapter > 0) loadLesson(currentChapter - 1);
        }

        function checkAdvance() {
            const btn = document.getElementById('btn-next');
            if(lessons[currentChapter].check()) {
                if(btn.disabled) {
                    btn.disabled = false;
                    btn.classList.add('pulse');
                }
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }
        function pulse(id, on) {
            const el = document.getElementById(id);
            if(on) el.classList.add('pulse'); else el.classList.remove('pulse');
        }

        // Init
        loadLesson(0);

        // Window Resize
        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -d * newAspect; camera.right = d * newAspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

    </script>
</body>
</html>
<!-- START OF FILE test.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Franklin's Fluid Theory</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43; /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body { margin: 0; height: 100vh; display: flex; background: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; overflow: hidden; }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0,0,0,0.5);
            z-index: 10;
        }

        /* HEADER */
        header { padding: 20px; border-bottom: 1px solid var(--border); background: rgba(0,0,0,0.2); }
        h1 { margin: 0; font-size: 20px; color: var(--accent); text-transform: uppercase; letter-spacing: 2px; }
        .subtitle { font-size: 12px; color: #777; margin-top: 5px; font-style: italic; }

        /* STORY CONTENT */
        #story-container { flex: 1; padding: 30px; overflow-y: auto; display: flex; flex-direction: column; }
        .chapter-title { font-size: 24px; font-weight: 300; color: #fff; margin-bottom: 20px; border-left: 4px solid var(--accent); padding-left: 15px; }
        .story-text { line-height: 1.8; font-size: 15px; color: #ccc; margin-bottom: 20px; }
        .story-text strong { color: #fff; font-weight: 600; }
        .highlight { color: var(--accent); }

        /* CONTROLS AREA */
        #controls-area { background: #181818; padding: 20px; border-top: 1px solid var(--border); }
        .control-row { margin-bottom: 15px; opacity: 0.5; pointer-events: none; transition: 0.3s; filter: grayscale(1); }
        .control-row.active { opacity: 1; pointer-events: all; filter: grayscale(0); }
        
        label { display: block; font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }

        button {
            background: #333; color: #aaa; border: 1px solid #444;
            padding: 10px 15px; cursor: pointer; border-radius: 4px;
            font-size: 13px; transition: all 0.2s; width: 100%;
            text-transform: uppercase; font-weight: bold;
        }
        button:hover { background: #444; color: #fff; }

        /* PULSE ANIMATION */
        @keyframes pulse-orange {
            0% { box-shadow: 0 0 0 0 rgba(255, 159, 67, 0.7); transform: scale(1); }
            70% { box-shadow: 0 0 0 8px rgba(255, 159, 67, 0); transform: scale(1.02); }
            100% { box-shadow: 0 0 0 0 rgba(255, 159, 67, 0); transform: scale(1); }
        }
        /* Applied to buttons or inputs */
        .pulse { animation: pulse-orange 2s infinite; }
        
        /* Specific fix for buttons to remove conflicting background styles when pulsing */
        button.pulse { border-color: var(--accent); color: #fff; }

        input[type=range] { width: 100%; accent-color: var(--accent); cursor: pointer; }

        /* NAVIGATION FOOTER */
        #nav-footer { padding: 20px; display: flex; justify-content: space-between; border-top: 1px solid var(--border); background: #222; }
        .nav-btn { width: 48%; background: #333; color: #fff; border: none; }
        
        /* NEXT BUTTON STYLING FIX */
        .nav-btn.next { 
            background: var(--accent); 
            color: #151515; 
            border: none;
        }
        .nav-btn.next:hover { 
            background: var(--accent-hover); 
            color: #000;
        }
        .nav-btn.next:disabled { 
            background: #333; 
            color: #555; 
            cursor: not-allowed; 
            opacity: 0.5; 
            box-shadow: none;
            transform: none;
            animation: none;
        }

        /* MAIN CANVAS */
        main { flex: 1; position: relative; background: #151515; overflow: hidden; }
        
        /* HUD */
        #hud {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0,0,0,0.8); border: 1px solid #333;
            padding: 15px; border-radius: 5px; pointer-events: none;
            font-family: 'Courier New', monospace;
            opacity: 0; transition: opacity 1s; user-select: none;
        }
        .hud-row { display: flex; justify-content: space-between; width: 160px; margin-bottom: 5px; }
        .hud-val { font-weight: bold; color: #fff; }

    </style>
</head>
<body>

    <aside>
        <header>
            <h1>Franklin's Lab</h1>
            <div class="subtitle">Chapter 1: The Invisible Fluid</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- Material Selectors -->
            <div class="control-row" id="ctrl-materials">
                <label>1. Select Material & Tool</label>
                <div style="display:flex; gap:10px;">
                    <button id="btn-glass" onclick="uiSetMaterial('glass')">Glass & Silk</button>
                    <button id="btn-rubber" onclick="uiSetMaterial('rubber')">Rubber & Fur</button>
                </div>
            </div>

            <!-- Action Button -->
            <div class="control-row" id="ctrl-action">
                <label>2. Action</label>
                <button id="btn-rub" onclick="uiRubRod()">Generate Friction</button>
            </div>

            <!-- Slider -->
            <div class="control-row" id="ctrl-move">
                <label>3. Move Rod</label>
                <input type="range" id="slider-dist" min="0" max="100" value="0" step="1">
            </div>
            
             <!-- Reset -->
            <div class="control-row" id="ctrl-reset" style="margin-top:10px; border-top:1px solid #333; padding-top:10px;">
                <label>Tools</label>
                <button onclick="groundObject('rod'); groundObject('ball')">Ground (Discharge) All</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next Chapter &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div id="hud">
            <div class="hud-row" style="border-bottom:1px solid #444; padding-bottom:5px; margin-bottom:10px; color:#888">CHARGE DETECTOR</div>
            <div class="hud-row"><span>Rod:</span> <span id="val-rod" class="hud-val">0</span></div>
            <div class="hud-row"><span>Ball:</span> <span id="val-ball" class="hud-val">0</span></div>
        </div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================
        
        const state = {
            mat: 'glass',
            rodCharge: 0,
            ballCharge: 0,
            rodPosition: 0, // 0 to 100
            isAnimating: false
        };

        const colors = {
            glass: 0x74b9ff, // Blueish
            rubber: 0xff5252, // Reddish
            silk: 0xffffff,   // White cloth
            fur: 0x8e5434,    // Brown fur
            skin: 0xffcd94,
            coat: 0xffffff
        };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x151515);

        // Adjust camera for sidebar width
        const sidebarWidth = 420;
        const d = 14;
        const aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(20, 20, 20); 
        camera.lookAt(0, 2, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('world').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- ENVIRONMENT ---
        const table = new THREE.Mesh(new THREE.BoxGeometry(25, 1, 15), new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 }));
        table.position.y = -0.5;
        table.receiveShadow = true;
        scene.add(table);
        const grid = new THREE.GridHelper(25, 25, 0x333333, 0x1a1a1a);
        grid.position.y = 0.01;
        scene.add(grid);

        // --- STAND & BALL ---
        const standGroup = new THREE.Group();
        standGroup.position.set(-5, 0, 0);
        scene.add(standGroup);
        const sBase = new THREE.Mesh(new THREE.BoxGeometry(3, 0.5, 3), new THREE.MeshStandardMaterial({color: 0x8e5434}));
        sBase.position.y = 0.25;
        const sPole = new THREE.Mesh(new THREE.BoxGeometry(0.4, 10, 0.4), new THREE.MeshStandardMaterial({color: 0x8e5434}));
        sPole.position.y = 5;
        const sArm = new THREE.Mesh(new THREE.BoxGeometry(5, 0.3, 0.3), new THREE.MeshStandardMaterial({color: 0x8e5434}));
        sArm.position.set(2.5, 9.8, 0);
        standGroup.add(sBase, sPole, sArm);

        // String & Ball
        const stringGroup = new THREE.Group();
        stringGroup.position.set(0, 9.6, 0); 
        scene.add(stringGroup);
        const stringGeo = new THREE.CylinderGeometry(0.02, 0.02, 5, 8);
        stringGeo.translate(0, -2.5, 0);
        const string = new THREE.Mesh(stringGeo, new THREE.MeshBasicMaterial({color: 0x888888}));
        stringGroup.add(string);
        const ballRadius = 0.6;
        const ball = new THREE.Mesh(new THREE.IcosahedronGeometry(ballRadius, 1), new THREE.MeshStandardMaterial({ color: 0xeeeeee }));
        ball.position.y = -5;
        ball.castShadow = true;
        stringGroup.add(ball);

        // --- THE ROD ---
        const rodGroup = new THREE.Group();
        scene.add(rodGroup);
        const rodRadius = 0.4;
        const rodMesh = new THREE.Mesh(
            new THREE.CylinderGeometry(rodRadius, rodRadius, 5, 32),
            new THREE.MeshStandardMaterial({ color: colors.glass, transparent: true, opacity: 0.9 })
        );
        rodMesh.rotation.z = Math.PI / 2;
        rodMesh.castShadow = true;
        rodGroup.add(rodMesh);
        rodGroup.position.set(6, 5, 0);

        // --- THE SCIENTIST ---
        const scientist = new THREE.Group();
        scene.add(scientist);
        scientist.position.set(6, 0, 8); 
        scientist.rotation.y = Math.PI; 

        const matSkin = new THREE.MeshStandardMaterial({ color: colors.skin });
        const matCoat = new THREE.MeshStandardMaterial({ color: colors.coat });
        const matDark = new THREE.MeshStandardMaterial({ color: 0x333333 });

        // Body
        const legL = new THREE.Mesh(new THREE.BoxGeometry(0.7, 2.5, 0.8), matDark); legL.position.set(-0.7, 1.25, 0);
        const legR = new THREE.Mesh(new THREE.BoxGeometry(0.7, 2.5, 0.8), matDark); legR.position.set(0.7, 1.25, 0);
        scientist.add(legL, legR);
        const torso = new THREE.Mesh(new THREE.BoxGeometry(2.2, 3, 1.2), matCoat); torso.position.y = 4;
        scientist.add(torso);
        const head = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.8, 1.5), matSkin); head.position.y = 6.5;
        scientist.add(head);
        
        // --- ARMS ---
        
        // Right Arm (Holds the Cloth/Fur)
        // NOTE: In the scientist's local space (facing -Z), -1.3 X is his RIGHT side.
        const armGroup = new THREE.Group(); 
        armGroup.position.set(-1.3, 5, 0); 
        scientist.add(armGroup);
        
        const arm = new THREE.Mesh(new THREE.BoxGeometry(0.6, 2.5, 0.6), matCoat); 
        arm.geometry.translate(0, -1.25, 0); 
        armGroup.add(arm);
        const hand = new THREE.Mesh(new THREE.BoxGeometry(0.65, 0.7, 0.65), matSkin); 
        hand.position.y = -2.8; 
        armGroup.add(hand);
        
        // Left Arm (Inactive)
        // NOTE: In the scientist's local space, 1.3 X is his LEFT side.
        const armLGroup = new THREE.Group(); 
        armLGroup.position.set(1.3, 5, 0); 
        scientist.add(armLGroup);
        
        const armL = new THREE.Mesh(new THREE.BoxGeometry(0.6, 2.5, 0.6), matCoat); 
        armL.geometry.translate(0, -1.25, 0); 
        armLGroup.add(armL);
        const handL = new THREE.Mesh(new THREE.BoxGeometry(0.65, 0.7, 0.65), matSkin); 
        handL.position.y = -2.8; 
        armLGroup.add(handL);

        // --- PROPS IN RIGHT HAND ---
        // 1. Silk Cloth (White, Smooth)
        const silkGeo = new THREE.BoxGeometry(1.4, 1.4, 0.3);
        const silkMat = new THREE.MeshStandardMaterial({ color: colors.silk, roughness: 0.5 });
        const silkProp = new THREE.Mesh(silkGeo, silkMat);
        // Position adjusted to be visible in hand
        silkProp.position.set(0, -3.2, 0.2); 
        silkProp.rotation.x = Math.PI / 4;
        armGroup.add(silkProp);

        // 2. Cat Fur (Brown, Rough)
        const furGeo = new THREE.BoxGeometry(1.6, 1.6, 0.5);
        const furMat = new THREE.MeshStandardMaterial({ color: colors.fur, roughness: 1.0 });
        const furProp = new THREE.Mesh(furGeo, furMat);
        // Position adjusted to be visible in hand
        furProp.position.set(0, -3.2, 0.2); 
        furProp.rotation.x = Math.PI / 4;
        furProp.visible = false; // Hidden by default
        armGroup.add(furProp);

        // Particles system
        const particles = [];
        function spawnParticle(x, y, z, type) {
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const col = type === 'pos' ? colors.glass : colors.rubber;
            const mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({color: col}));
            mesh.position.set(x, y, z);
            scene.add(mesh);
            particles.push({ mesh: mesh, vel: new THREE.Vector3((Math.random()-0.5)*0.2, Math.random()*0.2, (Math.random()-0.5)*0.2), life: 1.0 });
        }

        // --- GLOBAL API FUNCTIONS ---

        window.setMaterial = (m) => {
            if(state.isAnimating) return;
            state.mat = m;
            
            // 1. Change Rod Color
            rodMesh.material.color.setHex(m==='glass' ? colors.glass : colors.rubber);
            
            // 2. Change Prop in Hand immediately
            if(m === 'glass') {
                silkProp.visible = true;
                furProp.visible = false;
            } else {
                silkProp.visible = false;
                furProp.visible = true;
            }

            // Reset charge when changing material
            state.rodCharge = 0; 
            updateEmissives();
        };

        window.setRodDistance = (val) => {
            state.rodPosition = Math.max(0, Math.min(100, val));
        }

        window.rubRod = () => {
            if(state.isAnimating) return;
            let delta = 0;
            let type = '';

            // Physics Logic based on materials
            if(state.mat === 'glass') { 
                // Glass loses electrons (Positive)
                delta = 30; type='pos';
            } else if (state.mat === 'rubber') { 
                // Rubber gains electrons (Negative)
                delta = -30; type='neg';
            }
            
            state.isAnimating = true;

            const startZ = 8; const targetZ = 4; 
            let startTime = null;

            function animLoop(time) {
                if(!startTime) startTime = time;
                const elapsed = time - startTime;

                if(elapsed < 500) { // Walk in
                    const t = elapsed / 500;
                    scientist.position.z = startZ - (startZ - targetZ) * t;
                    scientist.position.y = Math.abs(Math.sin(t * 10)) * 0.3; 
                    armGroup.rotation.x = -Math.PI/2 * t; 
                } else if (elapsed < 1500) { // Rubbing Motion
                    scientist.position.z = targetZ; scientist.position.y = 0;
                    const rubT = (elapsed - 500) / 100; 
                    armGroup.rotation.x = -Math.PI/2 + Math.sin(rubT)*0.3; armGroup.rotation.z = Math.cos(rubT)*0.1; 
                    if(delta !== 0 && Math.random() > 0.8) spawnParticle(6 + (Math.random()-0.5)*3, 5.5, 0, type);
                } else if (elapsed < 2000) { // Walk out
                    const t = (elapsed - 1500) / 500;
                    scientist.position.z = targetZ + (startZ - targetZ) * t;
                    scientist.position.y = Math.abs(Math.sin(t * 10)) * 0.3;
                    armGroup.rotation.x = -Math.PI/2 * (1-t);
                } else {
                    state.isAnimating = false;
                    scientist.position.z = startZ;
                    armGroup.rotation.set(0,0,0);
                    state.rodCharge = Math.max(-100, Math.min(100, state.rodCharge + delta));
                    updateEmissives();
                    checkAdvance(); 
                    return;
                }
                requestAnimationFrame(animLoop);
            }
            requestAnimationFrame(animLoop);
        };

        window.groundObject = (obj) => {
            if(state.isAnimating) return;
            let currentCharge = (obj === 'rod') ? state.rodCharge : state.ballCharge;
            if(Math.abs(currentCharge) < 2) return;

            state.isAnimating = true;
            const startZ = 8;
            const startX = 6;
            const targetX = (obj === 'rod') ? rodGroup.position.x : 0; 
            const targetZ = 3; 

            // Hide props when grounding with hand (optional, but looks cleaner)
            const wasSilk = silkProp.visible;
            const wasFur = furProp.visible;
            silkProp.visible = false; furProp.visible = false;

            let startTime = null;
            function groundAnim(time) {
                if(!startTime) startTime = time;
                const elapsed = time - startTime;

                if(elapsed < 600) {
                    const t = elapsed / 600;
                    scientist.position.x = startX + (targetX - startX) * t;
                    scientist.position.z = startZ - (startZ - targetZ) * t;
                    scientist.position.y = Math.abs(Math.sin(t * 12)) * 0.3;
                    scientist.lookAt(targetX, 0, 0); 
                } 
                else if (elapsed < 1400) {
                    scientist.position.set(targetX, 0, targetZ);
                    scientist.lookAt(targetX, 0, 0); 
                    if(elapsed < 1000) {
                         const t = (elapsed - 600) / 400;
                         armGroup.rotation.x = -Math.PI/2.5 * t; 
                    } else {
                         const t = (elapsed - 1000) / 400;
                         armGroup.rotation.x = -Math.PI/2.5 * (1-t); 
                    }
                    if(elapsed > 1000 && Math.abs(currentCharge) > 0) {
                        if(obj === 'rod') state.rodCharge = 0;
                        if(obj === 'ball') state.ballCharge = 0;
                        updateEmissives();
                        spawnParticle(targetX, 4, 0, currentCharge > 0 ? 'pos' : 'neg');
                        currentCharge = 0;
                        updateHUD();
                    }
                } 
                else if (elapsed < 2000) {
                    const t = (elapsed - 1400) / 600;
                    scientist.position.x = targetX + (startX - targetX) * t;
                    scientist.position.z = targetZ + (startZ - targetZ) * t;
                    scientist.position.y = Math.abs(Math.sin(t * 12)) * 0.3;
                    scientist.rotation.set(0, Math.PI, 0); 
                    armGroup.rotation.x = 0;
                } 
                else {
                    state.isAnimating = false;
                    scientist.position.set(startX, 0, startZ);
                    scientist.rotation.set(0, Math.PI, 0);
                    // Restore props
                    silkProp.visible = wasSilk; furProp.visible = wasFur;
                    return;
                }
                requestAnimationFrame(groundAnim);
            }
            requestAnimationFrame(groundAnim);
        };

        function updateEmissives() {
            const r = state.rodCharge;
            const b = state.ballCharge;
            
            rodMesh.material.emissive.setHex(r > 0 ? colors.glass : (r < 0 ? colors.rubber : 0x000000));
            rodMesh.material.emissiveIntensity = Math.abs(r)/100 * 0.5;

            ball.material.emissive.setHex(b > 0 ? colors.glass : (b < 0 ? colors.rubber : 0x000000));
            ball.material.emissiveIntensity = Math.abs(b)/100 * 0.5;
        }

        // --- PHYSICS LOOP ---
        let theta = 0;
        let omega = 0;

        function animate() {
            requestAnimationFrame(animate);

            const ballX = Math.sin(theta) * 5;
            // UPDATED MAPPING: Maps 0-100% to go from x=10 down to x=1.0 (touching distance)
            const desiredRodX = 10 - (state.rodPosition / 100) * 9.0;
            // UPDATED COLLISION: Ball Radius (0.6) + Rod Radius (0.4) = 1.0
            const minRodX = ballX + 1.0; 
            const clampedTargetX = Math.max(desiredRodX, minRodX);
            
            if(!state.isAnimating) {
                rodGroup.position.x += (clampedTargetX - rodGroup.position.x) * 0.2;
            }

            const dx = rodGroup.position.x - ballX;
            const distSq = dx*dx; 
            const dist = Math.sqrt(distSq);
            let force = 0;

            // Simple Electrostatic Force Logic
            if(Math.abs(state.ballCharge) < 5 && Math.abs(state.rodCharge) > 5) {
                force = Math.abs(state.rodCharge) * 0.03 / (distSq + 0.1); 
            } 
            else {
                const prod = state.ballCharge * state.rodCharge;
                const mag = Math.abs(prod) * 0.02 / (distSq + 0.1);
                if(prod > 0) force = -mag; 
                else force = mag;      
            }

            const gravity = -0.5 * Math.sin(theta);
            omega += (gravity + force) * 0.05;
            omega *= 0.96; 
            theta += omega;
            theta = Math.max(-1.2, Math.min(1.2, theta));
            stringGroup.rotation.z = theta;

            // Conduction
            // UPDATED THRESHOLD: Slightly larger than 1.0 to ensure triggering when clamped
            if(dist < 1.2) {
                if(Math.abs(state.rodCharge - state.ballCharge) > 5) {
                    spawnParticle(ballX, 4.6, 0, state.rodCharge>0?'pos':'neg');
                    const avg = (state.rodCharge + state.ballCharge) / 2;
                    state.rodCharge = avg;
                    state.ballCharge = avg;
                    omega -= 0.05; 
                    updateEmissives();
                    checkAdvance(); 
                }
            }

            // Particles
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.mesh.position.add(p.vel);
                p.mesh.rotation.x += 0.1; p.life -= 0.02; p.mesh.scale.setScalar(p.life);
                if(p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
            }
            
            renderer.render(scene, camera);
            updateHUD();
        }

        animate();


        // ==========================================
        // PART 2: THE STORY ENGINE (UPDATED)
        // ==========================================

        function updateHUD() {
            const rVal = document.getElementById('val-rod');
            const bVal = document.getElementById('val-ball');
            
            // Format for display
            rVal.innerText = Math.round(state.rodCharge);
            rVal.style.color = state.rodCharge > 0 ? '#54a0ff' : (state.rodCharge < 0 ? '#ff5252' : '#888');
            
            bVal.innerText = Math.round(state.ballCharge);
            bVal.style.color = state.ballCharge > 0 ? '#54a0ff' : (state.ballCharge < 0 ? '#ff5252' : '#888');
        }

        function uiSetMaterial(mat) {
            setMaterial(mat);
            document.getElementById('btn-glass').style.borderColor = mat==='glass'?'#fff':'#444';
            document.getElementById('btn-rubber').style.borderColor = mat==='rubber'?'#fff':'#444';
            
            // Update button text logic
            const rubBtn = document.getElementById('btn-rub');
            if(mat === 'glass') rubBtn.innerText = "Rub with Silk";
            else rubBtn.innerText = "Rub with Fur";

            if(currentChapter === 1 || currentChapter === 5) pulse('btn-rub', true);
        }

        function uiRubRod() {
            rubRod();
            pulse('btn-rub', false);
        }

        document.getElementById('slider-dist').addEventListener('input', (e) => {
            setRodDistance(parseInt(e.target.value));
            pulse('slider-dist', false);
            checkAdvance();
        });

        // --- STORY CHAPTERS (NARRATIVE UPDATED) ---
        let currentChapter = 0;

        const lessons = [
            {
                title: "Prologue: The Invisible Ocean",
                text: "Welcome to 1752. Benjamin Franklin has a bold new idea.<br><br>He believes electricity is not a creation, but a <strong>Single Invisible Fluid</strong> that exists in everything—you, me, and this glass rod.<br><br>Right now, the rod has a normal amount of fluid. It is 'Neutral'.",
                setup: () => {
                    lockAll();
                    document.getElementById('hud').style.opacity = 0;
                    state.rodCharge = 0; state.ballCharge = 0; state.rodPosition = 0;
                    setMaterial('glass');
                    updateEmissives();
                    document.getElementById('slider-dist').value = 0;
                },
                check: () => true 
            },
            {
                title: "Step 1: The Greedy Silk",
                text: "To create a charge, we must move this fluid. <br><br>Franklin has noticed that <strong>Silk</strong> is greedy. When it touches glass, it wipes the electrical fluid away.<br><br>I have placed the Silk Cloth in his right hand. Click <strong>Rub with Silk</strong> to strip the fluid from the rod.",
                setup: () => {
                    document.getElementById('hud').style.opacity = 1;
                    unlock('ctrl-action');
                    pulse('btn-rub', true);
                },
                check: () => state.rodCharge > 10
            },
            {
                title: "Step 2: A 'Thirsty' Rod",
                text: "The rod has lost its fluid! Franklin calls this state <strong>Positive</strong>.<br><br>Because the rod is missing fluid, it is desperate to get it back. It pulls on everything nearby.<br><br>Slowly drag the <strong>Slider</strong> to move the rod closer to the neutral ball.",
                setup: () => {
                    unlock('ctrl-move');
                    pulse('slider-dist', true);
                    if(state.rodCharge < 10) state.rodCharge = 50; 
                    updateEmissives();
                },
                check: () => state.rodPosition > 50
            },
            {
                title: "Step 3: Sharing the Deficit",
                text: "The ball is attracted because the rod is trying to pull fluid out of it.<br><br>Move the slider to <strong>100%</strong>. Let them touch.<br><br>When they touch, the rod will steal fluid from the ball, leaving the ball deficient (Positive) as well.",
                setup: () => {
                    unlock('ctrl-move');
                    pulse('slider-dist', true);
                },
                check: () => Math.abs(state.ballCharge) > 5
            },
            {
                title: "Step 4: Repulsion",
                text: "<strong>BOOM!</strong> They flew apart!<br><br>Now both objects are 'thirsty' (Positive). They both want fluid, but neither has any to give. They reject each other.<br><br>We have discovered a law: <span class='highlight'>Like charges repel.</span>",
                setup: () => {
                    unlock('ctrl-move');
                },
                check: () => true
            },
            {
                title: "Step 5: The Generous Fur",
                text: "Let us try the opposite. We have reset the experiment.<br><br>Select the <strong>Rubber Rod</strong>. Notice the scientist now holds <strong>Cat Fur</strong>.<br><br>Fur is different. It is overflowing with fluid. If you rub it against rubber, the fur <em>gives</em> fluid to the rod.",
                setup: () => {
                    state.ballCharge = 0; 
                    state.rodCharge = 0; 
                    state.rodPosition = 0; 
                    document.getElementById('slider-dist').value = 0;
                    updateEmissives();

                    lockAll();
                    unlock('ctrl-materials');
                    unlock('ctrl-action');
                    pulse('btn-rubber', true);
                },
                check: () => state.rodCharge < -10
            },
            {
                title: "Final: The Negative State",
                text: "The Rubber Rod now has <em>too much</em> fluid. Franklin calls this <strong>Negative</strong>.<br><br>If you touch the ball now, the rod will pour its excess fluid into the ball.<br><br>Whether it is too much fluid or too little, the result is the same: Nature always seeks balance.",
                setup: () => {
                    unlock('ctrl-move');
                    pulse('slider-dist', true);
                },
                check: () => true
            }
        ];

        // --- NAVIGATION LOGIC ---

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            
            document.querySelector('header .subtitle').innerText = `Chapter ${idx}`;
            const container = document.getElementById('chapter-content');
            container.innerHTML = `<div class="chapter-title">${l.title}</div><div class="story-text">${l.text}</div>`;
            
            document.getElementById('btn-next').disabled = !l.check();
            document.querySelectorAll('.pulse').forEach(e => e.classList.remove('pulse'));
            l.setup();
        }

        function nextLesson() {
            if(currentChapter < lessons.length - 1) loadLesson(currentChapter + 1);
        }
        
        function prevLesson() {
            if(currentChapter > 0) loadLesson(currentChapter - 1);
        }

        function checkAdvance() {
            const btn = document.getElementById('btn-next');
            if(lessons[currentChapter].check()) {
                if(btn.disabled) {
                    btn.disabled = false;
                    btn.classList.add('pulse');
                }
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }
        function pulse(id, on) {
            const el = document.getElementById(id);
            if(on) el.classList.add('pulse'); else el.classList.remove('pulse');
        }

        // Init
        loadLesson(0);

        // Window Resize
        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -d * newAspect; camera.right = d * newAspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Insulators & Polarization: The Subtle Shift</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43; /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
            --electron: #00d2d3; /* Cyan */
            --proton: #ff6b6b;    /* Red */
        }

        body { margin: 0; height: 100vh; display: flex; background: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; overflow: hidden; }

        /* LEFT PANEL */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0,0,0,0.5);
            z-index: 10;
        }

        header { padding: 20px; border-bottom: 1px solid var(--border); background: rgba(0,0,0,0.2); }
        h1 { margin: 0; font-size: 20px; color: var(--accent); text-transform: uppercase; letter-spacing: 2px; }
        .subtitle { font-size: 12px; color: #777; margin-top: 5px; font-style: italic; }

        #story-container { flex: 1; padding: 30px; overflow-y: auto; display: flex; flex-direction: column; }
        .chapter-title { font-size: 24px; font-weight: 300; color: #fff; margin-bottom: 20px; border-left: 4px solid var(--accent); padding-left: 15px; }
        
        .story-text { line-height: 1.8; font-size: 15px; color: #ccc; margin-bottom: 20px; }
        .story-text strong { color: #fff; font-weight: 600; }
        .instruction-inline { color: var(--accent); font-weight: bold; }

        /* CONTROLS AREA */
        #controls-area { background: #181818; padding: 20px; border-top: 1px solid var(--border); }
        
        .control-row { 
            margin-bottom: 15px; 
            opacity: 0.5; 
            transition: 0.3s; 
            filter: grayscale(1); 
            position: relative; 
        }
        
        .control-row.active { opacity: 1; filter: grayscale(0); }
        
        label { display: block; font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }

        button {
            background: #333; color: #aaa; border: 1px solid #444;
            padding: 10px 15px; cursor: pointer; border-radius: 4px;
            font-size: 13px; transition: all 0.2s; width: 100%;
            text-transform: uppercase; font-weight: bold;
        }
        button:hover:not(:disabled) { background: #444; color: #fff; }
        button:disabled { cursor: not-allowed; }

        input[type=range] { width: 100%; accent-color: var(--accent); cursor: pointer; }
        input[type=range]:disabled { cursor: not-allowed; opacity: 0.5; }

        /* TOGGLE SWITCH for MICRO VIEW */
        .toggle-container { display: flex; align-items: center; justify-content: space-between; margin-top: 10px; }
        .toggle-label { font-size: 13px; color: #fff; }
        .switch { position: relative; display: inline-block; width: 40px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #333; transition: .4s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 14px; width: 14px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent); }
        input:checked + .slider:before { transform: translateX(20px); }

        /* NAVIGATION FOOTER */
        #nav-footer { padding: 20px; display: flex; justify-content: space-between; border-top: 1px solid var(--border); background: #222; }
        .nav-btn { width: 48%; background: #333; color: #fff; border: none; }
        .nav-btn.next { background: var(--accent); color: #151515; }
        .nav-btn.next:hover:not(:disabled) { background: var(--accent-hover); color: #000; }
        .nav-btn.next:disabled { background: #333; color: #555; cursor: not-allowed; opacity: 0.5; }

        main { flex: 1; position: relative; background: #151515; overflow: hidden; }
        
        #legend {
            position: absolute; top: 20px; right: 20px; 
            background: rgba(0,0,0,0.6); padding: 15px; border-radius: 8px;
            pointer-events: none; border: 1px solid #333;
        }
        .legend-item { display: flex; align-items: center; margin-bottom: 8px; font-size: 12px; color: #ccc; }
        .dot { width: 10px; height: 10px; border-radius: 50%; margin-right: 10px; }
    </style>
</head>
<body>

    <aside>
        <header>
            <h1>Franklin's Lab</h1>
            <div class="subtitle">Module: Insulators & Polarization</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- 1. Bring Rod -->
            <div class="control-row" id="ctrl-rod">
                <label>1. Tools</label>
                <button id="btn-rod" disabled onclick="toggleRod()">Equip Negative Rod</button>
            </div>

            <!-- 2. Slider -->
            <div class="control-row" id="ctrl-move">
                <label>2. Distance</label>
                <input type="range" id="slider-dist" disabled min="0" max="100" value="0" step="1">
            </div>
            
            <!-- 3. Micro View Toggle -->
            <div class="control-row active" style="border-top: 1px solid #333; padding-top: 10px; margin-top: 10px;">
                <div class="toggle-container">
                    <span class="toggle-label">Microscopic View (X-Ray)</span>
                    <label class="switch">
                        <input type="checkbox" id="check-micro" checked onchange="toggleMicroView()">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>

             <div class="control-row active" style="margin-top:10px;">
                <button onclick="resetSim()" style="background: transparent; border: 1px solid #555; color: #777;">Reset Experiment</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div id="legend">
            <div style="font-size: 10px; text-transform: uppercase; color: #666; margin-bottom: 5px;">Legend</div>
            <div class="legend-item"><div class="dot" style="background: #ff6b6b;"></div>Pos. Nucleus (Fixed)</div>
            <div class="legend-item"><div class="dot" style="background: #00d2d3; box-shadow: 0 0 5px #00d2d3;"></div>Neg. Electron Cloud</div>
        </div>
    </main>

   <script>
    // ==========================================
    // PART 1: THE 3D ENGINE
    // ==========================================
    
    const state = {
        rodVisible: false,
        rodPosPercent: 0,
        microView: true,
        molecules: [] // Stores reference to our atom objects
    };

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x151515);

    // Camera Setup
    const sidebarWidth = 420;
    let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
    const viewSize = 28; 
    const camera = new THREE.OrthographicCamera(
        -viewSize * aspect / 2, viewSize * aspect / 2,
        viewSize / 2, -viewSize / 2,
        1, 1000
    );
    camera.position.set(20, 20, 20); 
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.getElementById('world').appendChild(renderer.domElement);

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(10, 20, 10);
    dirLight.castShadow = true;
    scene.add(dirLight);

    const grid = new THREE.GridHelper(60, 60, 0x333333, 0x111111);
    grid.position.y = -10; 
    scene.add(grid);

    // --- THE INSULATOR BLOCK ---
    const blockGroup = new THREE.Group();
    scene.add(blockGroup);

    // The physical block (Macro view)
    const blockGeo = new THREE.BoxGeometry(10, 8, 10);
    const blockMat = new THREE.MeshPhongMaterial({
        color: 0x444444,
        transparent: true,
        opacity: 0.1,
        shininess: 80,
        side: THREE.DoubleSide,
        depthWrite: false 
    });
    const blockMesh = new THREE.Mesh(blockGeo, blockMat);
    blockMesh.renderOrder = 0;
    blockGroup.add(blockMesh);
    
    // Wireframe edges
    const edges = new THREE.EdgesGeometry(blockGeo);
    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x555555 }));
    blockGroup.add(line);

    // --- THE MOLECULES (Micro View) ---
    const moleculeGroup = new THREE.Group();
    blockGroup.add(moleculeGroup);

    function createMolecule(x, y, z) {
        const group = new THREE.Group();
        group.position.set(x, y, z);
        
        // 1. The Nucleus (Positive)
        const nucGeo = new THREE.SphereGeometry(0.35, 16, 16);
        const nucMat = new THREE.MeshStandardMaterial({ 
            color: 0xff4444,     // Bright Red
            emissive: 0x660000,  // Glows slightly red
            roughness: 0.4 
        });
        const nucleus = new THREE.Mesh(nucGeo, nucMat);
        group.add(nucleus);

        // 2. The Electron Cloud (Negative)
        const cloudGeo = new THREE.SphereGeometry(0.75, 24, 24);
        const cloudMat = new THREE.MeshPhongMaterial({ 
            color: 0x66eeff,     // Light Blue (Cyan-ish)
            emissive: 0x002233,
            transparent: true, 
            opacity: 0.3,        
            depthWrite: false,   
            side: THREE.DoubleSide
        });
        const cloud = new THREE.Mesh(cloudGeo, cloudMat);
        group.add(cloud);

        return {
            group: group,
            nucleus: nucleus,
            cloud: cloud,
            basePos: new THREE.Vector3(x, y, z)
        };
    }

    // Generate grid of molecules
    for(let x=-3.5; x<=3.5; x+=3.5) {
        for(let y=-2.5; y<=2.5; y+=2.5) {
            for(let z=-3.5; z<=3.5; z+=3.5) {
                const mol = createMolecule(x, y, z);
                moleculeGroup.add(mol.group);
                state.molecules.push(mol);
            }
        }
    }

    // --- THE ROD ---
    const rodGroup = new THREE.Group();
    const rodGeo = new THREE.CylinderGeometry(0.8, 0.8, 12, 32);
    rodGeo.rotateZ(Math.PI / 2); // Lay flat
    const rodMat = new THREE.MeshStandardMaterial({ color: 0xff4444, roughness: 0.2 });
    const rodMesh = new THREE.Mesh(rodGeo, rodMat);
    rodGroup.add(rodMesh);

    // Add negative signs
    for(let i=-4; i<=4; i+=2) {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.font = 'bold 60px Arial';
        ctx.fillText('-', 25, 50);
        const tex = new THREE.CanvasTexture(canvas);
        const sign = new THREE.Mesh(new THREE.PlaneGeometry(0.8,0.8), new THREE.MeshBasicMaterial({map: tex, transparent:true, side: THREE.DoubleSide}));
        sign.position.set(i, 0.9, 0);
        sign.rotation.x = -Math.PI/2; 
        rodGroup.add(sign);
    }
    rodGroup.position.set(-50, 0, 0);
    scene.add(rodGroup);

    // ==========================================
    // PART 2: PHYSICS LOOP
    // ==========================================

    function animate() {
        requestAnimationFrame(animate);

        // 1. Rod Movement
        const targetX = -30 + (state.rodPosPercent / 100) * 10;
        
        if(state.rodVisible) {
            rodGroup.visible = true;
            rodGroup.position.x += (targetX - rodGroup.position.x) * 0.1;
        } else {
            rodGroup.visible = false;
            rodGroup.position.x = -50;
        }

        const rodTipX = rodGroup.position.x + 6; // Tip location

        // 2. Molecular Polarization Logic
        state.molecules.forEach(mol => {
            const molWorldPos = mol.basePos.clone(); // Approx position
            const dist = molWorldPos.x - rodTipX; // Distance to rod
            
            if(state.rodVisible && dist > 0) {
                // Strength falls off with distance squared
                const force = 100 / (dist * dist + 10); 
                const maxShift = 0.6; 
                const shift = Math.min(force * 0.8, maxShift);

                // Apply Shift - Cloud moves AWAY from negative rod (to the right)
                mol.cloud.position.x = THREE.MathUtils.lerp(mol.cloud.position.x, shift, 0.1);
                
            } else {
                // Reset - Cloud centers on nucleus
                mol.cloud.position.x = THREE.MathUtils.lerp(mol.cloud.position.x, 0, 0.1);
            }
        });

        // 3. Macro Block Movement
        if(state.rodVisible) {
            if(state.rodPosPercent > 20) {
                const pull = (state.rodPosPercent / 100) * 2.0;
                blockGroup.position.x = THREE.MathUtils.lerp(blockGroup.position.x, -pull, 0.05);
            } else {
                blockGroup.position.x = THREE.MathUtils.lerp(blockGroup.position.x, 0, 0.05);
            }
        } else {
            blockGroup.position.x = THREE.MathUtils.lerp(blockGroup.position.x, 0, 0.05);
        }

        moleculeGroup.visible = state.microView;
        renderer.render(scene, camera);
    }
    animate();

    // ==========================================
    // PART 3: INTERACTION & STORY
    // ==========================================

    function toggleRod() {
        state.rodVisible = true;
        document.getElementById('btn-rod').disabled = true;
        document.getElementById('btn-rod').innerText = "Rod Equipped";
        checkAdvance();
    }

    document.getElementById('slider-dist').addEventListener('input', (e) => {
        state.rodPosPercent = e.target.value;
        checkAdvance();
    });

    function toggleMicroView() {
        state.microView = document.getElementById('check-micro').checked;
    }

    function resetSim() {
        state.rodVisible = false;
        state.rodPosPercent = 0;
        document.getElementById('slider-dist').value = 0;
        document.getElementById('btn-rod').innerText = "Equip Negative Rod";
        blockGroup.position.x = 0;
        loadLesson(0);
    }

    // Helper to format the **text** into <strong>text</strong>
    function formatStoryText(text) {
        // Regex looks for ** ... ** and replaces with <strong> ... </strong>
        return text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    }

    // STORY DATA
    let currentChapter = 0;
    const lessons = [
        {
            title: "1. The Insulator",
            text: "<strong>What is an Electron Cloud?</strong><br>In our previous Conductor experiment, we saw electrons as simple dots flowing freely.<br><br>Here in an **Insulator**, electrons are trapped. They orbit the nucleus so fast that they form a blurry **Cloud** (Cyan). They can wiggle, but they cannot leave the atom.",
            setup: () => {
                state.microView = true;
                document.getElementById('check-micro').checked = true;
                toggleRodLogic(false);
            },
            check: () => true 
        },
        {
            title: "2. Approaching Charge",
            text: "We have a <strong>Negatively Charged Rod</strong>. <br><br>Since the electrons in this block are trapped in clouds, they cannot flow to the other side like they did in metal. But they can still react.<br><br><span class='instruction-inline'>Equip the Rod</span> to begin.",
            setup: () => {
                toggleRodLogic(true);
            },
            check: () => state.rodVisible
        },
        {
            title: "3. Polarization",
            text: "Watch the **Cyan Clouds** carefully. <br><span class='instruction-inline'>Drag the slider to 60%</span>.<br><br>The negative rod repels the electron clouds. The clouds stretch and shift to the <em>right</em>, away from the rod.<br><br>The **Red Nuclei** stay put, but now they are slightly 'exposed' on the left side.",
            setup: () => {
                toggleSliderLogic(true);
            },
            check: () => state.rodPosPercent > 50
        },
        {
            title: "4. Conclusion & The Next Step",
            text: "The slight shift you see is **Polarization**. The positive nuclei are now closer to the rod than the repelled clouds, creating a net attraction that pulls the neutral block.<br><br><strong>Up Next: The Triboelectric Effect</strong><br>We've seen how charge *pulls* things, but where does the charge come from? In our next module, we will explore what happens when you **comb your hair**. We'll discover why it makes a crackling popping sound, and how friction tears electrons violently from one surface to another.",
            setup: () => {},
            check: () => state.rodPosPercent > 90
        }
    ];

    function toggleRodLogic(enable) {
        const row = document.getElementById('ctrl-rod');
        const btn = document.getElementById('btn-rod');
        if(enable) {
            row.classList.add('active');
            btn.disabled = false;
        } else {
            row.classList.remove('active');
            btn.disabled = true;
        }
    }

    function toggleSliderLogic(enable) {
        const row = document.getElementById('ctrl-move');
        const slide = document.getElementById('slider-dist');
        if(enable) {
            row.classList.add('active');
            slide.disabled = false;
        } else {
            row.classList.remove('active');
            slide.disabled = true;
        }
    }

    function loadLesson(idx) {
        currentChapter = idx;
        const l = lessons[idx];
        document.querySelector('header .subtitle').innerText = `Step ${idx+1} of 4`;
        
        // Use the formatter here
        document.getElementById('chapter-content').innerHTML = 
            `<div class="chapter-title">${l.title}</div>
             <div class="story-text">${formatStoryText(l.text)}</div>`;
        
        // Reset controls state for safety before applying specific lesson setup
        if(idx === 0) {
            toggleRodLogic(false);
            toggleSliderLogic(false);
        }

        l.setup();
        checkAdvance();
    }

    function nextLesson() {
        if(currentChapter < lessons.length - 1) loadLesson(currentChapter + 1);
    }
    function prevLesson() {
        if(currentChapter > 0) loadLesson(currentChapter - 1);
    }
    function checkAdvance() {
        const btn = document.getElementById('btn-next');
        if(lessons[currentChapter].check()) {
            btn.disabled = false;
        } else {
            btn.disabled = true;
        }
    }

    // Init
    loadLesson(0);

    window.addEventListener('resize', () => {
        const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        camera.left = -viewSize * newAspect / 2;
        camera.right = viewSize * newAspect / 2;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
    });

</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Coulomb's Torsion Balance Experiment</title>
    <!-- Using Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #0f1014;
            --panel: #181a1f;
            --text: #e0e6ed;
            --accent: #ff9f43; /* Warm Orange */
            --accent-hover: #ffb773;
            --border: #2c313a;
            --electron: #00d2d3; /* Cyan */
            --proton: #ff6b6b;    /* Red */
        }

        body { margin: 0; height: 100vh; display: flex; background: var(--bg); color: var(--text); font-family: 'Segoe UI', Roboto, Helvetica, sans-serif; overflow: hidden; }

        /* LEFT PANEL */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0,0,0,0.6);
            z-index: 10;
        }

        header { padding: 25px; border-bottom: 1px solid var(--border); background: rgba(0,0,0,0.1); }
        h1 { margin: 0; font-size: 22px; color: var(--accent); text-transform: uppercase; letter-spacing: 2px; font-weight: 700; }
        .subtitle { font-size: 13px; color: #8892b0; margin-top: 5px; font-style: italic; }

        #story-container { flex: 1; padding: 30px; overflow-y: auto; display: flex; flex-direction: column; }
        
        .chapter-title { 
            font-size: 20px; 
            font-weight: 600; 
            color: #fff; 
            margin-bottom: 15px; 
            border-left: 4px solid var(--accent); 
            padding-left: 15px; 
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .story-text { 
            line-height: 1.8; 
            font-size: 15px; 
            color: #bdc3c7; 
            margin-bottom: 20px; 
        }
        
        .story-text strong { color: #fff; font-weight: 600; }
        
        /* CONTROLS AREA */
        #controls-area { background: #131519; padding: 25px; border-top: 1px solid var(--border); }
        .control-row { margin-bottom: 20px; opacity: 0.4; pointer-events: none; transition: 0.4s; filter: grayscale(1); position: relative; }
        .control-row.active { opacity: 1; pointer-events: all; filter: grayscale(0); }
        
        label { display: flex; justify-content: space-between; font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px; font-weight: 700; }
        label span { color: var(--accent); }

        button {
            background: #2c313a; color: #aaa; border: 1px solid #3d4450;
            padding: 12px 15px; cursor: pointer; border-radius: 6px;
            font-size: 13px; transition: all 0.2s; width: 100%;
            text-transform: uppercase; font-weight: bold; letter-spacing: 0.5px;
        }
        button:hover { background: #3d4450; color: #fff; border-color: #555; }
        button:active { transform: translateY(1px); }

        input[type=range] { width: 100%; accent-color: var(--accent); cursor: pointer; height: 6px; background: #333; border-radius: 3px; }

        /* NAVIGATION FOOTER */
        #nav-footer { padding: 20px 25px; display: flex; justify-content: space-between; border-top: 1px solid var(--border); background: #111; }
        .nav-btn { width: 48%; background: #222; color: #fff; border: none; }
        .nav-btn.next { background: var(--accent); color: #151515; font-weight: 800; }
        .nav-btn.next:hover { background: var(--accent-hover); color: #000; box-shadow: 0 0 15px rgba(255, 159, 67, 0.4); }
        .nav-btn.next:disabled { background: #222; color: #555; cursor: not-allowed; opacity: 0.5; box-shadow: none; }

        /* MAIN CANVAS */
        main { flex: 1; position: relative; background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%); overflow: hidden; }
        
        .scene-tag {
            position: absolute;
            color: rgba(255,255,255,0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }

        /* DATA DISPLAY OVERLAY */
        #data-overlay {
            position: absolute;
            bottom: 20px; right: 20px;
            background: rgba(0,0,0,0.6);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--border);
            color: #aaa;
            font-family: monospace;
            font-size: 12px;
            pointer-events: none;
        }
        .data-row { display: flex; justify-content: space-between; width: 220px; margin-bottom: 5px; }
        .data-val { color: #fff; font-weight: bold; }

    </style>
</head>
<body>

    <aside>
        <header>
            <h1>Charles Coulomb</h1>
            <div class="subtitle">Deriving the Law</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- Control 1: Charge Q1 -->
            <div class="control-row" id="ctrl-q1">
                <label>Fixed Sphere Charge (Q1) <span id="val-q1">0 µC</span></label>
                <input type="range" id="slider-q1" min="-50" max="50" value="0" step="1">
            </div>

            <!-- Control 2: Charge Q2 -->
            <div class="control-row" id="ctrl-q2">
                <label>Beam Sphere Charge (Q2) <span id="val-q2">0 µC</span></label>
                <input type="range" id="slider-q2" min="-50" max="50" value="0" step="1">
            </div>
            
            <!-- Control 3: Distance -->
             <div class="control-row" id="ctrl-dist">
                <label>Probe Distance (r) <span id="val-dist">21 cm</span></label>
                <input type="range" id="slider-dist" min="21" max="40" value="21" step="0.5">
            </div>

            <!-- Reset -->
             <div class="control-row active" id="ctrl-reset" style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; filter: grayscale(0);">
                <button onclick="resetSim()">Reset Experiment</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Laboratory View</div>
        <div id="data-overlay">
            <div class="data-row"><span>Torsion Torque:</span> <span class="data-val" id="disp-torque">0.00 Nm</span></div>
            <div class="data-row" style="border-top: 1px solid #444; padding-top: 5px; margin-top:5px;"><span>Twist Angle (θ):</span> <span class="data-val" id="disp-angle" style="color: var(--accent); font-size: 14px;">0.00°</span></div>
        </div>
    </main>

<script>
    // ==========================================
    // PART 1: SIMULATION STATE & VARIABLES
    // ==========================================
    
    // 1. Core Config
    // UPDATED FOR STABILITY: Higher stiffness (torsionK) prevents the 180-degree flip glitch
    const config = {
        charge1: 0,      // Fixed Probe
        charge2: 0,      // Beam Sphere
        distance: 21,    // Initial distance
        k: 65,           // Scaling constant (Adjusted to balance new stiffness)
        torsionK: 450,   // INCREASED: Makes the wire stiff. Range will stay < 100 degrees.
        damping: 0.92,   // INCREASED: Stops wobbling fast.
        angle: 0,        // Current rotation
        velocity: 0      // Angular velocity
    };

    // 2. Narrative State
    let currentChapter = 0;

    function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
    function unlock(id) { document.getElementById(id).classList.add('active'); }

    // --- LESSONS ---
    const lessons = [
        {
            title: "Lesson 1: The Measurement Tool",
            text: "We want to find the equation for electric force. But we cannot see force directly.<br><br>This apparatus uses a wire that resists twisting. <strong>Hooke's Law</strong> tells us that the angle of twist (θ) is directly proportional to the Force.<br><br>Therefore: <strong>If the angle doubles, the Force has doubled.</strong><br><br>Click Next to begin the derivation.",
            setup: () => {
                lockAll();
                unlock('ctrl-reset');
            },
            check: () => true
        },
        {
            title: "Lesson 2: Establishing a Baseline",
            text: "First, let's create a baseline measurement.<br><br>1. Ensure Distance is at <strong>21 cm</strong>.<br>2. Set Fixed Sphere (Q1) to <strong>+20 µC</strong>.<br>3. Set Beam Sphere (Q2) to <strong>+20 µC</strong>.<br><br>Wait for the beam to settle. The angle should appear in the <strong>30° to 40°</strong> range.",
            setup: () => {
                unlock('ctrl-q1');
                unlock('ctrl-q2');
            },
            check: () => config.charge1 === 20 && config.charge2 === 20 && config.distance === 21
        },
        {
            title: "Lesson 3: Testing Charge (q)",
            text: "Now, let's discover how Charge affects Force.<br><br>Keep the distance fixed at 21cm. <strong>Double</strong> the Beam Sphere (Q2) charge to <strong>+40 µC</strong>.<br><br>Look at the new Angle. It should now be in the <strong>60° to 75°</strong> range.<br><br>Because the angle roughly doubled when the charge doubled, we know that Force is directly proportional to Charge.",
            setup: () => {
                unlock('ctrl-q2'); 
                document.getElementById('ctrl-q1').classList.remove('active');
                document.getElementById('ctrl-dist').classList.remove('active');
            },
            check: () => config.charge2 >= 40
        },
        {
            title: "Lesson 4: Testing Distance (r)",
            text: "Now for the critical discovery. Reset charges to <strong>+40 µC</strong> and <strong>+40 µC</strong>.<br><br>Currently, Distance is 21cm. Slowly increase the distance slider to <strong>30cm or 40cm</strong>.<br><br>Observe the Angle. Does it drop linearly? No, it plummets rapidly.<br><br><em>Observation: Force drops by the square of the distance (1/r²).</em>",
            setup: () => {
                unlock('ctrl-q1');
                unlock('ctrl-q2');
                unlock('ctrl-dist');
            },
            check: () => config.distance > 30 && config.charge1 > 30 && config.charge2 > 30
        },
        {
            title: "Lesson 5: The Equation",
            text: "By combining your two observations, you have derived Coulomb's Law:<br><br>1. Force $\\propto$ $(q1 \\cdot q2)$<br>2. Force $\\propto$ $1/r^2$<br><br>Putting it together:<br><strong>F = k · (q1 · q2) / r²</strong><br><br>Click Next for the conclusion.",
            setup: () => {
                unlock('ctrl-q1');
                unlock('ctrl-q2');
                unlock('ctrl-dist');
                unlock('ctrl-reset');
            },
            check: () => true 
        },
        {
            title: "Conclusion",
            text: "<strong>Excellent work.</strong><br><br>You have successfully replicated Charles Coulomb's 1785 experiment. You observed that force increases with charge and decreases drastically with distance.<br><br>This fundamental law explains everything from the structure of the atom to the behavior of static electricity.<br><br>Feel free to continue experimenting with different values.",
            setup: () => {
                unlock('ctrl-q1');
                unlock('ctrl-q2');
                unlock('ctrl-dist');
                unlock('ctrl-reset');
            },
            check: () => false // End
        }
    ];

    function checkAdvance() {
        if(currentChapter >= lessons.length - 1) return;
        
        const btn = document.getElementById('btn-next');
        if(lessons[currentChapter].check()) {
            btn.disabled = false;
        } else {
            btn.disabled = true;
        }
    }

    // ==========================================
    // PART 2: THE 3D SCENE CONSTRUCTION
    // ==========================================

    const scene = new THREE.Scene();

    // Camera Setup
    const sidebarWidth = 420;
    let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
    const viewSize = 45; 
    
    const camera = new THREE.OrthographicCamera(
        -viewSize * aspect / 2, viewSize * aspect / 2,
        viewSize / 2, -viewSize / 2,
        1, 1000
    );
    camera.position.set(30, 35, 30); 
    camera.lookAt(0, 5, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
    document.getElementById('world').appendChild(renderer.domElement);

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(20, 50, 20);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    scene.add(dirLight);

    // --- MATERIALS & TEXTURES ---
    
    function createTileTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#1e2126'; ctx.fillRect(0, 0, 512, 512);
        ctx.strokeStyle = '#111316'; ctx.lineWidth = 4;
        ctx.beginPath();
        for(let i=0; i<=512; i+=64) {
            ctx.moveTo(i, 0); ctx.lineTo(i, 512);
            ctx.moveTo(0, i); ctx.lineTo(512, i);
        }
        ctx.stroke();
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(10, 10);
        return tex;
    }

    const matFloor = new THREE.MeshStandardMaterial({ map: createTileTexture(), roughness: 0.8, metalness: 0.2 });
    const matBase = new THREE.MeshStandardMaterial({ color: 0x2c3e50, roughness: 0.3 });
    const matGlass = new THREE.MeshPhongMaterial({ color: 0xaec6cf, opacity: 0.1, transparent: true, shininess: 90, side: THREE.DoubleSide });
    const matMetal = new THREE.MeshStandardMaterial({ color: 0x95a5a6, roughness: 0.2, metalness: 0.8 });
    const matBeam = new THREE.MeshStandardMaterial({ color: 0xe67e22, roughness: 0.6 });
    const matWire = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const matPos = new THREE.MeshStandardMaterial({ color: 0xff6b6b, emissive: 0x550000 });
    const matNeg = new THREE.MeshStandardMaterial({ color: 0x00d2d3, emissive: 0x004444 });
    const matNeu = new THREE.MeshStandardMaterial({ color: 0x7f8c8d });

    // --- GEOMETRY ---

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), matFloor);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -2;
    floor.receiveShadow = true;
    scene.add(floor);

    const baseMesh = new THREE.Mesh(new THREE.CylinderGeometry(16, 18, 2, 8), matBase);
    baseMesh.position.y = -1;
    baseMesh.receiveShadow = true;
    scene.add(baseMesh);

    // Scale
    const scaleGroup = new THREE.Group();
    const ringGeo = new THREE.RingGeometry(14, 15, 64);
    ringGeo.rotateX(-Math.PI/2);
    const ringMesh = new THREE.Mesh(ringGeo, new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.3 }));
    scaleGroup.add(ringMesh);
    for(let i=0; i<360; i+=10) {
        const tickGeo = new THREE.BoxGeometry(0.2, 0.1, 2);
        const tick = new THREE.Mesh(tickGeo, new THREE.MeshBasicMaterial({color: 0xaaaaaa}));
        tick.position.set(Math.cos(i*Math.PI/180)*14.5, 0.1, Math.sin(i*Math.PI/180)*14.5);
        tick.lookAt(0,0,0);
        scaleGroup.add(tick);
    }
    scaleGroup.position.y = 0.1;
    scene.add(scaleGroup);

    // Apparatus
    const glassCase = new THREE.Mesh(new THREE.CylinderGeometry(14, 14, 25, 32, 1, true), matGlass);
    glassCase.position.y = 12.5;
    scene.add(glassCase);
    const glassCap = new THREE.Mesh(new THREE.CylinderGeometry(14, 14, 1, 32), matBase);
    glassCap.position.y = 25.5;
    scene.add(glassCap);

    const wire = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 25), matWire);
    wire.position.y = 12.5;
    scene.add(wire);

    // Torsion Assembly
    const torsionGroup = new THREE.Group();
    scene.add(torsionGroup);

    const beam = new THREE.Mesh(new THREE.BoxGeometry(20, 0.4, 0.4), matBeam);
    beam.position.y = 10;
    beam.castShadow = true;
    torsionGroup.add(beam);

    const sphereGeo = new THREE.IcosahedronGeometry(1.5, 1);
    const sphereBeam = new THREE.Mesh(sphereGeo, matNeu);
    sphereBeam.position.set(10, 10, 0); // Radius 10
    sphereBeam.castShadow = true;
    torsionGroup.add(sphereBeam);

    const sphereWeight = new THREE.Mesh(new THREE.IcosahedronGeometry(1.5, 0), matMetal);
    sphereWeight.position.set(-10, 10, 0);
    sphereWeight.castShadow = true;
    torsionGroup.add(sphereWeight);

    // Probe
    const probeGroup = new THREE.Group();
    scene.add(probeGroup);

    const sphereFixed = new THREE.Mesh(sphereGeo, matNeu);
    sphereFixed.castShadow = true;
    probeGroup.add(sphereFixed);

    const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 15), matMetal);
    handle.position.y = 8;
    probeGroup.add(handle);

    // Force Line
    const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0)]);
    const lineMat = new THREE.LineDashedMaterial({ color: 0xffffff, dashSize: 0.5, gapSize: 0.3, scale: 1 });
    const forceLine = new THREE.Line(lineGeo, lineMat);
    scene.add(forceLine);

    // ==========================================
    // PART 3: PHYSICS LOOP
    // ==========================================

    function updateMaterial(mesh, charge) {
        if (Math.abs(charge) < 0.1) mesh.material = matNeu;
        else if (charge > 0) mesh.material = matPos;
        else mesh.material = matNeg;
        
        if (mesh.material.emissive) {
            const intensity = Math.min(Math.abs(charge) / 50, 1);
            mesh.material.emissiveIntensity = 0.5 + intensity;
        }
    }

    function animate() {
        requestAnimationFrame(animate);

        // 1. Update Probe Position based on distance slider
        const probeX = config.distance;
        probeGroup.position.set(probeX, 10, 5); 
        probeGroup.lookAt(0, 10, 0);

        // 2. Physics Logic
        const pBeam = new THREE.Vector3();
        sphereBeam.getWorldPosition(pBeam);
        
        const pFixed = new THREE.Vector3();
        sphereFixed.getWorldPosition(pFixed);

        const rVec = new THREE.Vector3().subVectors(pBeam, pFixed);
        let r = rVec.length();
        // Clamp min physics distance
        if(r < 2.5) r = 2.5; 

        // Coulomb Force: F = k * q1 * q2 / r^2
        let force = (config.k * config.charge1 * config.charge2) / (r * r);
        
        // Torque Calculation
        const forceDir = rVec.normalize();
        
        // Tangent vector for torque
        const tangent = new THREE.Vector3(-Math.sin(config.angle), 0, Math.cos(config.angle));
        
        // Effective Force Component
        const forceTan = forceDir.dot(tangent) * force;
        const torqueElec = forceTan * 10; // Radius = 10

        // Spring Torque 
        const torqueSpring = -config.torsionK * config.angle;

        // Damping
        const torqueDamp = -config.damping * config.velocity * 100;

        const netTorque = torqueElec + torqueSpring + torqueDamp;

        config.velocity += netTorque * 0.001; 
        config.angle += config.velocity;

        // --- PHYSICS CLAMP ---
        // Prevent rotation past ~120 degrees (2.1 rad) to avoid vector flipping
        if (config.angle > 2.1) {
            config.angle = 2.1;
            config.velocity = 0;
        }
        if (config.angle < -0.2) {
            config.angle = -0.2;
            config.velocity = 0;
        }
        // ---------------------

        torsionGroup.rotation.y = config.angle;

        // 3. Visuals
        updateMaterial(sphereFixed, config.charge1);
        updateMaterial(sphereBeam, config.charge2);

        if (Math.abs(force) > 0.5) {
            forceLine.visible = true;
            const pts = forceLine.geometry.attributes.position.array;
            pts[0] = pBeam.x; pts[1] = pBeam.y; pts[2] = pBeam.z;
            pts[3] = pFixed.x; pts[4] = pFixed.y; pts[5] = pFixed.z;
            forceLine.geometry.attributes.position.needsUpdate = true;
            forceLine.computeLineDistances();
        } else {
            forceLine.visible = false;
        }

        // 4. Update UI Data
        document.getElementById('disp-torque').innerText = Math.abs(torqueElec).toFixed(2) + " Nm";
        document.getElementById('disp-angle').innerText = (config.angle * (180/Math.PI)).toFixed(1) + "°";

        renderer.render(scene, camera);
        checkAdvance();
    }

    // ==========================================
    // PART 4: CONTROL LOGIC
    // ==========================================

    const slQ1 = document.getElementById('slider-q1');
    const slQ2 = document.getElementById('slider-q2');
    const slDist = document.getElementById('slider-dist');

    slQ1.addEventListener('input', (e) => {
        config.charge1 = parseFloat(e.target.value);
        document.getElementById('val-q1').innerText = config.charge1 + " µC";
    });
    slQ2.addEventListener('input', (e) => {
        config.charge2 = parseFloat(e.target.value);
        document.getElementById('val-q2').innerText = config.charge2 + " µC";
    });
    slDist.addEventListener('input', (e) => {
        config.distance = parseFloat(e.target.value);
        document.getElementById('val-dist').innerText = config.distance + " cm";
    });

    window.addEventListener('resize', () => {
        aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        camera.left = -viewSize * aspect / 2;
        camera.right = viewSize * aspect / 2;
        camera.top = viewSize / 2;
        camera.bottom = -viewSize / 2;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
    });

    function resetSim() {
        config.charge1 = 0;
        config.charge2 = 0;
        config.distance = 21; 
        config.angle = 0;
        config.velocity = 0;
        
        slQ1.value = 0; slQ1.dispatchEvent(new Event('input'));
        slQ2.value = 0; slQ2.dispatchEvent(new Event('input'));
        slDist.value = 21; slDist.dispatchEvent(new Event('input'));

        loadLesson(0);
    }

    function loadLesson(idx) {
        currentChapter = idx;
        const l = lessons[idx];
        document.querySelector('header .subtitle').innerText = `Step ${idx+1} of ${lessons.length}`;
        document.getElementById('chapter-content').innerHTML = 
            `<div class="chapter-title">${l.title}</div>
             <div class="story-text">${l.text}</div>`;
        
        const btn = document.getElementById('btn-next');
        
        if (currentChapter === lessons.length -1) {
            btn.innerHTML = "Experiment Complete";
            // btn.disabled = true; // Optional: Keep enabled if they want to just look at it
        } else {
            btn.innerHTML = "Next &rarr;";
            btn.disabled = !l.check();
        }
        
        l.setup();
    }

    function nextLesson() {
        if(currentChapter < lessons.length - 1) loadLesson(currentChapter + 1);
    }
    function prevLesson() {
        if(currentChapter > 0) loadLesson(currentChapter - 1);
    }

    loadLesson(0);
    animate();

</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Triboelectricity: The Static Spark</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT (Identical to previous) --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43; /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
            --electron: #00d2d3; /* Cyan */
            --proton: #ff6b6b;    /* Red */
        }

    body { margin: 0; height: 100vh; display: flex; background: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; overflow: hidden; }

    aside {
        width: 450px;
        background: var(--panel);
        border-right: 1px solid var(--border);
        display: flex;
        flex-direction: column;
        box-shadow: 10px 0 30px rgba(0,0,0,0.5);
        z-index: 10;
    }

    header { padding: 25px; border-bottom: 1px solid var(--border); background: rgba(0,0,0,0.2); }
    h1 { margin: 0; font-size: 22px; color: var(--accent); text-transform: uppercase; letter-spacing: 2px; }
    .subtitle { font-size: 13px; color: #777; margin-top: 5px; font-style: italic; }

    #story-container { flex: 1; padding: 30px; overflow-y: auto; display: flex; flex-direction: column; }
    .chapter-title { font-size: 26px; font-weight: 300; color: #fff; margin-bottom: 20px; border-left: 4px solid var(--accent); padding-left: 15px; }
    
    .story-text { line-height: 1.8; font-size: 16px; color: #ccc; margin-bottom: 20px; text-align: justify; }
    .story-text strong { color: #fff; font-weight: 600; }
    .instruction-inline { color: var(--accent); font-weight: bold; border-bottom: 1px dotted var(--accent); }
    .example-box { background: #252525; padding: 15px; border-left: 2px solid #555; margin: 15px 0; font-size: 14px; }

    /* CONTROLS AREA */
    #controls-area { background: #181818; padding: 25px; border-top: 1px solid var(--border); }
    .control-row { margin-bottom: 20px; opacity: 0.5; pointer-events: none; transition: 0.3s; filter: grayscale(1); position: relative; }
    .control-row.active { opacity: 1; pointer-events: all; filter: grayscale(0); }
    
    label { display: block; font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }

    button {
        background: #333; color: #aaa; border: 1px solid #444;
        padding: 12px 15px; cursor: pointer; border-radius: 4px;
        font-size: 13px; transition: all 0.2s; width: 100%;
        text-transform: uppercase; font-weight: bold;
    }
    button:hover { background: #444; color: #fff; }

    input[type=range] { width: 100%; accent-color: var(--accent); cursor: pointer; }

    #nav-footer { padding: 20px; display: flex; justify-content: space-between; border-top: 1px solid var(--border); background: #222; }
    .nav-btn { width: 48%; background: #333; color: #fff; border: none; }
    .nav-btn.next { background: var(--accent); color: #151515; }
    .nav-btn.next:hover { background: var(--accent-hover); color: #000; }
    .nav-btn.next:disabled { background: #333; color: #555; cursor: not-allowed; opacity: 0.5; }

    main { flex: 1; position: relative; background: #151515; overflow: hidden; }
    
    /* Stats Overlay */
    #stats-overlay {
        position: absolute; top: 20px; right: 20px;
        background: rgba(0,0,0,0.6); padding: 15px; border-radius: 4px;
        font-family: monospace; font-size: 12px; pointer-events: none;
    }
    .stat-line { display: flex; justify-content: space-between; width: 180px; margin-bottom: 5px; }
    .val-elec { color: var(--electron); }
    .val-prot { color: var(--proton); }

</style>

</head>
<body>

    <aside>
    <header>
        <h1>Triboelectric Effect</h1>
        <div class="subtitle">Friction & Charge Transfer</div>
    </header>

    <div id="story-container">
        <div id="chapter-content">
            <!-- Content injected by JS -->
        </div>
    </div>

    <div id="controls-area">
        <!-- 1. Grab Comb -->
        <div class="control-row" id="ctrl-tool">
            <label>Action 1: Preparation</label>
            <button id="btn-tool" onclick="equipComb()">Pick Up Plastic Comb</button>
        </div>

        <!-- 2. Slider -->
        <div class="control-row" id="ctrl-rub">
            <label>Action 2: Apply Friction</label>
            <input type="range" id="slider-rub" min="0" max="100" value="0" step="0.5">
        </div>
        
        <!-- Reset -->
         <div class="control-row" id="ctrl-reset" style="margin-top:10px; border-top:1px solid #333; padding-top:15px;">
            <label>System Control</label>
            <button onclick="resetSim()">Discharge & Reset</button>
        </div>
    </div>

    <div id="nav-footer">
        <button class="nav-btn" onclick="prevLesson()">Back</button>
        <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Continue &rarr;</button>
    </div>
</aside>

<main id="world">
    <div id="stats-overlay">
        <div class="stat-line"><span>HAIR CHARGE:</span> <span id="stat-hair" class="val-prot">NEUTRAL</span></div>
        <div class="stat-line"><span>COMB CHARGE:</span> <span id="stat-comb" class="val-elec">NEUTRAL</span></div>
    </div>
</main>

<script>
    // ==========================================
    // PART 1: ISOMETRIC 3D ENGINE
    // ==========================================
    
    const state = {
        combActive: false,
        frictionLevel: 0, // 0 to 100
        chargeTransferred: 0, // Number of electrons moved
        maxCharge: 80 // Max electrons to move
    };

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x151515);

    // ISOMETRIC CAMERA
    const sidebarWidth = 450;
    const aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
    const d = 18; 
    const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
    
    // Isometric Look
    camera.position.set(20, 20, 20); 
    camera.lookAt(0, -2, 0); // Look slightly down

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.getElementById('world').appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffaa, 0.8);
    dirLight.position.set(10, 20, 5);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // Grid Floor
    const grid = new THREE.GridHelper(50, 50, 0x333333, 0x111111);
    grid.position.y = -8; 
    scene.add(grid);

    // --- CHARACTER MODEL ---
    const charGroup = new THREE.Group();
    scene.add(charGroup);

    // Head
    const headGeo = new THREE.IcosahedronGeometry(3.5, 1);
    const headMat = new THREE.MeshLambertMaterial({ color: 0xffccaa }); // Skin tone
    const head = new THREE.Mesh(headGeo, headMat);
    charGroup.add(head);

    // Shoulders (Context)
    const bodyGeo = new THREE.CylinderGeometry(5, 7, 6, 8);
    const bodyMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = -6;
    charGroup.add(body);

    // --- HAIR SYSTEM ---
    const hairStrands = [];
    const hairCount = 90;
    const hairLength = 3.5;
    
    // Geometry: Translate cylinder so pivot is at base (0,0,0)
    const strandGeo = new THREE.CylinderGeometry(0.05, 0.08, hairLength, 4);
    strandGeo.translate(0, hairLength/2, 0); 
    const strandMat = new THREE.MeshLambertMaterial({ color: 0x5c3a21 }); // Brown hair

    for(let i=0; i<hairCount; i++) {
        // Distribute on top hemisphere
        const phi = Math.acos( -1 + ( 2 * i ) / hairCount ); // latitude
        const theta = Math.sqrt( hairCount * Math.PI ) * phi; // longitude
        
        // Convert spherical to cartesian, but only top half
        const r = 3.4; // Slightly inside head surface
        const y = r * Math.cos(phi);
        
        if(y > 0.5) { // Only top of head
            const x = r * Math.sin(phi) * Math.cos(theta);
            const z = r * Math.sin(phi) * Math.sin(theta);

            const hair = new THREE.Mesh(strandGeo, strandMat.clone());
            hair.position.set(x, y, z);
            
            // Orient hair to face outward initially
            const target = new THREE.Vector3(x*2, y*2, z*2);
            hair.lookAt(target);
            hair.rotateX(Math.PI / 2); // Fix cylinder orientation
            
            // Store initial rotation for animation
            hair.userData = { 
                baseQuat: hair.quaternion.clone(),
                normal: new THREE.Vector3(x, y, z).normalize(),
                hasElectron: true,
                electronMesh: null
            };

            charGroup.add(hair);
            hairStrands.push(hair);
        }
    }

    // --- ELECTRONS & PROTONS ---
    const electronGeo = new THREE.SphereGeometry(0.15, 6, 6);
    const electronMat = new THREE.MeshBasicMaterial({ color: 0x00d2d3 });
    const protonMat = new THREE.MeshBasicMaterial({ color: 0xff6b6b });

    // Add electrons to hair
    hairStrands.forEach(hair => {
        const elec = new THREE.Mesh(electronGeo, electronMat);
        elec.position.set(0, hairLength, 0); // Tip of hair
        hair.add(elec);
        hair.userData.electronMesh = elec;
        
        // Add a proton at the base (invisible core charge)
        const prot = new THREE.Mesh(electronGeo, protonMat);
        prot.position.set(0, 0.2, 0);
        prot.visible = false; // Reveal later
        hair.add(prot);
        hair.userData.protonMesh = prot;
    });

    // --- COMB MODEL ---
    const combGroup = new THREE.Group();
    const combBaseGeo = new THREE.BoxGeometry(8, 1, 0.5);
    const combMat = new THREE.MeshPhongMaterial({ color: 0xaaaaaa, shininess: 80 }); // Plastic
    const combBase = new THREE.Mesh(combBaseGeo, combMat);
    combGroup.add(combBase);

    // Teeth
    for(let i = -3.5; i <= 3.5; i+=0.4) {
        const tooth = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.5, 0.5), combMat);
        tooth.position.set(i, -1.2, 0);
        combGroup.add(tooth);
    }
    
    // Comb visual location
    combGroup.position.set(10, 8, 0); // Start away
    combGroup.rotation.z = -Math.PI / 6;
    scene.add(combGroup);

    // Stolen Electrons Container (on the comb)
    const stolenElectrons = [];


    // ==========================================
    // PART 2: PHYSICS & ANIMATION
    // ==========================================
    
    let time = 0;

    function animate() {
        requestAnimationFrame(animate);
        time += 0.05;

        // 1. COMB ANIMATION (Controlled by Slider)
        if(state.combActive) {
            // Lerp target position based on friction slider
            // If slider is 0: Hover above
            // If slider > 0: Rub back and forth
            
            const intensity = state.frictionLevel / 100;
            
            const hoverX = 0; 
            const hoverY = 7;
            
            // Rubbing motion
            const rubX = Math.sin(time * 5) * 4; 
            const rubY = 5 + Math.cos(time * 10) * 0.5;
            
            // Blend between Hover and Rub
            const targetX = hoverX + (rubX * intensity);
            const targetY = hoverY - (2 * intensity) + (Math.cos(time*10)*0.5*intensity);

            combGroup.position.lerp(new THREE.Vector3(targetX, targetY, 0), 0.1);
            combGroup.rotation.z = -Math.PI/6 + Math.sin(time*5)*0.2*intensity;

            // CHARGE TRANSFER LOGIC
            // Only transfer if friction level is high enough and moving
            if(state.frictionLevel > 10 && state.chargeTransferred < state.maxCharge) {
                // Rate of transfer proportional to friction
                if(Math.random() < (state.frictionLevel/300)) {
                    stealElectron();
                }
            }
        } else {
            // Hide comb
            combGroup.position.lerp(new THREE.Vector3(20, 10, 0), 0.05);
        }

        // 2. HAIR PHYSICS (Repulsion)
        // The more charge transferred, the more the hair stands up
        const chargeRatio = state.chargeTransferred / state.maxCharge;

        hairStrands.forEach((hair, idx) => {
            // Basic idle sway
            const sway = Math.sin(time + idx) * 0.05;
            
            // Repulsion Vector calculation
            // If charged (lost electron), hair wants to align with Normal vector (stand straight up)
            // If neutral, hair falls slightly due to gravity (simulated by rotating down)
            
            const startQ = hair.userData.baseQuat;
            
            // Calculate "Standing Up" Quaternion (aligned with normal)
            // Actually, baseQuat IS the normal alignment.
            // So we want to add "gravity" when neutral, and remove it when charged.
            
            // Artificial Gravity rotation (droop)
            const gravityAxis = new THREE.Vector3(1, 0, 0); // Local axis approximation
            
            // 0 charge = lots of droop. 1 charge = 0 droop (rigid standing).
            const droopFactor = 1.0 - (chargeRatio * 0.9); 
            
            // Apply droop manually? 
            // Easier approach: Reset to base, then apply rotation based on state.
            hair.quaternion.copy(startQ);
            
            // Add sway
            hair.rotateX(sway * 0.5); 
            
            // Gravity effect: rotate 'down' relative to head? 
            // A simple approximation: spread outward more when charged.
            
            // Divergence effect (Repulsion):
            // Rotate hairs away from each other. Since they are on a sphere, 
            // the normal is the divergence direction.
            // Let's create a "random" messiness that straightens out into a "porcupine" shape when charged.
            
            if(chargeRatio > 0.1) {
                // Jitter decreases, alignment to normal increases
                // Visual effect: Hair stands stiff
                hair.rotateZ(Math.sin(time*10 + idx)*0.02 * chargeRatio); // Static vibration
            } else {
                // Relaxed hair
                hair.rotateX(0.5); // Droop down
            }
        });
        
        // 3. ELECTRON UPDATE (Stolen ones)
        stolenElectrons.forEach(elec => {
            // Stick them to the comb relative surface
            // We just let them ride the combGroup hierarchy, but we can jitter them
            elec.position.y += Math.sin(time * 20) * 0.001;
        });

        updateUI();
        renderer.render(scene, camera);
    }

    function stealElectron() {
        // Find a hair that still has an electron
        const availableHairs = hairStrands.filter(h => h.userData.hasElectron);
        if(availableHairs.length === 0) return;

        const victimHair = availableHairs[Math.floor(Math.random() * availableHairs.length)];
        
        // Logic Update
        victimHair.userData.hasElectron = false;
        state.chargeTransferred++;
        
        // Visual Transfer
        const electronMesh = victimHair.userData.electronMesh;
        const protonMesh = victimHair.userData.protonMesh;
        
        // 1. Reveal Proton on Hair (Hair becomes positive)
        protonMesh.visible = true;
        
        // 2. Move Electron to Comb
        // We detach electron from hair and attach to comb.
        // Needs coordinate transformation
        
        const worldPos = new THREE.Vector3();
        electronMesh.getWorldPosition(worldPos);
        
        victimHair.remove(electronMesh); // Remove from hair
        combGroup.add(electronMesh);     // Add to comb
        
        // Convert worldPos to Comb's local space
        combGroup.worldToLocal(worldPos);
        electronMesh.position.copy(worldPos);
        
        // Lerp to a random spot on the comb "teeth"
        const targetX = (Math.random() - 0.5) * 7;
        const targetY = -0.5 - Math.random(); // On the teeth
        
        // Animate the travel (simple GSAP-like approach manually)
        const travelAnim = () => {
            electronMesh.position.lerp(new THREE.Vector3(targetX, targetY, 0.25), 0.1);
            if(electronMesh.position.distanceTo(new THREE.Vector3(targetX, targetY, 0.25)) > 0.1) {
                requestAnimationFrame(travelAnim);
            }
        };
        travelAnim();

        stolenElectrons.push(electronMesh);
        checkAdvance();
    }
    
    function updateUI() {
        const hVal = document.getElementById('stat-hair');
        const cVal = document.getElementById('stat-comb');
        
        if(state.chargeTransferred === 0) {
            hVal.innerText = "NEUTRAL"; hVal.style.color = "#ccc";
            cVal.innerText = "NEUTRAL"; cVal.style.color = "#ccc";
        } else {
            hVal.innerText = "+" + state.chargeTransferred + " e";
            hVal.style.color = "var(--proton)";
            
            cVal.innerText = "-" + state.chargeTransferred + " e";
            cVal.style.color = "var(--electron)";
        }
    }

    animate();


    // ==========================================
    // PART 3: STORY & LOGIC
    // ==========================================

    function equipComb() {
        state.combActive = true;
        document.getElementById('btn-tool').innerText = "Comb Equipped";
        document.getElementById('btn-tool').disabled = true;
        checkAdvance();
    }

    document.getElementById('slider-rub').addEventListener('input', (e) => {
        state.frictionLevel = parseFloat(e.target.value);
        checkAdvance();
    });

    function resetSim() {
        // Reset Logic
        state.combActive = false;
        state.frictionLevel = 0;
        state.chargeTransferred = 0;
        document.getElementById('slider-rub').value = 0;
        document.getElementById('btn-tool').disabled = false;
        document.getElementById('btn-tool').innerText = "Pick Up Plastic Comb";

        // Reset Meshes
        stolenElectrons.forEach(e => combGroup.remove(e));
        stolenElectrons.length = 0;

        hairStrands.forEach(hair => {
            hair.userData.hasElectron = true;
            hair.userData.protonMesh.visible = false;
            // Re-add electron mesh
            const newElec = new THREE.Mesh(electronGeo, electronMat);
            newElec.position.set(0, hairLength, 0);
            hair.add(newElec);
            hair.userData.electronMesh = newElec;
        });

        loadLesson(0);
    }

    // --- NARRATIVE ENGINE ---
    
    let currentChapter = 0;

    const lessons = [
        {
            title: "Phase 1: Neutral Harmony",
            text: "Here we have a typical human head and a plastic comb. Initially, both materials are electrically <strong>Neutral</strong>. <br><br>The hair has an equal number of protons (positive) and electrons (negative). The net charge is zero, so the hair behaves normally, resting due to gravity.<br><br><span class='instruction-inline'>Click 'PICK UP COMB'</span> to introduce the insulator.",
            setup: () => {
                lockAll();
                unlock('ctrl-tool');
            },
            check: () => state.combActive
        },
        {
            title: "Phase 2: The Triboelectric Effect",
            text: "When two different materials touch and rub, electrons may transfer. This is the <strong>Triboelectric Effect</strong>.<br><br>Plastic has a higher 'Electron Affinity' than human hair. It is greedy. It wants to steal electrons.<br><br><span class='instruction-inline'>Drag the Friction Slider to ~50%</span> to vigorously rub the comb against the hair.",
            setup: () => {
                unlock('ctrl-rub');
            },
            check: () => state.frictionLevel > 40
        },
        {
            title: "Phase 3: Electron Theft",
            text: "Observe the particles! As friction increases, the plastic comb rips electrons (Cyan) off the hair strands.<br><br><strong>Conservation of Charge:</strong> The electrons aren't created; they just moved. The comb is becoming negatively charged (-), while the hair—having lost electrons—is left with a net positive charge (Red Protons).<br><br>The hair strands now <strong>repel each other</strong> because they share the same positive charge, overcoming gravity to stand up.",
            setup: () => {
                 document.getElementById('ctrl-reset').classList.add('active');
            },
            // Just need a little bit of transfer to prove the point, no hard grinding required.
            check: () => state.chargeTransferred > 5
        },
        {
            title: "Phase 4: Real World Examples",
            text: "The Triboelectric Effect is contact-induced electrification. It happens everywhere, not just with combs.<br><br>Examples from the <strong>Triboelectric Series</strong>:<br><div class='example-box'>1. <strong>Glass (+) & Silk (-):</strong> Rubbing glass with silk makes the glass positive.<br>2. <strong>Shoes & Carpet:</strong> Rubber soles steal electrons from wool carpets.</div><br>It is all about which material has the stronger 'hunger' for electrons.",
            setup: () => {
               // Informational slide
            },
            check: () => true
        },
        {
            title: "History: From Sparks to Science",
            text: "We have observed that charge creates a force (repulsion). But <em>precisely</em> how strong is that force?<br><br>In 1785, the French physicist <strong>Charles-Augustin de Coulomb</strong> sought to answer this. He suspected the force depended on the amount of charge and the distance between objects.<br><br>To prove it, he built a sensitive device called the <strong>Torsion Balance</strong>. Next, we will leave the comb behind and step into his lab to discover the mathematical equation of charges.",
            setup: () => {
                lockAll();
            },
            check: () => true
        }
    ];

    function loadLesson(idx) {
        currentChapter = idx;
        const l = lessons[idx];
        document.querySelector('header .subtitle').innerText = `Stage ${idx+1} of ${lessons.length}`;
        document.getElementById('chapter-content').innerHTML = 
            `<div class="chapter-title">${l.title}</div>
             <div class="story-text">${l.text}</div>`;
        
        const btn = document.getElementById('btn-next');
        
        // If the check returns true immediately (informational slide), enable button
        if(l.check()) {
            btn.disabled = false;
        } else {
            btn.disabled = true;
        }

        if(idx === lessons.length - 1) {
            btn.innerText = "Proceed to Coulomb's Law";
        } else {
            btn.innerText = "Continue →";
            btn.style.display = 'inline-block';
        }
        
        l.setup();
    }

    function nextLesson() {
        if(currentChapter < lessons.length - 1) {
            loadLesson(currentChapter + 1);
        } else {
            alert("End of Module 1. Loading Module 2: Coulomb's Torsion Balance...");
            // In a real app, this would be: window.location.href = 'coulomb.html';
        }
    }
    function prevLesson() {
        if(currentChapter > 0) loadLesson(currentChapter - 1);
    }
    function checkAdvance() {
        if(lessons[currentChapter].check()) {
            document.getElementById('btn-next').disabled = false;
        }
    }
    
    function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
    function unlock(id) { document.getElementById(id).classList.add('active'); }

    // Init
    loadLesson(0);
    
    // Responsive
    window.addEventListener('resize', () => {
        const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        camera.left = -d * newAspect;
        camera.right = d * newAspect;
        camera.top = d;
        camera.bottom = -d;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
    });

</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>The Dance of Electrons: Induction (Low Poly)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #0f1014;
            --panel: #181a1f;
            --text: #e0e6ed;
            --accent: #ff9f43; /* Warm Orange */
            --accent-hover: #ffb773;
            --border: #2c313a;
            --electron: #00d2d3; /* Cyan */
            --proton: #ff6b6b;    /* Red */
        }

        body { margin: 0; height: 100vh; display: flex; background: var(--bg); color: var(--text); font-family: 'Segoe UI', Roboto, Helvetica, sans-serif; overflow: hidden; }

        /* LEFT PANEL */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0,0,0,0.6);
            z-index: 10;
        }

        header { padding: 25px; border-bottom: 1px solid var(--border); background: rgba(0,0,0,0.1); }
        h1 { margin: 0; font-size: 22px; color: var(--accent); text-transform: uppercase; letter-spacing: 2px; font-weight: 700; }
        .subtitle { font-size: 13px; color: #8892b0; margin-top: 5px; font-style: italic; }

        #story-container { flex: 1; padding: 30px; overflow-y: auto; display: flex; flex-direction: column; }
        
        .chapter-title { 
            font-size: 20px; 
            font-weight: 600; 
            color: #fff; 
            margin-bottom: 15px; 
            border-left: 4px solid var(--accent); 
            padding-left: 15px; 
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .story-text { 
            line-height: 1.8; 
            font-size: 15px; 
            color: #bdc3c7; 
            margin-bottom: 20px; 
        }
        
        .story-text strong { color: #fff; font-weight: 600; }
        .instruction-inline { color: var(--accent); font-weight: bold; background: rgba(255, 159, 67, 0.1); padding: 2px 5px; border-radius: 4px; }
        
        .highlight-elec { color: var(--electron); font-weight: bold; }

        /* CONTROLS AREA */
        #controls-area { background: #131519; padding: 25px; border-top: 1px solid var(--border); }
        .control-row { margin-bottom: 20px; opacity: 0.4; pointer-events: none; transition: 0.4s; filter: grayscale(1); position: relative; }
        .control-row.active { opacity: 1; pointer-events: all; filter: grayscale(0); }
        
        label { display: block; font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px; font-weight: 700; }

        button {
            background: #2c313a; color: #aaa; border: 1px solid #3d4450;
            padding: 12px 15px; cursor: pointer; border-radius: 6px;
            font-size: 13px; transition: all 0.2s; width: 100%;
            text-transform: uppercase; font-weight: bold; letter-spacing: 0.5px;
        }
        button:hover { background: #3d4450; color: #fff; border-color: #555; }
        button:active { transform: translateY(1px); }

        input[type=range] { width: 100%; accent-color: var(--accent); cursor: pointer; height: 6px; background: #333; border-radius: 3px; }

        /* LIMIT MARKER */
        #limit-marker {
            position: absolute;
            bottom: -8px; 
            left: 55%; 
            width: 2px;
            height: 20px;
            background: #ff5252;
            display: none; 
            z-index: 5;
            box-shadow: 0 0 5px #ff5252;
        }
        #limit-marker::after {
            content: "STOP";
            position: absolute;
            top: 100%;
            left: -12px;
            font-size: 10px;
            color: #ff5252;
            font-weight: bold;
            margin-top: 2px;
        }

        /* NAVIGATION FOOTER */
        #nav-footer { padding: 20px 25px; display: flex; justify-content: space-between; border-top: 1px solid var(--border); background: #111; }
        .nav-btn { width: 48%; background: #222; color: #fff; border: none; }
        .nav-btn.next { background: var(--accent); color: #151515; font-weight: 800; }
        .nav-btn.next:hover { background: var(--accent-hover); color: #000; box-shadow: 0 0 15px rgba(255, 159, 67, 0.4); }
        .nav-btn.next:disabled { background: #222; color: #555; cursor: not-allowed; opacity: 0.5; box-shadow: none; }

        /* MAIN CANVAS */
        main { flex: 1; position: relative; background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%); overflow: hidden; }
        
        /* FLASH OVERLAY */
        #flash-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: white; opacity: 0; pointer-events: none;
            transition: opacity 0.1s ease-out;
            z-index: 100;
        }

        /* TAGS IN SCENE */
        .scene-tag {
            position: absolute;
            color: rgba(255,255,255,0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }

    </style>
</head>
<body>

    <aside>
        <header>
            <h1>Franklin's Lab</h1>
            <div class="subtitle">Simulation: The Metallic Sea</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- 1. Bring Rod -->
            <div class="control-row" id="ctrl-rod">
                <label>Step 1: The Intruder</label>
                <button id="btn-rod" onclick="toggleRod()">Introduce Charged Rod</button>
            </div>

            <!-- 2. Slider -->
            <div class="control-row" id="ctrl-move">
                <label>Step 2: Proximity Control</label>
                <input type="range" id="slider-dist" min="0" max="100" value="0" step="1">
                <div id="limit-marker"></div>
            </div>
            
            <!-- Reset -->
             <div class="control-row" id="ctrl-reset" style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Experiment Control</label>
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div id="flash-overlay"></div>
        <div class="scene-tag" style="top: 20px; right: 20px;">Microscopic View: x10,000,000</div>
    </main>

   <script>
    // ==========================================
    // PART 1: THE 3D ENGINE
    // ==========================================
    
    const state = {
        rodVisible: false,
        rodPosPercent: 0,
        hasTouched: false,
        theta: 0,
        omega: 0,
    };

    const scene = new THREE.Scene();

    const sidebarWidth = 420;
    let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
    const viewSize = 35; 
    
    const camera = new THREE.OrthographicCamera(
        -viewSize * aspect / 2, viewSize * aspect / 2,
        viewSize / 2, -viewSize / 2,
        1, 1000
    );

    camera.position.set(20, 25, 20); // Higher angle to see the floor better
    camera.lookAt(0, -5, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
    document.getElementById('world').appendChild(renderer.domElement);

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(10, 30, 15);
    dirLight.castShadow = true;
    
    // Shadow properties for clean lines
    dirLight.shadow.mapSize.width = 1024;
    dirLight.shadow.mapSize.height = 1024;
    dirLight.shadow.camera.near = 0.5;
    dirLight.shadow.camera.far = 100;
    const d = 30;
    dirLight.shadow.camera.left = -d;
    dirLight.shadow.camera.right = d;
    dirLight.shadow.camera.top = d;
    dirLight.shadow.camera.bottom = -d;
    
    scene.add(dirLight);

    // --- NEW: TILED FLOOR GENERATION ---
    function createTileTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');

        // Background (Tile color)
        ctx.fillStyle = '#1e2126';
        ctx.fillRect(0, 0, 512, 512);

        // Grid lines (Grout)
        ctx.strokeStyle = '#111316';
        ctx.lineWidth = 16;
        
        // Draw 2x2 grid on the texture
        ctx.beginPath();
        // Middle vertical
        ctx.moveTo(256, 0); ctx.lineTo(256, 512);
        // Middle horizontal
        ctx.moveTo(0, 256); ctx.lineTo(512, 256);
        // Borders
        ctx.strokeRect(0, 0, 512, 512);
        ctx.stroke();

        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(20, 20); // Repeat 20 times across the floor
        
        return tex;
    }

    const floorGeo = new THREE.PlaneGeometry(120, 120);
    const floorMat = new THREE.MeshStandardMaterial({ 
        map: createTileTexture(),
        roughness: 0.8,
        metalness: 0.2
    });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -18; 
    floor.receiveShadow = true;
    scene.add(floor);


    // --- HELPER: TEXTURE GENERATOR ---
    function createSignTexture(symbol) {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        // Transparent background
        ctx.fillStyle = 'rgba(255,255,255,1)';
        ctx.font = 'bold 60px Arial';
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(symbol, 32, 34);
        return new THREE.CanvasTexture(canvas);
    }

    // --- THE BALLOON SYSTEM (LOW POLY) ---
    const anchorPoint = new THREE.Vector3(0, -10, 0); 
    const stringLength = 16;
    const balloonRadius = 3.0;

    // String (Reduced segments)
    const stringGeo = new THREE.CylinderGeometry(0.08, 0.08, 1, 4); // 4 sides = rectangular string
    const stringMat = new THREE.MeshStandardMaterial({color: 0x888888, flatShading: true});
    const stringMesh = new THREE.Mesh(stringGeo, stringMat);
    stringMesh.castShadow = true;
    scene.add(stringMesh);

    // Balloon Group 
    const balloonGroup = new THREE.Group();
    scene.add(balloonGroup);

    // The Sphere (LOW POLY: Reduced segments 32->10 and 32->6)
    const balloonGeo = new THREE.SphereGeometry(balloonRadius, 10, 6);
    const balloonMat = new THREE.MeshPhongMaterial({
        color: 0x555555, // Metallic grey
        transparent: true, 
        opacity: 0.2,
        shininess: 60,
        specular: 0xffffff,
        side: THREE.DoubleSide,
        flatShading: true // THE KEY TO LOW POLY LOOK
    });
    const balloonMesh = new THREE.Mesh(balloonGeo, balloonMat);
    balloonMesh.castShadow = true;
    balloonGroup.add(balloonMesh);

    // Balloon Sign
    const balloonSignTex = createSignTexture("-");
    const balloonSignMat = new THREE.MeshBasicMaterial({map: balloonSignTex, transparent:true, side: THREE.DoubleSide, depthTest: false});
    const balloonSignMesh = new THREE.Mesh(new THREE.PlaneGeometry(2,2), balloonSignMat);
    balloonSignMesh.position.set(0, 4.5, 0);
    balloonSignMesh.rotation.y = Math.PI / 4; 
    balloonSignMesh.visible = false;
    balloonGroup.add(balloonSignMesh);


    // Inner Nuclei (Static Positive Cores - LOW POLY)
    const nucleiGroup = new THREE.Group();
    // Icosahedron is nicer for small low poly particles than a sphere
    const nucGeo = new THREE.IcosahedronGeometry(0.35, 0); 
    const nucMat = new THREE.MeshBasicMaterial({color: 0xff6b6b}); // Bright Red
    for(let i=0; i<12; i++) {
        const m = new THREE.Mesh(nucGeo, nucMat);
        m.position.set((Math.random()-0.5)*4, (Math.random()-0.5)*4, (Math.random()-0.5)*4);
        nucleiGroup.add(m);
    }
    balloonGroup.add(nucleiGroup);

    // Wireframe (Optional, but looks cool in low poly)
    const wireGeo = new THREE.WireframeGeometry(balloonGeo);
    const wireMat = new THREE.LineBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.1 });
    const wireframe = new THREE.LineSegments(wireGeo, wireMat);
    balloonMesh.add(wireframe);

    // --- THE ELECTRON SEA (LOW POLY PARTICLES) ---
    const particleCount = 150; // Slightly fewer for cleaner look
    const electrons = [];
    // Icosahedron for sharp edges on particles
    const elecGeo = new THREE.IcosahedronGeometry(0.15, 0);
    const elecMat = new THREE.MeshBasicMaterial({ color: 0x00d2d3 }); 

    for(let i=0; i<particleCount; i++) {
        const mesh = new THREE.Mesh(elecGeo, elecMat);
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        const r = Math.cbrt(Math.random()) * (balloonRadius * 0.9);
        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);
        const basePos = new THREE.Vector3(x, y, z);
        
        mesh.position.copy(basePos);
        balloonGroup.add(mesh);
        electrons.push({ mesh: mesh, basePos: basePos });
    }

    // --- TRANSFER ELECTRONS (For Animation) ---
    const transferParticles = [];
    function spawnTransferParticles(startPos) {
        for(let i=0; i<40; i++) {
            const mesh = new THREE.Mesh(elecGeo, elecMat);
            mesh.position.copy(startPos);
            mesh.position.x += (Math.random()-0.5)*1.5;
            mesh.position.y += (Math.random()-0.5)*1.5;
            mesh.position.z += (Math.random()-0.5)*1.5;
            
            const target = new THREE.Vector3(
                (Math.random()-0.5)*3, 
                (Math.random()-0.5)*3, 
                (Math.random()-0.5)*3
            ); 
            
            scene.add(mesh);
            transferParticles.push({
                mesh: mesh,
                targetLocal: target,
                progress: 0,
                speed: 0.03 + Math.random() * 0.04
            });
        }
    }

    // --- THE ROD (LOW POLY) ---
    const rodGroup = new THREE.Group();
    // Cylinder with only 6 radial segments (Hexagonal prism)
    const rodGeo = new THREE.CylinderGeometry(0.7, 0.7, 10, 6);
    rodGeo.rotateZ(Math.PI / 2);
    const rodMat = new THREE.MeshStandardMaterial({ 
        color: 0xcc4444, 
        roughness: 0.4, 
        metalness: 0.1,
        flatShading: true // Faceted look
    });
    const rodMesh = new THREE.Mesh(rodGeo, rodMat);
    rodMesh.castShadow = true;
    rodGroup.add(rodMesh);
    
    // Add "-" signs to rod
    const rodSignTex = createSignTexture("-");
    const rodSignMat = new THREE.MeshBasicMaterial({map: rodSignTex, transparent:true, side: THREE.DoubleSide});
    for(let i=-4; i<=4; i+=1.2) {
        const sign = new THREE.Mesh(new THREE.PlaneGeometry(0.7,0.7), rodSignMat);
        sign.position.set(i, 0.8, 0); // slightly higher due to hex shape
        sign.rotation.x = -Math.PI/3;
        rodGroup.add(sign);
    }

    rodGroup.position.set(-100, 0, 0); 
    scene.add(rodGroup);


    // ==========================================
    // PART 2: PHYSICS & SIMULATION LOOP
    // ==========================================
    
    function animate() {
        requestAnimationFrame(animate);

        // 1. ROD MOTION
        const minX = -30;
        const maxX = -3; 
        const targetRodX = minX + (state.rodPosPercent / 100) * (maxX - minX);
        
        if(state.rodVisible) {
            rodGroup.visible = true;
            rodGroup.position.x += (targetRodX - rodGroup.position.x) * 0.1;
            rodGroup.position.y = balloonGroup.position.y;
        } else {
            rodGroup.visible = false;
            rodGroup.position.x = -100; 
        }

        // 2. CALCULATE DISTANCE & PHYSICS
        const rodTipX = rodGroup.position.x + 5; 
        const balloonX = balloonGroup.position.x;
        const dist = Math.abs(rodTipX - balloonX);

        if(state.rodVisible && dist < 3.2 && !state.hasTouched) {
            triggerContact();
        }

        let electricForce = 0; 
        if(state.rodVisible) {
            if(!state.hasTouched) {
                // INDUCTION (Attraction)
                electricForce = -200 / (dist * dist + 10); 
            } else {
                // CONDUCTION (Repulsion)
                electricForce = 800 / (dist * dist + 5);
            }
        }

        // 3. ELECTRON BEHAVIOR
        const rodTipWorld = new THREE.Vector3(rodTipX, rodGroup.position.y, 0);
        
        electrons.forEach(elec => {
            const jitter = new THREE.Vector3((Math.random()-0.5)*0.1, (Math.random()-0.5)*0.1, (Math.random()-0.5)*0.1);
            const elecWorld = elec.mesh.position.clone().add(balloonGroup.position);
            const dirFromRod = new THREE.Vector3().subVectors(elecWorld, rodTipWorld).normalize();
            
            let strength = state.rodVisible ? (150 / (dist*dist + 1)) : 0;
            if(state.hasTouched) strength *= 3; 

            const push = dirFromRod.multiplyScalar(strength * 6);
            const targetPos = new THREE.Vector3().addVectors(elec.basePos, push).add(jitter);
            
            if(targetPos.length() > (balloonRadius * 0.95)) targetPos.setLength(balloonRadius * 0.95);
            elec.mesh.position.lerp(targetPos, 0.1);
        });

        // 4. TRANSFER ANIMATION
        if(transferParticles.length > 0) {
            for(let i = transferParticles.length - 1; i >= 0; i--) {
                const p = transferParticles[i];
                p.progress += p.speed;
                
                // Calculate current world target (balloon moves, so target moves)
                const worldTarget = p.targetLocal.clone().add(balloonGroup.position);
                
                const dir = new THREE.Vector3().subVectors(worldTarget, p.mesh.position);
                
                if(dir.length() < 0.2 || p.progress >= 1) {
                    scene.remove(p.mesh);
                    transferParticles.splice(i, 1);
                } else {
                    p.mesh.position.add(dir.multiplyScalar(0.15));
                }
            }
        }

        // 5. PENDULUM DYNAMICS
        const gravity = 0.5; 
        const restoringTorque = -gravity * 20 * Math.sin(state.theta);
        const electricTorque = electricForce * Math.cos(state.theta) * 0.2;
        const angularAccel = (restoringTorque + electricTorque) * 0.01;
        
        state.omega += angularAccel;
        state.omega *= 0.92;
        state.theta += state.omega;

        const bX = stringLength * Math.sin(state.theta);
        const bY = -10 + stringLength * Math.cos(state.theta);
        balloonGroup.position.set(bX, bY, 0);

        const midX = (0 + bX) / 2;
        const midY = (-10 + bY) / 2;
        stringMesh.position.set(midX, midY, 0);
        const currentLen = Math.sqrt(bX*bX + (bY - (-10))*(bY - (-10)));
        stringMesh.scale.set(1, currentLen, 1);
        stringMesh.rotation.z = -state.theta;

        // 6. VISUAL FEEDBACK
        if(state.hasTouched) {
            // Show the "-" sign
            balloonSignMesh.visible = true;
            // Align sign to face camera
            balloonSignMesh.rotation.copy(camera.rotation); 
            
            balloonMat.emissive.setHex(0x004444);
            wireMat.opacity = 0.5;
        } else {
            balloonSignMesh.visible = false;
            balloonMat.emissive.setHex(0x000000);
            wireMat.opacity = 0.1;
        }

        renderer.render(scene, camera);
    }

    function triggerContact() {
        state.hasTouched = true;
        const flash = document.getElementById('flash-overlay');
        flash.style.opacity = 0.9;
        setTimeout(() => { flash.style.opacity = 0; }, 150);
        
        // Spawn Transfer particles from Rod Tip
        const rodTip = new THREE.Vector3(rodGroup.position.x + 5, rodGroup.position.y, 0);
        spawnTransferParticles(rodTip);

        checkAdvance();
    }

    animate();


    // ==========================================
    // PART 3: NARRATIVE ENGINE
    // ==========================================

    let currentSliderLimit = 100;
    let currentChapter = 0;

    function toggleRod() {
        state.rodVisible = true;
        const btn = document.getElementById('btn-rod');
        btn.innerText = "Rod Active";
        btn.style.borderColor = "#ff9f43";
        btn.style.color = "#ff9f43";
        btn.style.background = "#222"; 
        btn.style.opacity = "0.7";   
        btn.disabled = true;
        checkAdvance();
    }

    document.getElementById('slider-dist').addEventListener('input', (e) => {
        let val = parseFloat(e.target.value);
        if (val > currentSliderLimit) {
            val = currentSliderLimit;
            e.target.value = currentSliderLimit; 
        }
        state.rodPosPercent = val;
        checkAdvance();
    });

    function resetSim() {
        state.rodVisible = false;
        state.rodPosPercent = 0;
        state.hasTouched = false;
        state.theta = 0;
        state.omega = 0;
        
        transferParticles.forEach(p => scene.remove(p.mesh));
        transferParticles.length = 0;

        const slider = document.getElementById('slider-dist');
        slider.value = 0;
        slider.max = 100; 
        
        const btn = document.getElementById('btn-rod');
        btn.disabled = false;
        btn.innerText = "Introduce Charged Rod";
        btn.style.borderColor = "#3d4450";
        btn.style.color = "#aaa";
        btn.style.opacity = "1";
        
        document.getElementById('limit-marker').style.display = 'none';

        loadLesson(0);
    }

    // --- THE LESSONS (Narrative Content) ---

    const lessons = [
        {
            title: "Prologue: The Silent Sea",
            text: "Welcome to the atomic level. You are looking at a metal sphere. <br><br>Observe the <span class='highlight-elec'>Blue Particles</span>. These are free electrons. In a metal, they act like a liquid ocean—constantly moving but evenly distributed. The sphere is currently <strong>Neutral</strong>, meaning the sea is calm.<br><br>To disturb this peace, we need a charge. <span class='instruction-inline'>Click 'INTRODUCE CHARGED ROD'</span>.",
            setup: () => {
                lockAll();
                unlock('ctrl-rod');
                document.getElementById('limit-marker').style.display = 'none';
                currentSliderLimit = 100; 
            },
            check: () => state.rodVisible
        },
        {
            title: "Step 1: The Great Migration (Induction)",
            text: "The Rod is negatively charged. It is an enemy to the electrons.<br><br>As you bring the rod closer, watch the blue ocean. The electrons will flee to the far side of the sphere, leaving the near side exposed and Positive.<br><br><span class='instruction-inline'>Drag the slider</span> to the Red Marker to see this 'Induction' effect.",
            setup: () => {
                unlock('ctrl-move');
                currentSliderLimit = 55;
                document.getElementById('limit-marker').style.display = 'block';
            },
            check: () => state.rodPosPercent >= 50
        },
        {
            title: "Step 2: The Breaking Point (Conduction)",
            text: "Notice the sphere swinging <em>toward</em> the rod? That is attraction. The positive nuclei on the near side are pulling it closer.<br><br>But the tension is too high. If they touch, the dam will break.<br><br><span class='instruction-inline'>Drag the slider past the limit</span> to force contact.",
            setup: () => {
                currentSliderLimit = 100;
                document.getElementById('limit-marker').style.display = 'none';
            },
            check: () => state.hasTouched
        },
        {
            title: "Step 3: The Invisible War (Repulsion)",
            text: "<strong>FLASH!</strong> Did you see the stream of particles? A torrent of electrons just rushed onto the sphere.<br><br>Now, a question you might ask: <em>'The rod is negative and the sphere's nuclei are positive. Shouldn't they still attract?'</em><br><br><strong>The Answer:</strong> The sphere has swallowed such a massive dose of electrons that they <strong>drown out</strong> the positive pull of the nuclei. This new <strong>Net Negative Charge</strong> dominates the force. Since like charges repel, the sphere is violently pushed away.",
            setup: () => {
                // Just observation here
            },
            check: () => true
        },
        {
            title: "Conclusion: The Nature of Materials",
            text: "You have just witnessed <strong>Conduction</strong>. This was possible only because the electrons in the metal were free to move, like water in a pipe.<br><br><strong>But ask yourself:</strong> What if these electrons were frozen? What if they were trapped inside the atoms, unable to flow?<br><br>Next, we will explore <strong>Insulators</strong>, where the invisible fluid turns to ice.",
            setup: () => {
                // Lock controls to signify end of this module
                lockAll(); 
                document.getElementById('ctrl-reset').classList.add('active'); // Only allow reset
                document.getElementById('ctrl-reset').style.opacity = "1";
                document.getElementById('ctrl-reset').style.pointerEvents = "all";
            },
            check: () => false // End of line
        }
    ];

    function loadLesson(idx) {
        currentChapter = idx;
        const l = lessons[idx];
        document.querySelector('header .subtitle').innerText = `Module 1: Metal Induction - Part ${idx+1}`;
        document.getElementById('chapter-content').innerHTML = 
            `<div class="chapter-title">${l.title}</div>
             <div class="story-text">${l.text}</div>`;
        
        const btn = document.getElementById('btn-next');
        
        if (currentChapter === lessons.length -1) {
            btn.innerHTML = "Module Complete";
            btn.disabled = true;
        } else {
            btn.innerHTML = "Next &rarr;";
            if(l.check()) {
                btn.disabled = false;
            } else {
                btn.disabled = true;
            }
        }
        
        l.setup();
    }

    function nextLesson() {
        if(currentChapter < lessons.length - 1) loadLesson(currentChapter + 1);
    }
    function prevLesson() {
        if(currentChapter > 0) loadLesson(currentChapter - 1);
    }
    function checkAdvance() {
        if(currentChapter >= lessons.length - 1) return;

        if(lessons[currentChapter].check()) {
            document.getElementById('btn-next').disabled = false;
        }
    }
    
    function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
    function unlock(id) { document.getElementById(id).classList.add('active'); }

    // Init
    loadLesson(0);

    // Resize Handle
    window.addEventListener('resize', () => {
        const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        camera.left = -viewSize * newAspect / 2;
        camera.right = viewSize * newAspect / 2;
        camera.top = viewSize / 2;
        camera.bottom = -viewSize / 2;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
    });

</script>
</body>
</html>
