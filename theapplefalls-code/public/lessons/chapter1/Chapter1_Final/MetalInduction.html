<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Franklin: The Metallic Sea</title>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME: GALVANI STYLE --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Galvani Orange */
            --accent-hover: #e58e3c;
            --border: #333;
            --electron: #00d2d3;
            /* Cyan for visibility */
            --proton: #ff6b6b;
            /* Red */
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* LEFT PANEL */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        /* HEADER */
        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        /* STORY CONTENT */
        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
        }

        .highlight-elec {
            color: var(--electron);
            font-weight: bold;
        }

        .highlight-nuc {
            color: var(--proton);
            font-weight: bold;
        }

        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
            position: relative;
            /* For limit marker */
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        button:disabled {
            background: #222;
            color: #444;
            cursor: default;
        }

        /* CUSTOM SLIDER for Galvani Theme */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #333;
            border-radius: 2px;
        }

        /* LIMIT MARKER */
        #limit-marker {
            position: absolute;
            bottom: -5px;
            left: 55%;
            width: 2px;
            height: 20px;
            background: #ff5252;
            display: none;
            z-index: 5;
            box-shadow: 0 0 5px #ff5252;
        }

        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        .nav-btn.next {
            background: var(--accent);
            color: #151515;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }

        /* MAIN CANVAS */
        main {
            flex: 1;
            position: relative;
            background: #151515;
            /* Galvani Background */
            overflow: hidden;
        }

        /* FLASH OVERLAY */
        #flash-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s ease-out;
            z-index: 100;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.2);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Franklin's Lab</h1>
            <div class="subtitle">Simulation: The Metallic Sea</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- 1. Bring Rod -->
            <div class="control-row" id="ctrl-rod">
                <label>1. Intro</label>
                <button id="btn-rod" onclick="toggleRod()">Introduce Charged Rod</button>
            </div>

            <!-- 2. Slider -->
            <div class="control-row" id="ctrl-move">
                <label>2. Proximity</label>
                <input type="range" id="slider-dist" min="0" max="100" value="0" step="1">
                <div id="limit-marker"></div>
            </div>

            <!-- Reset -->
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #333; padding-top:10px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>System</label>
                <button onclick="resetSim()">Reset Lab</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div id="flash-overlay"></div>
        <div class="scene-tag" style="top: 20px; right: 20px;">Microscopic View: x10,000,000</div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE (GALVANI STYLE)
        // ==========================================

        const state = {
            rodVisible: false,
            rodPosPercent: 0,
            hasTouched: false,
            theta: 0,
            omega: 0,
        };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x151515); // The Galvani Background Color

        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 35;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );

        camera.position.set(10, 40, 20);
        camera.lookAt(0, -5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('world').appendChild(renderer.domElement);

        // Lighting (Matching Galvani)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;

        // Shadow Settings
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        const d = 30;
        dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
        scene.add(dirLight);

        // --- MATERIALS (Galvani Palette) ---
        const mats = {
            floor: new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 }), // Matte dark floor
            string: new THREE.MeshStandardMaterial({ color: 0x888888, flatShading: true }),
            balloon: new THREE.MeshPhongMaterial({
                color: 0x555555, // Metallic grey base
                transparent: true,
                opacity: 0.3,
                shininess: 60,
                specular: 0xffffff,
                side: THREE.DoubleSide,
                flatShading: true
            }),
            proton: new THREE.MeshBasicMaterial({ color: 0xff6b6b }), // Red
            electron: new THREE.MeshBasicMaterial({ color: 0x00d2d3 }), // Cyan
            rod: new THREE.MeshStandardMaterial({ color: 0xc0392b, roughness: 0.4, flatShading: true })
        };

        // --- SCENE OBJECTS ---

        // 1. FLOOR (Replaced Tiles with Galvani Style Matte Plane)
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), mats.floor);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -18;
        floor.receiveShadow = true;
        scene.add(floor);

        // 2. BALLOON SYSTEM (Low Poly)
        const stringLength = 16;
        const balloonRadius = 3.0;

        // String
        const stringGeo = new THREE.CylinderGeometry(0.08, 0.08, 1, 4);
        const stringMesh = new THREE.Mesh(stringGeo, mats.string);
        stringMesh.castShadow = true;
        scene.add(stringMesh);

        // Balloon Group 
        const balloonGroup = new THREE.Group();
        scene.add(balloonGroup);

        // The Sphere
        const balloonGeo = new THREE.IcosahedronGeometry(balloonRadius, 1); // Low poly sphere
        const balloonMesh = new THREE.Mesh(balloonGeo, mats.balloon);
        balloonMesh.castShadow = true;
        balloonGroup.add(balloonMesh);

        // Wireframe Overlay for technical look
        const wireGeo = new THREE.WireframeGeometry(balloonGeo);
        const wireMat = new THREE.LineBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.1 });
        const wireframe = new THREE.LineSegments(wireGeo, wireMat);
        balloonMesh.add(wireframe);

        // Inner Nuclei (Positive Cores)
        const nucGeo = new THREE.IcosahedronGeometry(0.35, 0);
        for (let i = 0; i < 12; i++) {
            const m = new THREE.Mesh(nucGeo, mats.proton);
            m.position.set((Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4);
            balloonGroup.add(m);
        }

        // --- HELPER: SIGN TEXTURE ---
        function createSignTexture(symbol) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(255,255,255,0)'; // Transparent
            ctx.clearRect(0, 0, 64, 64);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(symbol, 32, 34);
            return new THREE.CanvasTexture(canvas);
        }

        // Balloon Sign ("-")
        const balloonSignMat = new THREE.MeshBasicMaterial({ map: createSignTexture("-"), transparent: true, side: THREE.DoubleSide, depthTest: false });
        const balloonSignMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), balloonSignMat);
        balloonSignMesh.position.set(0, 4.5, 0);
        balloonSignMesh.visible = false;
        //balloonGroup.add(balloonSignMesh);

        // --- ELECTRONS (Particles) ---
        const particleCount = 150;
        const electrons = [];
        const elecGeo = new THREE.IcosahedronGeometry(0.15, 0);

        for (let i = 0; i < particleCount; i++) {
            const mesh = new THREE.Mesh(elecGeo, mats.electron);
            // Distribute inside sphere
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const r = Math.cbrt(Math.random()) * (balloonRadius * 0.9);
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            const basePos = new THREE.Vector3(x, y, z);

            mesh.position.copy(basePos);
            balloonGroup.add(mesh);
            electrons.push({ mesh: mesh, basePos: basePos });
        }

        // Transfer Particles Array
        const transferParticles = [];

        // --- THE ROD ---
        const rodGroup = new THREE.Group();
        const rodGeo = new THREE.CylinderGeometry(0.7, 0.7, 10, 6);
        rodGeo.rotateZ(Math.PI / 2);
        const rodMesh = new THREE.Mesh(rodGeo, mats.rod);
        rodMesh.castShadow = true;
        rodGroup.add(rodMesh);

        // Rod Signs
        const rodSignMat = new THREE.MeshBasicMaterial({ map: createSignTexture("-"), transparent: true, side: THREE.DoubleSide });
        for (let i = -4; i <= 4; i += 1.2) {
            const sign = new THREE.Mesh(new THREE.PlaneGeometry(0.7, 0.7), rodSignMat);
            sign.position.set(i, 0.8, 0);
            sign.rotation.x = -Math.PI / 3;
            rodGroup.add(sign);
        }

        rodGroup.position.set(-100, 0, 0);
        scene.add(rodGroup);

        // ==========================================
        // PART 2: PHYSICS LOOP
        // ==========================================

        function animate() {
            requestAnimationFrame(animate);

            // 1. Rod Motion
            const minX = -30;
            const maxX = -3;
            const targetRodX = minX + (state.rodPosPercent / 100) * (maxX - minX);

            if (state.rodVisible) {
                rodGroup.visible = true;
                rodGroup.position.x += (targetRodX - rodGroup.position.x) * 0.1;
                rodGroup.position.y = balloonGroup.position.y;
            } else {
                rodGroup.visible = false;
                rodGroup.position.x = -100;
            }

            // 2. Physics & Forces
            const rodTipX = rodGroup.position.x + 5;
            const balloonX = balloonGroup.position.x;
            const dist = Math.abs(rodTipX - balloonX);

            // Contact Detection
            if (state.rodVisible && dist < 3.2 && !state.hasTouched) {
                triggerContact();
            }

            let electricForce = 0;
            if (state.rodVisible) {
                if (!state.hasTouched) {
                    // Induction (Attraction)
                    electricForce = -200 / (dist * dist + 10);
                } else {
                    // Conduction (Repulsion)
                    electricForce = 800 / (dist * dist + 5);
                }
            }

            // 3. Electron Simulation
            const rodTipWorld = new THREE.Vector3(rodTipX, rodGroup.position.y, 0);

            electrons.forEach(elec => {
                const jitter = new THREE.Vector3((Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1);
                const elecWorld = elec.mesh.position.clone().add(balloonGroup.position);
                const dirFromRod = new THREE.Vector3().subVectors(elecWorld, rodTipWorld).normalize();

                let strength = state.rodVisible ? (150 / (dist * dist + 1)) : 0;
                if (state.hasTouched) strength *= 3; // Huge surge after contact

                const push = dirFromRod.multiplyScalar(strength * 6);
                const targetPos = new THREE.Vector3().addVectors(elec.basePos, push).add(jitter);

                if (targetPos.length() > (balloonRadius * 0.95)) targetPos.setLength(balloonRadius * 0.95);
                elec.mesh.position.lerp(targetPos, 0.1);
            });

            // 4. Particle Transfer Animation
            if (transferParticles.length > 0) {
                for (let i = transferParticles.length - 1; i >= 0; i--) {
                    const p = transferParticles[i];
                    p.progress += p.speed;
                    const worldTarget = p.targetLocal.clone().add(balloonGroup.position);
                    const dir = new THREE.Vector3().subVectors(worldTarget, p.mesh.position);

                    if (dir.length() < 0.2 || p.progress >= 1) {
                        scene.remove(p.mesh);
                        transferParticles.splice(i, 1);
                    } else {
                        p.mesh.position.add(dir.multiplyScalar(0.15));
                    }
                }
            }

            // 5. Pendulum Physics
            const gravity = 0.5;
            const restoringTorque = -gravity * 20 * Math.sin(state.theta);
            const electricTorque = electricForce * Math.cos(state.theta) * 0.2;
            const angularAccel = (restoringTorque + electricTorque) * 0.01;

            state.omega += angularAccel;
            state.omega *= 0.92; // Damping
            state.theta += state.omega;

            // Update positions
            const bX = stringLength * Math.sin(state.theta);
            const bY = -10 + stringLength * Math.cos(state.theta);
            balloonGroup.position.set(bX, bY, 0);

            const midX = (0 + bX) / 2;
            const midY = (-10 + bY) / 2;
            stringMesh.position.set(midX, midY, 0);
            const currentLen = Math.sqrt(bX * bX + (bY - (-10)) * (bY - (-10)));
            stringMesh.scale.set(1, currentLen, 1);
            stringMesh.rotation.z = -state.theta;

            // 6. UI Updates
            if (state.hasTouched) {
                balloonSignMesh.visible = true;
                balloonSignMesh.rotation.copy(camera.rotation); // Billboard
                mats.balloon.emissive.setHex(0x004444); // Glow
                wireMat.opacity = 0.5;
            } else {
                balloonSignMesh.visible = false;
                mats.balloon.emissive.setHex(0x000000);
                wireMat.opacity = 0.1;
            }

            renderer.render(scene, camera);
        }

        function spawnTransferParticles(startPos) {
            for (let i = 0; i < 40; i++) {
                const mesh = new THREE.Mesh(elecGeo, mats.electron);
                mesh.position.copy(startPos);
                // Random scatter at start
                mesh.position.add(new THREE.Vector3((Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)));

                const target = new THREE.Vector3(
                    (Math.random() - 0.5) * 3,
                    (Math.random() - 0.5) * 3,
                    (Math.random() - 0.5) * 3
                );

                scene.add(mesh);
                transferParticles.push({
                    mesh: mesh,
                    targetLocal: target,
                    progress: 0,
                    speed: 0.03 + Math.random() * 0.04
                });
            }
        }

        function triggerContact() {
            state.hasTouched = true;
            const flash = document.getElementById('flash-overlay');
            flash.style.opacity = 0.9;
            setTimeout(() => { flash.style.opacity = 0; }, 150);

            const rodTip = new THREE.Vector3(rodGroup.position.x + 5, rodGroup.position.y, 0);
            spawnTransferParticles(rodTip);
            checkAdvance();
        }

        animate();

        // ==========================================
        // PART 3: STORY ENGINE
        // ==========================================

        let currentSliderLimit = 100;
        let currentChapter = 0;

        function toggleRod() {
            state.rodVisible = true;
            const btn = document.getElementById('btn-rod');
            btn.innerText = "Rod Active";
            btn.disabled = true;
            checkAdvance();
        }

        document.getElementById('slider-dist').addEventListener('input', (e) => {
            let val = parseFloat(e.target.value);
            if (val > currentSliderLimit) {
                val = currentSliderLimit;
                e.target.value = currentSliderLimit;
            }
            state.rodPosPercent = val;
            checkAdvance();
        });

        window.resetSim = () => {
            state.rodVisible = false;
            state.rodPosPercent = 0;
            state.hasTouched = false;
            state.theta = 0;
            state.omega = 0;

            transferParticles.forEach(p => scene.remove(p.mesh));
            transferParticles.length = 0;

            const slider = document.getElementById('slider-dist');
            slider.value = 0;

            const btn = document.getElementById('btn-rod');
            btn.disabled = false;
            btn.innerText = "Introduce Charged Rod";

            document.getElementById('limit-marker').style.display = 'none';
            loadLesson(0);
        }

        const lessons = [
            {
                title: "Prologue: The Silent Sea",
                text: "You are viewing a metallic sphere at the atomic level. <br><br>Observe the <span class='highlight-elec'>Cyan Particles</span>. These are free electrons.The <span class='highlight-nuc'>Red particles</span> are the positively charged nucelus. In a metal, they act like a liquidâ€”constantly moving but evenly distributed. The sphere is currently <strong>Neutral</strong>.<br><br>To disturb this peace, we need a charge. <span class='instruction-inline'>Click 'INTRODUCE CHARGED ROD'</span>.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-rod');
                    currentSliderLimit = 100;
                    document.getElementById('limit-marker').style.display = 'none';
                },
                check: () => state.rodVisible
            },
            {
                title: "Step 1: Induction (The Migration)",
                text: "The Rod is negatively charged. It is an enemy to the electrons.<br><br>As you bring the rod closer, watch the blue ocean flee to the far side of the sphere, leaving the near side exposed and Positive.<br><br><span class='instruction-inline'>Drag the slider</span> to the Red Marker to see this 'Induction' effect.",
                setup: () => {
                    unlock('ctrl-move');
                    currentSliderLimit = 55;
                    document.getElementById('limit-marker').style.display = 'block';
                },
                check: () => state.rodPosPercent >= 50
            },
            {
                title: "Step 2: Conduction (The Break)",
                text: "Notice the sphere swinging <em>toward</em> the rod? That is attraction. The positive nuclei on the near side are pulling it closer.<br><br>If they touch, the dam will break.<br><br><span class='instruction-inline'>Drag the slider past the limit</span> to force contact.",
                setup: () => {
                    currentSliderLimit = 100;
                    document.getElementById('limit-marker').style.display = 'none';
                },
                check: () => state.hasTouched
            },
            {
                title: "Conclusion: Repulsion",
                text: "<strong>FLASH!</strong> A torrent of electrons just rushed onto the sphere.<br><br>Now, why is it pushed away? The sphere has swallowed such a massive dose of electrons that they <strong>drown out</strong> the positive pull of the nuclei. <br><br>This new <strong>Net Negative Charge</strong> dominates the force. Like charges repel.",
                setup: () => {
                    document.getElementById('btn-next').innerText = "Chapter Complete";
                },
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Module 1: Chapter 1 - Step ${idx + 1} of ${lessons.length}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div><div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');
            btn.disabled = !l.check();
            if (idx === lessons.length - 1) btn.disabled = false;

            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                // Navigate to Polarization via React route
                window.location.href = '/theapplefalls/lessons/chapter1/Chapter1_Final/PolarizationInductors.html';
            }
        }

        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }

        function checkAdvance() {
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        loadLesson(0);

        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * newAspect / 2;
            camera.right = viewSize * newAspect / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

    </script>
</body>

</html>