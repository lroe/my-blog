<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Circuit Logic: Series & Parallel</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MathJax for nice formula rendering -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        /* --- THEME & LAYOUT (PRESERVED) --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* LEFT PANEL */
        aside {
            width: 450px;
            /* Slightly wider for formulas */
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.6;
            font-size: 14px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .formula-box {
            background: #252525;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #444;
            margin: 10px 0;
            color: #fff;
            font-family: 'Times New Roman', serif;
            font-style: italic;
            text-align: center;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .highlight {
            color: var(--accent);
        }

        /* CONTROLS */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .val-display {
            color: var(--accent);
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
            margin-bottom: 5px;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        button.active-mode {
            background: var(--accent);
            color: #151515;
            border-color: var(--accent);
        }

        /* ANIMATIONS */
        @keyframes pulse-orange {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 159, 67, 0.7);
                transform: scale(1);
            }

            70% {
                box-shadow: 0 0 0 8px rgba(255, 159, 67, 0);
                transform: scale(1.02);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(255, 159, 67, 0);
                transform: scale(1);
            }
        }

        .pulse {
            animation: pulse-orange 2s infinite;
        }

        button.pulse {
            border-color: var(--accent);
            color: #fff;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
        }

        /* NAVIGATION */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        .nav-btn.next {
            background: var(--accent);
            color: #151515;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            animation: none;
        }

        /* CANVAS */
        main {
            flex: 1;
            position: relative;
            background: #151515;
            overflow: hidden;
        }

        /* STATS OVERLAY */
        #stats-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #333;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            color: #ddd;
            width: 200px;
            pointer-events: none;
            user-select: none;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 13px;
        }

        .stat-val {
            color: var(--accent);
            font-weight: bold;
        }

        .stat-header {
            border-bottom: 1px solid #444;
            margin-bottom: 10px;
            padding-bottom: 5px;
            color: #fff;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Chapter 8: Resistor Networks</div>
        </header>
        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>
        <div id="controls-area">
            <!-- Mode Selection -->
            <div class="control-row" id="ctrl-mode">
                <label>1. Circuit Topology</label>
                <div style="display:flex; gap:10px;">
                    <button id="btn-series" onclick="setMode('series')">Series</button>
                    <button id="btn-parallel" onclick="setMode('parallel')">Parallel</button>
                </div>
            </div>
            <!-- Resistor 1 -->
            <div class="control-row" id="ctrl-r1">
                <label>2. Resistor 1 (Ohms) <span id="val-r1" class="val-display">10 立</span></label>
                <input type="range" id="slider-r1" min="1" max="100" value="10" step="1">
            </div>
            <!-- Resistor 2 -->
            <div class="control-row" id="ctrl-r2">
                <label>3. Resistor 2 (Ohms) <span id="val-r2" class="val-display">10 立</span></label>
                <input type="range" id="slider-r2" min="1" max="100" value="10" step="1">
            </div>
        </div>
        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next Concept &rarr;</button>
        </div>
    </aside>
    <main id="world">
    </main>
    <script>
        // ==========================================
        // PART 1: PHYSICS & STATE
        // ==========================================
        const VOLTAGE = 12; // Constant 12V Battery
        const state = {
            mode: 'series', // 'series' or 'parallel'
            r1: 10,
            r2: 10,
            req: 20,
            iTotal: 0,
            i1: 0,
            i2: 0
        };

        function recalculate() {
            if (state.mode === 'series') {
                // Series Formula: Req = R1 + R2
                state.req = state.r1 + state.r2;
                state.iTotal = VOLTAGE / state.req;
                // Current is same everywhere in series
                state.i1 = state.iTotal;
                state.i2 = state.iTotal;
            } else {
                // Parallel Formula: 1/Req = 1/R1 + 1/R2
                // Req = (R1*R2) / (R1+R2)
                state.req = (state.r1 * state.r2) / (state.r1 + state.r2);
                state.i1 = VOLTAGE / state.r1;
                state.i2 = VOLTAGE / state.r2;
                state.iTotal = state.i1 + state.i2;
            }
        }

        // ==========================================
        // PART 2: THREE.JS VISUALIZATION
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x151515);

        // Camera setup
        const aspect = (window.innerWidth - 450) / window.innerHeight;
        const camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
        camera.position.set(0, 15, 15);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth - 450, window.innerHeight);
        document.getElementById('world').appendChild(renderer.domElement);

        // Lights
        const ambLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambLight);
        const pointLight = new THREE.PointLight(0xff9f43, 1, 50);
        pointLight.position.set(0, 10, 0);
        scene.add(pointLight);

        // Materials
        const matWire = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.2, metalness: 0.8 });
        const matResistorBody = new THREE.MeshStandardMaterial({ color: 0xeecfa1 }); // Beige
        const matBand1 = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const matBand2 = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const matBattery = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const matBatteryPos = new THREE.MeshStandardMaterial({ color: 0xff9f43, emissive: 0xff9f43, emissiveIntensity: 0.5 });
        const matElectron = new THREE.MeshBasicMaterial({ color: 0xff9f43 });

        // Groups
        const circuitGroup = new THREE.Group();
        scene.add(circuitGroup);
        const particleGroup = new THREE.Group();
        scene.add(particleGroup);

        // Helpers
        function createWire(x1, z1, x2, z2) {
            const vec1 = new THREE.Vector3(x1, 0, z1);
            const vec2 = new THREE.Vector3(x2, 0, z2);
            const len = vec1.distanceTo(vec2);
            const geo = new THREE.CylinderGeometry(0.1, 0.1, len, 8);
            geo.translate(0, len / 2, 0);
            geo.rotateX(Math.PI / 2);
            const mesh = new THREE.Mesh(geo, matWire);
            mesh.position.copy(vec1);
            mesh.lookAt(vec2);
            return mesh;
        }

        function createResistor(x, z, rotY = 0, label) {
            const group = new THREE.Group();
            group.position.set(x, 0, z);
            group.rotation.y = rotY;
            // Body
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 2, 16), matResistorBody);
            body.rotation.z = Math.PI / 2;
            group.add(body);
            // Bands (Decorative)
            const b1 = new THREE.Mesh(new THREE.CylinderGeometry(0.41, 0.41, 0.2, 16), matBand1);
            b1.rotation.z = Math.PI / 2;
            b1.position.x = -0.5;
            const b2 = new THREE.Mesh(new THREE.CylinderGeometry(0.41, 0.41, 0.2, 16), matBand2);
            b2.rotation.z = Math.PI / 2;
            b2.position.x = 0.2;
            group.add(b1, b2);
            // Leads
            const l1 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1, 8), matWire);
            l1.rotation.z = Math.PI / 2;
            l1.position.x = -1.5;
            const l2 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1, 8), matWire);
            l2.rotation.z = Math.PI / 2;
            l2.position.x = 1.5;
            group.add(l1, l2);
            return group;
        }

        // Build Circuits
        function buildCircuit() {
            // Clear old
            while (circuitGroup.children.length > 0) {
                circuitGroup.remove(circuitGroup.children[0]);
            }

            const batt = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 1), matBattery);
            batt.position.set(0, 0, 6);
            const posTerm = new THREE.Mesh(new THREE.BoxGeometry(0.5, 2.1, 0.5), matBatteryPos);
            posTerm.position.set(0.5, 0, 6); // Right side is positive
            circuitGroup.add(batt, posTerm);

            // Polarities (+ and -)
            const symbolMat = new THREE.MeshBasicMaterial({ color: 0xff9f43 });
            // Plus Sign
            const plus = new THREE.Group();
            const pH = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.1, 0.1), symbolMat);
            const pV = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 0.1), symbolMat);
            plus.add(pH, pV);
            plus.position.set(0.5, 0, 6.6); // Front of pos terminal
            circuitGroup.add(plus);
            // Minus Sign
            const minus = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.1, 0.1), symbolMat);
            minus.position.set(-0.5, 0, 6.6); // Front of neg side
            circuitGroup.add(minus);

            if (state.mode === 'series') {
                // --- SERIES LAYOUT ---
                // Loop: Battery -> Right -> Up -> Left (R1) -> Left (R2) -> Down -> Battery
                // Wires
                circuitGroup.add(createWire(1, 6, 6, 6)); // Batt to Corner
                circuitGroup.add(createWire(6, 6, 6, -2)); // Up
                circuitGroup.add(createWire(6, -2, 4, -2)); // To R1
                circuitGroup.add(createWire(0, -2, -2, -2));// R1 to R2
                circuitGroup.add(createWire(-6, -2, -6, 6));// Down
                circuitGroup.add(createWire(-6, 6, -1, 6)); // Back to Batt
                // Resistors
                circuitGroup.add(createResistor(2, -2, 0, "R1")); // R1
                circuitGroup.add(createResistor(-4, -2, 0, "R2")); // R2
            } else {
                // --- PARALLEL LAYOUT ---
                // Battery -> Split
                // Main Rails
                circuitGroup.add(createWire(1, 6, 6, 6)); // Batt to Right
                circuitGroup.add(createWire(6, 6, 6, 2)); // Up main
                circuitGroup.add(createWire(-6, 6, -1, 6)); // Left return to Batt
                circuitGroup.add(createWire(-6, 2, -6, 6)); // Down return
                // Branch 1 (R1 at Z=2)
                circuitGroup.add(createWire(6, 2, 2, 2)); // Right rail in
                circuitGroup.add(createResistor(0, 2, 0, "R1"));
                circuitGroup.add(createWire(-2, 2, -6, 2)); // Left rail out
                // Rail connector to Branch 2
                circuitGroup.add(createWire(6, 2, 6, -2));
                circuitGroup.add(createWire(-6, 2, -6, -2));
                // Branch 2 (R2 at Z=-2)
                circuitGroup.add(createWire(6, -2, 2, -2)); // Right rail in
                circuitGroup.add(createResistor(0, -2, 0, "R2"));
                circuitGroup.add(createWire(-2, -2, -6, -2)); // Left rail out
            }
        }

        // Particle System
        const particles = [];
        const MAX_PARTICLES = 60;

        function spawnParticle(pathId, initialProgress = 0) {
            const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), matElectron);
            particleGroup.add(mesh);
            particles.push({
                mesh: mesh,
                pathId: pathId, // 0 = main/series, 1 = branch 1, 2 = branch 2
                progress: initialProgress,
                speed: 0
            });
        }

        function initParticles() {
            // Clean old
            while (particleGroup.children.length > 0) particleGroup.remove(particleGroup.children[0]);
            particles.length = 0;

            const n = MAX_PARTICLES - 1;
            if (state.mode === 'series') {
                for (let i = 0; i < MAX_PARTICLES; i++) {
                    const progress = n > 0 ? (i / n) * 100 : 0;
                    spawnParticle(0, progress);
                }
            } else {
                // Allocate particles proportional to path lengths for uniform spacing
                const len1 = 30;
                const len2 = 38;
                const total_len = len1 + len2;
                const frac1 = len1 / total_len;
                let num1 = Math.round(MAX_PARTICLES * frac1);
                let num2 = MAX_PARTICLES - num1;
                // Adjust if rounding causes issue
                if (num1 < 1) num1 = 1;
                if (num2 < 1) num2 = 1;
                if (num1 + num2 > MAX_PARTICLES) num2--;

                const n1 = num1 - 1;
                for (let i = 0; i < num1; i++) {
                    const progress = n1 > 0 ? (i / n1) * 100 : 0;
                    spawnParticle(1, progress);
                }

                const n2 = num2 - 1;
                for (let i = 0; i < num2; i++) {
                    const progress = n2 > 0 ? (i / n2) * 100 : 0;
                    spawnParticle(2, progress);
                }
            }
        }

        function updateParticles() {
            // Rely on fixed pool initialized in initParticles()
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];

                // Determine current and path length
                let current = state.iTotal;
                let pathLen;
                if (state.mode === 'series') {
                    pathLen = 38;
                } else {
                    if (p.pathId === 1) {
                        current = state.i1;
                        pathLen = 30;
                    } else if (p.pathId === 2) {
                        current = state.i2;
                        pathLen = 38;
                    } else continue; // Invalid
                }

                // Nominal visual speed (as if length=38)
                const nominal_vis = 0.05 + (current * 0.03);
                // Adjust for actual path length to keep spatial speed consistent
                const visSpeed = nominal_vis * (38 / pathLen);

                p.progress += visSpeed;

                // Position Calculation based on Path
                let pos = new THREE.Vector3();
                const pr = p.progress % 100;

                if (state.mode === 'series') {
                    // Series / Path 2 thresholds approx: 13,34,66,87 (for lengths 5,8,12,8,5 total 38)
                    if (pr < 13) {
                        const frac = pr / 13;
                        pos.set(1 + frac * 5, 0, 6);
                    } else if (pr < 34) {
                        const frac = (pr - 13) / 21;
                        pos.set(6, 0, 6 - frac * 8);
                    } else if (pr < 66) {
                        const frac = (pr - 34) / 32;
                        pos.set(6 - frac * 12, 0, -2);
                    } else if (pr < 87) {
                        const frac = (pr - 66) / 21;
                        pos.set(-6, 0, -2 + frac * 8);
                    } else {
                        const frac = (pr - 87) / 13;
                        pos.set(-6 + frac * 5, 0, 6);
                    }
                } else {
                    // Parallel
                    if (p.pathId === 1) {
                        // Upper path thresholds: 16.7,30,70,83.3 (5,4,12,4,5 total 30)
                        if (pr < 16.7) {
                            const frac = pr / 16.7;
                            pos.set(1 + frac * 5, 0, 6);
                        } else if (pr < 30) {
                            const frac = (pr - 16.7) / 13.3;
                            pos.set(6, 0, 6 - frac * 4);
                        } else if (pr < 70) {
                            const frac = (pr - 30) / 40;
                            pos.set(6 - frac * 12, 0, 2);
                        } else if (pr < 83.3) {
                            const frac = (pr - 70) / 13.3;
                            pos.set(-6, 0, 2 + frac * 4);
                        } else {
                            const frac = (pr - 83.3) / 16.7;
                            pos.set(-6 + frac * 5, 0, 6);
                        }
                    } else {
                        // Lower path same as series
                        if (pr < 13) {
                            const frac = pr / 13;
                            pos.set(1 + frac * 5, 0, 6);
                        } else if (pr < 34) {
                            const frac = (pr - 13) / 21;
                            pos.set(6, 0, 6 - frac * 8);
                        } else if (pr < 66) {
                            const frac = (pr - 34) / 32;
                            pos.set(6 - frac * 12, 0, -2);
                        } else if (pr < 87) {
                            const frac = (pr - 66) / 21;
                            pos.set(-6, 0, -2 + frac * 8);
                        } else {
                            const frac = (pr - 87) / 13;
                            pos.set(-6 + frac * 5, 0, 6);
                        }
                    }
                }

                p.mesh.position.copy(pos);

                // Respawn/Loop check
                if (p.progress >= 100) {
                    // Recycle
                    p.progress = 0;
                    if (state.mode === 'parallel') {
                        // Re-roll path decision proportional to current
                        const totalI = state.i1 + state.i2;
                        if (totalI > 0) {
                            const r = Math.random() * totalI;
                            p.pathId = (r < state.i1 ? 1 : 2);
                        }
                    }
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateParticles();
            renderer.render(scene, camera);
        }
        animate();

        // ==========================================
        // PART 3: STORY & LOGIC
        // ==========================================
        function setMode(m) {
            state.mode = m;
            document.getElementById('btn-series').className = m === 'series' ? 'active-mode' : '';
            document.getElementById('btn-parallel').className = m === 'parallel' ? 'active-mode' : '';
            buildCircuit();
            recalculate();
            initParticles();
            checkAdvance();
        }

        // Sliders
        document.getElementById('slider-r1').addEventListener('input', (e) => {
            state.r1 = parseInt(e.target.value);
            document.getElementById('val-r1').innerText = state.r1 + " 立";
            recalculate();
        });
        document.getElementById('slider-r2').addEventListener('input', (e) => {
            state.r2 = parseInt(e.target.value);
            document.getElementById('val-r2').innerText = state.r2 + " 立";
            recalculate();
        });

        function updateHUD() {
        }

        // Story Modules
        let currentChapter = 0;
        const chapters = [
            {
                title: "Series: The Single Path",
                text: "In a <strong>Series Circuit</strong>, electrons have only one path to take. Think of it like a single lane road with multiple toll booths.<br><br>Because there is only one path, the <strong>Current (I)</strong> is the same everywhere.<br><br>However, the <strong>Resistance</strong> adds up. The more resistors you add, the harder it is for current to flow.",
                formula: `$$R_{eq} = R_1 + R_2$$`,
                setup: () => {
                    setMode('series');
                    lockAll();
                    unlock('ctrl-mode');
                    document.getElementById('btn-parallel').disabled = true; // Force series
                    document.getElementById('btn-series').disabled = false;
                    document.getElementById('btn-series').click();
                },
                check: () => state.mode === 'series'
            },
            {
                title: "Deriving the Series Formula",
                text: "How do we get that formula? We use Ohm's Law ($V = I \\cdot R$).<br><br>1. The total voltage ($V$) is split across the resistors: <br>$$V_{total} = V_1 + V_2$$<br>2. Since $V=I \\cdot R$, we can write:<br>$$I \\cdot R_{eq} = I \\cdot R_1 + I \\cdot R_2$$<br>3. Since Current ($I$) is the same everywhere, divide by $I$:<br>$$R_{eq} = R_1 + R_2$$",
                formula: "Change R1 and R2 using the sliders below. Notice how the Current slows down as Total Resistance increases.",
                setup: () => {
                    unlock('ctrl-r1');
                    unlock('ctrl-r2');
                    pulse('slider-r1', true);
                },
                check: () => true
            },
            {
                title: "Parallel: The Split Path",
                text: "In a <strong>Parallel Circuit</strong>, the path splits. Electrons can choose which way to go.<br><br>Think of this as opening a second lane on a highway. Even if the new lane is bumpy (high resistance), it still helps traffic move faster than having just one lane.<br><br><strong>Key Rule:</strong> Voltage is the same across both branches ($V_1 = V_2 = 12V$), but Current splits.",
                formula: `$$\\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2}$$`,
                setup: () => {
                    document.getElementById('btn-parallel').disabled = false;
                    pulse('btn-parallel', true);
                    pulse('slider-r1', false);
                },
                check: () => state.mode === 'parallel'
            },
            {
                title: "Conclusion",
                text: "1. The Total Current ($I$) is the sum of the branches:<br>$$I_{total} = I_1 + I_2$$<br>2. Using Ohm's Law ($I = V/R$):<br>$$\\frac{V}{R_{eq}} = \\frac{V}{R_1} + \\frac{V}{R_2}$$<br>3. Since Voltage ($V$) is constant, divide by $V$:<br>$$\\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2}$$",
                formula: "Experiment! Make R1 small (low resistance) and R2 large. Watch the electrons rush through the easy path (R1).",
                setup: () => {
                    pulse('btn-parallel', false);
                },
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = chapters[idx];
            document.querySelector('.subtitle').innerText = `Concept ${idx + 1} of ${chapters.length}`;
            let content = `<div class="chapter-title">${l.title}</div>`;
            content += `<div class="story-text">${l.text}</div>`;
            if (l.formula) content += `<div class="formula-box">${l.formula}</div>`;
            document.getElementById('chapter-content').innerHTML = content;
            // Re-render MathJax
            if (window.MathJax) {
                MathJax.typesetPromise();
            }
            l.setup();
            const btn = document.getElementById('btn-next');
            if (idx === chapters.length - 1) {
                btn.innerHTML = "Next Lesson";
                btn.disabled = false;
                btn.classList.add('pulse');
            } else {
                btn.innerHTML = "Next Concept &rarr;";
                btn.disabled = !l.check();
            }
            // Clear pulses
            document.querySelectorAll('.pulse').forEach(e => {
                if (e.id !== 'btn-next') e.classList.remove('pulse');
            });
        }

        function nextLesson() {
            if (currentChapter < chapters.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.location.href = '/theapplefalls/lessons/chapter8/10_electric_power.html';
            }
        }

        function prevLesson() {
            if (currentChapter > 0) {
                loadLesson(currentChapter - 1);
            }
        }

        function checkAdvance() {
            const btn = document.getElementById('btn-next');
            if (chapters[currentChapter].check()) {
                btn.disabled = false;
                btn.classList.add('pulse');
            }
        }

        function lockAll() {
            document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active'));
        }

        function unlock(id) {
            document.getElementById(id).classList.add('active');
        }

        function pulse(id, on) {
            const el = document.getElementById(id);
            if (el) {
                if (on) el.classList.add('pulse');
                else el.classList.remove('pulse');
            }
        }

        // Init
        buildCircuit();
        recalculate();
        initParticles();
        loadLesson(0);

        // Resize handler
        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - 450) / window.innerHeight;
            camera.aspect = newAspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - 450, window.innerHeight);
        });
    </script>
</body>

</html>