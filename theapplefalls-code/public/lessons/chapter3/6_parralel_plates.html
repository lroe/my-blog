<!-- START OF FILE parallel_plates_ortho_fixed.html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Electrostatics: Parallel Plates</title>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load OrbitControls -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
            --pos: #ff5252;
            /* Red */
            --neg: #74b9ff;
            /* Blue */
            --net: #ffffff;
            /* White */
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* SIDEBAR */
        aside {
            width: 400px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        /* STORY CONTENT */
        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 20px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.6;
            font-size: 14px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        /* FORMULA BOX */
        .formula-box {
            background: #111;
            border-left: 3px solid var(--accent);
            padding: 15px;
            margin: 10px 0;
            font-family: 'Times New Roman', serif;
            font-style: italic;
            font-size: 18px;
            color: #fff;
            text-align: center;
        }

        .small-note {
            font-size: 12px;
            color: #888;
            font-family: 'Segoe UI', sans-serif;
            font-style: normal;
            margin-top: 5px;
            display: block;
        }

        /* DEFINITION BOX */
        .definition-box {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 13px;
            color: #eee;
        }

        .definition-title {
            color: var(--accent);
            font-weight: bold;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 5px;
            display: block;
        }

        .legend-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        /* PULSE ANIMATION */
        @keyframes pulse-orange {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 159, 67, 0.7);
                transform: scale(1);
            }

            70% {
                box-shadow: 0 0 0 8px rgba(255, 159, 67, 0);
                transform: scale(1.02);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(255, 159, 67, 0);
                transform: scale(1);
            }
        }

        .pulse {
            animation: pulse-orange 2s infinite;
        }

        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        .nav-btn.next {
            background: var(--accent);
            color: #151515;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            animation: none;
        }

        /* MAIN CANVAS */
        main {
            flex: 1;
            position: relative;
            background: #151515;
            overflow: hidden;
            cursor: move;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #555;
            font-size: 12px;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Electrostatics</h1>
            <div class="subtitle">Parallel Plates & Superposition</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">

            <div class="control-row" id="ctrl-sep">
                <label><span>Plate Separation (d)</span></label>
                <input type="range" id="slider-sep" min="2" max="12" value="6" step="0.1">
            </div>

            <div class="control-row" id="ctrl-reset" style="display:flex;">
                <button onclick="resetView()">Reset Camera</button>
            </div>

        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div id="instructions">Left Click: Rotate | Right Click: Pan | Scroll: Zoom</div>
    </main>

    <script>
        // ==========================================
        // 3D ENGINE
        // ==========================================

        const state = {
            separation: 6.0,
            showPosField: false,
            showNegField: false,
            showNetField: false
        };

        // Scene Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x151515);

        const sidebarWidth = 400;
        const d = 20;
        const aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;

        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(20, 10, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        document.getElementById('world').appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        window.resetView = () => {
            camera.position.set(20, 10, 20);
            camera.lookAt(0, 0, 0);
            controls.reset();
        }

        // --- OBJECTS ---

        const worldGroup = new THREE.Group();
        scene.add(worldGroup);

        // Materials
        const posPlateMat = new THREE.MeshBasicMaterial({ color: 0xff5252, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
        const negPlateMat = new THREE.MeshBasicMaterial({ color: 0x74b9ff, transparent: true, opacity: 0.2, side: THREE.DoubleSide });

        // 1. Plates
        const topPlate = new THREE.Group();
        const bottomPlate = new THREE.Group();
        worldGroup.add(topPlate);
        worldGroup.add(bottomPlate);

        // Top Plate (+sigma)
        topPlate.add(new THREE.GridHelper(30, 30, 0xff5252, 0x330000));
        const topMesh = new THREE.Mesh(new THREE.PlaneGeometry(30, 30), posPlateMat);
        topMesh.rotation.x = Math.PI / 2;
        topPlate.add(topMesh);

        // Bottom Plate (-sigma)
        bottomPlate.add(new THREE.GridHelper(30, 30, 0x74b9ff, 0x000033));
        const botMesh = new THREE.Mesh(new THREE.PlaneGeometry(30, 30), negPlateMat);
        botMesh.rotation.x = Math.PI / 2;
        bottomPlate.add(botMesh);


        // 2. Vectors
        // We need vectors at specific X,Z points, but in 3 distinct zones: Above, Middle, Below
        const vectorGroup = new THREE.Group();
        scene.add(vectorGroup);

        const arrowSets = [];
        // Structure: { posArrow: Mesh, negArrow: Mesh, netArrow: Mesh, origin: Vector3, zone: 'top'|'mid'|'bot' }

        const createArrow = (color, len) => {
            return new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), len, color, 0.5, 0.3);
        }

        // Generate grid of measurement points
        for (let x = -8; x <= 8; x += 4) {
            for (let z = -8; z <= 8; z += 4) {

                // We create 3 sets of arrows for every X,Z coordinate:
                // 1. High (Above top plate)
                // 2. Mid (Between plates)
                // 3. Low (Below bottom plate)

                const zones = ['top', 'mid', 'bot'];

                zones.forEach(zone => {
                    const group = {};
                    group.zone = zone;
                    group.xz = { x, z };

                    // Red Arrow (From Top Plate)
                    group.posArrow = createArrow(0xff5252, 2.5);
                    vectorGroup.add(group.posArrow);

                    // Blue Arrow (From Bottom Plate)
                    group.negArrow = createArrow(0x74b9ff, 2.5);
                    vectorGroup.add(group.negArrow);

                    // White Arrow (Net)
                    group.netArrow = createArrow(0xffffff, 2.5);
                    vectorGroup.add(group.netArrow);

                    arrowSets.push(group);
                });
            }
        }

        // ==========================================
        // LOGIC LOOP
        // ==========================================

        function updateSim() {
            const halfD = state.separation / 2;

            // Move Plates
            topPlate.position.y = halfD;
            bottomPlate.position.y = -halfD;

            // Update Arrows
            arrowSets.forEach(set => {
                let yPos = 0;

                // Determine vertical position based on zone
                if (set.zone === 'top') yPos = halfD + 2.5;
                if (set.zone === 'mid') yPos = 0;
                if (set.zone === 'bot') yPos = -halfD - 2.5;

                const origin = new THREE.Vector3(set.xz.x, yPos, set.xz.z);

                // --- POSITIVE PLATE CONTRIBUTION (Red) ---
                // Always points AWAY from topPlate (y = halfD)
                // If yPos > halfD, points UP. If yPos < halfD, points DOWN.
                const dirPos = yPos > halfD ? 1 : -1;
                set.posArrow.position.copy(origin);
                // Shift slightly to avoid z-fighting with other arrows
                set.posArrow.position.x -= 0.3;
                set.posArrow.setDirection(new THREE.Vector3(0, dirPos, 0));
                set.posArrow.visible = state.showPosField;

                // --- NEGATIVE PLATE CONTRIBUTION (Blue) ---
                // Always points TOWARDS bottomPlate (y = -halfD)
                // If yPos > -halfD, points DOWN. If yPos < -halfD, points UP.
                const dirNeg = yPos > -halfD ? -1 : 1;
                set.negArrow.position.copy(origin);
                set.negArrow.position.x += 0.3;
                set.negArrow.setDirection(new THREE.Vector3(0, dirNeg, 0));
                set.negArrow.visible = state.showNegField;

                // --- NET FIELD (White) ---
                // Superposition
                const netY = dirPos + dirNeg; // Will be 2, 0, or -2

                set.netArrow.position.copy(origin);

                if (netY === 0) {
                    set.netArrow.visible = false; // Cancellation
                } else {
                    // Normalize for visual length (we just want direction mostly)
                    set.netArrow.setDirection(new THREE.Vector3(0, Math.sign(netY), 0));
                    // If visualizng net field, scale it slightly larger
                    set.netArrow.scale.setScalar(state.showNetField ? 1.0 : 0.001);
                    set.netArrow.visible = state.showNetField;
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();


        // ==========================================
        // STORY ENGINE
        // ==========================================

        const lessons = [
            {
                title: "1. The Setup",
                text: `
                <div class="definition-box">
                    <span class="definition-title">Configuration</span>
                    Two infinite parallel planes separated by distance <em>d</em>.
                    <br><br>
                    <span class="legend-dot" style="background:#ff5252"></span>Top: Charge density <strong>+&sigma;</strong><br>
                    <span class="legend-dot" style="background:#74b9ff"></span>Bottom: Charge density <strong>-&sigma;</strong>
                </div>
                In the previous lesson, we learned that a single infinite plane creates a constant electric field.<br><br>
                What happens when we bring two opposite plates close together? We use the <strong>Principle of Superposition</strong>: we simply add the vector fields produced by each plate.`,
                setup: () => {
                    state.showPosField = false;
                    state.showNegField = false;
                    state.showNetField = false;
                    state.separation = 10;
                    document.getElementById('slider-sep').value = 10;
                    document.getElementById('ctrl-sep').classList.add('active');
                    updateSim();
                },
                check: () => true
            },
            {
                title: "2. The Positive Contribution",
                text: `Let's ignore the bottom plate for a moment and only look at the field created by the <strong>Top Positive Plate</strong>.<br><br>Positive charges push outward. The field points <strong>UP</strong> above the plate and <strong>DOWN</strong> below it.<br><br>Remember, magnitude is E = &sigma; / 2&epsilon;<sub>0</sub>.`,
                setup: () => {
                    state.showPosField = true;
                    state.showNegField = false;
                    state.showNetField = false;
                    updateSim();
                },
                check: () => true
            },
            {
                title: "3. The Negative Contribution",
                text: `Now, let's look only at the <strong>Bottom Negative Plate</strong>.<br><br>Negative charges pull inward. The field points <strong>DOWN</strong> above the plate and <strong>UP</strong> below it.<br><br>Notice the direction arrows carefully.`,
                setup: () => {
                    state.showPosField = false;
                    state.showNegField = true;
                    state.showNetField = false;
                    updateSim();
                },
                check: () => true
            },
            {
                title: "4. The Inside Region",
                text: `Now we show both simultaneously. Focus on the space <strong>between</strong> the plates.<br><br>
                1. The Red (Top) field pushes <strong>DOWN</strong>.<br>
                2. The Blue (Bottom) field pulls <strong>DOWN</strong>.<br><br>
                Since both vectors point in the same direction, they <strong>reinforce</strong> each other.`,
                setup: () => {
                    state.showPosField = true;
                    state.showNegField = true;
                    state.showNetField = false;
                    updateSim();
                },
                check: () => true
            },
            {
                title: "5. The Outside Regions",
                text: `Now look at the space <strong>above</strong> and <strong>below</strong> the sandwich.<br><br>
                Above the top plate: Red points UP, Blue points DOWN.<br>
                Below the bottom plate: Red points DOWN, Blue points UP.<br><br>
                They are opposite directions and equal magnitude. They <strong>cancel perfectly</strong>.`,
                setup: () => {
                    // Just narration, visual stays same
                },
                check: () => true
            },
            {
                title: "6. The Net Field",
                text: `When we sum them up (White Arrows):<br><br>
                <strong>Outside:</strong> E<sub>net</sub> = 0<br><br>
                <strong>Inside:</strong> The fields add up.<br>
                <div class="formula-box">
                E<sub>net</sub> = &sigma;/2&epsilon;<sub>0</sub> + &sigma;/2&epsilon;<sub>0</sub> = &sigma;/&epsilon;<sub>0</sub>
                </div>
                <br>Try moving the <strong>Plate Separation</strong> slider. Notice that as long as we are between the plates, the field strength is constant.`,
                setup: () => {
                    state.showPosField = false;
                    state.showNegField = false;
                    state.showNetField = true;
                    document.getElementById('slider-sep').classList.add('pulse');
                    updateSim();
                },
                check: () => state.separation < 5
            },
            {
                title: "Conclusion",
                text: `We have derived the standard formula for a capacitor: <div class='formula-box'>E = &sigma; / &epsilon;<sub>0</sub></div><br>However, this assumes <strong>Infinite Plates</strong>.<br><br>In the real world, plates have edges. Near the edges, the cancellation isn't perfect, and field lines bow out. These are called <strong>Fringe Fields</strong>.<br><br>But for small distances <em>d</em> compared to plate size, our approximation is excellent.`,
                setup: () => {
                    document.getElementById('slider-sep').classList.remove('pulse');
                },
                check: () => true
            }
        ];

        let currentChapter = 0;

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];

            // UI Updates
            document.querySelector('header .subtitle').innerText = `Step ${idx + 1} / ${lessons.length}`;
            document.getElementById('chapter-content').innerHTML = `<div class="chapter-title">${l.title}</div><div class="story-text">${l.text}</div>`;

            // Button Logic
            const btn = document.getElementById('btn-next');
            if (idx === lessons.length - 1) btn.innerText = "Done";
            else btn.innerText = "Next \u2192";

            btn.disabled = !l.check();
            if (!l.check()) btn.classList.remove('pulse');
            else btn.classList.add('pulse');

            l.setup();
        }

        function checkAdvance() {
            if (lessons[currentChapter].check()) {
                const btn = document.getElementById('btn-next');
                btn.disabled = false;
                btn.classList.add('pulse');
            }
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.location.href = '/theapplefalls/lessons/chapter3/7infinteplanevsspeherical.html';
            }
        }
        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }

        // DOM Listeners
        document.getElementById('slider-sep').addEventListener('input', (e) => {
            state.separation = parseFloat(e.target.value);
            updateSim();
            checkAdvance();
        });

        // Resize
        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -d * newAspect; camera.right = d * newAspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

        // Start
        loadLesson(0);

    </script>
</body>

</html>