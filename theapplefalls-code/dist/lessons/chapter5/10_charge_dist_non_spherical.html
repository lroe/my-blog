<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Maxwell's Notebook: The Action of Points</title>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        :root {
            --bg: #050508;
            --panel: #141416;
            --text: #e0e0e0;
            --accent: #ff9f43;
            --danger: #ff4757;
            --safe: #2ed573;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        aside {
            width: 400px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 10;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.8);
        }

        header {
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-bottom: 1px solid var(--border);
        }

        h1 {
            margin: 0;
            font-size: 18px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        #story-container {
            flex: 1;
            padding: 25px;
            overflow-y: auto;
        }

        .chapter-title {
            font-size: 22px;
            color: #fff;
            margin-bottom: 15px;
            border-left: 3px solid var(--accent);
            padding-left: 10px;
        }

        .text-content {
            line-height: 1.6;
            font-size: 14px;
            color: #ccc;
            text-align: justify;
        }

        .text-content strong {
            color: #fff;
        }

        .text-content em {
            color: var(--accent);
            font-style: normal;
        }

        #controls {
            background: #0a0a0a;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
            margin-bottom: 15px;
        }

        button {
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #444;
            padding: 12px;
            width: 100%;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
            text-transform: uppercase;
            font-size: 12px;
        }

        button:hover {
            background: var(--accent);
            color: #111;
            border-color: var(--accent);
            box-shadow: 0 0 10px var(--accent);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(1);
            box-shadow: none;
        }

        #nav {
            padding: 15px;
            display: flex;
            gap: 10px;
            background: #000;
            border-top: 1px solid var(--border);
        }

        .nav-btn {
            flex: 1;
        }

        .next-btn {
            background: var(--accent);
            color: #111;
            border: none;
        }

        .next-btn:hover {
            background: #ffb875;
        }

        main {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: linear-gradient(to bottom, #020205, #111);
        }

        /* Overlay Labels */
        .overlay-label {
            position: absolute;
            color: var(--accent);
            font-size: 12px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.8);
            padding: 4px 8px;
            border: 1px solid var(--accent);
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        /* Status Console */
        #console-log {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.9);
            z-index: 100;
        }

        .status-safe {
            color: var(--safe);
            border-color: var(--safe) !important;
            box-shadow: 0 0 15px rgba(46, 213, 115, 0.4) !important;
        }

        .status-danger {
            color: var(--danger);
            border-color: var(--danger) !important;
            box-shadow: 0 0 15px rgba(255, 71, 87, 0.4) !important;
        }

        /* Flash overlay for lightning */
        #flash-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #fff;
            opacity: 0;
            pointer-events: none;
            mix-blend-mode: overlay;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Chapter 5: The Action of Points</div>
        </header>
        <div id="story-container">
            <div id="content"></div>
        </div>
        <div id="controls">
            <div id="dynamic-controls"></div>
        </div>
        <div id="nav">
            <button class="nav-btn" onclick="prevStep()">Back</button>
            <button class="nav-btn next-btn" id="btn-next" onclick="nextStep()">Next</button>
        </div>
    </aside>

    <main id="viewport">
        <div id="flash-overlay"></div>
        <div id="lbl-density" class="overlay-label">High Surface Charge Density (σ)</div>
        <div id="console-log">System Standby</div>
    </main>

    <script>
        // --- CONFIGURATION ---
        const sceneConfig = {
            morph: 0,
            rodSharpness: 0,
            sceneIndex: 0 // 0 = Distribution, 1 = Lightning Rod
        };

        // --- THREE.JS SETUP ---
        const viewport = document.getElementById('viewport');

        // Scene
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050508, 0.00);

        // Camera
        const camera = new THREE.PerspectiveCamera(45, viewport.offsetWidth / viewport.offsetHeight, 0.1, 500);
        camera.position.set(0, 0, 30);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(viewport.offsetWidth, viewport.offsetHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputEncoding = THREE.sRGBEncoding;
        viewport.appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
        mainLight.position.set(20, 30, 20);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        scene.add(mainLight);

        // --- SCENE 1: CHARGE DISTRIBUTION (TEARDROP) ---
        const groupDist = new THREE.Group();
        scene.add(groupDist);

        const geomDist = new THREE.SphereGeometry(6, 128, 128);
        const matDist = new THREE.MeshStandardMaterial({
            color: 0x333333, roughness: 0.4, metalness: 0.6,
            polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1
        });
        const meshDist = new THREE.Mesh(geomDist, matDist);
        meshDist.castShadow = true;
        groupDist.add(meshDist);

        // Save original positions
        const originalPos = [];
        const posAttr = geomDist.attributes.position;
        for (let i = 0; i < posAttr.count; i++) {
            originalPos.push(new THREE.Vector3().fromBufferAttribute(posAttr, i));
        }

        // Charges (Blue Electrons)
        const chargeCount = 1200;
        const chargeGeom = new THREE.SphereGeometry(0.12, 6, 6);
        const chargeMat = new THREE.MeshBasicMaterial({ color: 0x00d2ff });
        const charges = [];
        const chargeGroup = new THREE.Group();
        groupDist.add(chargeGroup);

        for (let i = 0; i < chargeCount; i++) {
            const c = new THREE.Mesh(chargeGeom, chargeMat);

            // Fibonacci Sphere Algorithm for uniform initial distribution
            const phi = Math.acos(1 - 2 * (i + 0.5) / chargeCount);
            const theta = Math.PI * (1 + Math.sqrt(5)) * i;

            const x = Math.cos(theta) * Math.sin(phi);
            const y = Math.sin(theta) * Math.sin(phi);
            const z = Math.cos(phi);

            const vec = new THREE.Vector3(x, y, z).applyAxisAngle(new THREE.Vector3(0, 0, 1), -Math.PI / 2);

            c.userData = {
                baseVec: vec.clone(),
                angleFromTip: vec.angleTo(new THREE.Vector3(1, 0, 0))
            };

            chargeGroup.add(c);
            charges.push(c);
        }

        // --- SCENE 2: DETAILED LIGHTNING ENVIRONMENT ---
        const groupRod = new THREE.Group();
        groupRod.visible = false;
        scene.add(groupRod);

        // 1. Clouds
        const cloudGroup = new THREE.Group();
        groupRod.add(cloudGroup);

        const cloudGeo = new THREE.DodecahedronGeometry(1, 0);
        const cloudMat = new THREE.MeshStandardMaterial({
            color: 0x333344, flatShading: true, roughness: 0.9, transparent: true, opacity: 0.9
        });

        for (let i = 0; i < 60; i++) {
            const puff = new THREE.Mesh(cloudGeo, cloudMat);
            const r = 10 + Math.random() * 25;
            const a = Math.random() * Math.PI * 2;
            puff.position.set(Math.cos(a) * r, 22 + Math.random() * 4, Math.sin(a) * r);
            const scale = 3 + Math.random() * 5;
            puff.scale.set(scale, scale * 0.6, scale);
            puff.rotation.set(Math.random(), Math.random(), Math.random());
            cloudGroup.add(puff);
        }

        // 2. Ground
        const groundGeo = new THREE.CircleGeometry(60, 32);
        const groundMat = new THREE.MeshStandardMaterial({
            color: 0x111611, roughness: 1, metalness: 0
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -5;
        ground.receiveShadow = true;
        groupRod.add(ground);

        // 3. Rain
        const rainGeo = new THREE.BufferGeometry();
        const rainCount = 2000;
        const rainPos = new Float32Array(rainCount * 3);
        for (let i = 0; i < rainCount * 3; i++) {
            rainPos[i] = (Math.random() - 0.5) * 80;
            if (i % 3 === 1) rainPos[i] = Math.random() * 40;
        }
        rainGeo.setAttribute('position', new THREE.BufferAttribute(rainPos, 3));
        const rainMat = new THREE.PointsMaterial({ color: 0x8899aa, size: 0.2, transparent: true, opacity: 0.4 });
        const rainSystem = new THREE.Points(rainGeo, rainMat);
        groupRod.add(rainSystem);

        // 4. House
        const bldgGroup = new THREE.Group();
        groupRod.add(bldgGroup);
        bldgGroup.position.y = -5;

        const houseBody = new THREE.Mesh(new THREE.BoxGeometry(10, 8, 10), new THREE.MeshStandardMaterial({ color: 0x4a4a4a }));
        houseBody.position.y = 4;
        houseBody.receiveShadow = true;
        houseBody.castShadow = true;
        bldgGroup.add(houseBody);

        const roofGeo = new THREE.ConeGeometry(9, 5, 4);
        const roofMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
        const roof = new THREE.Mesh(roofGeo, roofMat);
        roof.position.y = 10.5;
        roof.rotation.y = Math.PI / 4;
        bldgGroup.add(roof);

        const chimney = new THREE.Mesh(new THREE.BoxGeometry(2, 4, 2), new THREE.MeshStandardMaterial({ color: 0x5c3a3a }));
        chimney.position.set(2.5, 10, 2.5);
        bldgGroup.add(chimney);

        const winGeo = new THREE.PlaneGeometry(2, 2.5);
        const winMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xffaa00, emissiveIntensity: 0.5 });

        const w1 = new THREE.Mesh(winGeo, winMat); w1.position.set(2.5, 5, 5.01);
        const w2 = new THREE.Mesh(winGeo, winMat); w2.position.set(-2.5, 5, 5.01);
        const w3 = new THREE.Mesh(winGeo, winMat); w3.position.set(0, 5, -5.01); w3.rotation.y = Math.PI;
        bldgGroup.add(w1); bldgGroup.add(w2); bldgGroup.add(w3);

        // Rod
        const rodAssembly = new THREE.Group();
        bldgGroup.add(rodAssembly);
        rodAssembly.position.y = 12.8;

        const insulator = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1), new THREE.MeshStandardMaterial({ color: 0xeeeeee }));
        insulator.position.y = 0.5;
        rodAssembly.add(insulator);

        const mast = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 4), new THREE.MeshStandardMaterial({ color: 0x888888 }));
        mast.position.y = 2.5;
        rodAssembly.add(mast);

        const tipGeo = new THREE.CylinderGeometry(0.05, 0.1, 1.5, 16);
        tipGeo.translate(0, 0.75, 0);
        const tipMat = new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: 1.0, roughness: 0.2, emissive: 0x000000 });
        const activeTip = new THREE.Mesh(tipGeo, tipMat);
        activeTip.position.y = 4.5;
        rodAssembly.add(activeTip);

        const wirePath = new THREE.CatmullRomCurve3([
            new THREE.Vector3(0, 4.5, 0),
            new THREE.Vector3(0.3, 4, 0),
            new THREE.Vector3(0.3, -2, 5.2),
            new THREE.Vector3(0.3, -12, 5.2),
            new THREE.Vector3(2, -13, 7)
        ]);
        const wireGeo = new THREE.TubeGeometry(wirePath, 64, 0.05, 8, false);
        const wireMat = new THREE.MeshStandardMaterial({ color: 0x222222, emissive: 0x000000 });
        const wire = new THREE.Mesh(wireGeo, wireMat);
        rodAssembly.add(wire);

        // --- LOGIC ---

        function getDeformedPosition(dir, morph) {
            const R = 6;
            const v = dir.clone();
            v.multiplyScalar(R);

            if (v.x > 0) {
                const factor = 1 + morph * 2.2;
                v.x *= factor;

                const xNorm = v.x / (R * factor);
                let pinch = 1.0;
                if (morph > 0) {
                    pinch = Math.pow(Math.cos(xNorm * Math.PI / 2 * 0.95), morph * 1.5);
                }
                v.y *= pinch;
                v.z *= pinch;
            } else {
                v.x *= (1 - morph * 0.1);
            }
            return v;
        }

        function updateTeardrop() {
            if (!groupDist.visible) return;

            const m = sceneConfig.morph;
            const positions = meshDist.geometry.attributes.position;

            for (let i = 0; i < originalPos.length; i++) {
                const v = originalPos[i].clone().normalize();
                const newPos = getDeformedPosition(v, m);
                positions.setXYZ(i, newPos.x, newPos.y, newPos.z);
            }
            positions.needsUpdate = true;
            meshDist.geometry.computeVertexNormals();

            charges.forEach(c => {
                const originalDir = c.userData.baseVec.clone();
                const angle = c.userData.angleFromTip;

                // Physics Simulation Approximation:
                // As m increases, the component of repulsive force tangent to the surface 
                // decreases near the tip due to high curvature.
                let bias = 0;
                if (m > 0) {
                    const slide = (1 - Math.cos(angle)) * 0.5;
                    bias = m * (1 - slide) * 0.7;
                }

                const newAngle = angle * (1 - bias);
                const axis = new THREE.Vector3(1, 0, 0).cross(originalDir).normalize();
                if (axis.lengthSq() > 0) {
                    originalDir.set(1, 0, 0).applyAxisAngle(axis, newAngle);
                }

                const finalPos = getDeformedPosition(originalDir, m);
                const normal = finalPos.clone().normalize();
                c.position.copy(finalPos).add(normal.multiplyScalar(0.15));
            });

            const lblDen = document.getElementById('lbl-density');
            if (m > 0.8) {
                const tipPos = new THREE.Vector3(19, 0, 0);
                tipPos.project(camera);
                const x = (tipPos.x * .5 + .5) * viewport.offsetWidth;
                const y = (-(tipPos.y * .5) + .5) * viewport.offsetHeight;
                lblDen.style.left = x + 'px'; lblDen.style.top = (y - 50) + 'px'; lblDen.style.opacity = 1;
            } else {
                lblDen.style.opacity = 0;
            }
        }

        function updateRod() {
            if (!groupRod.visible) return;
            cloudGroup.rotation.y += 0.001;
            const positions = rainSystem.geometry.attributes.position.array;
            for (let i = 1; i < positions.length; i += 3) {
                positions[i] -= 0.8;
                if (positions[i] < 0) positions[i] = 40;
            }
            rainSystem.geometry.attributes.position.needsUpdate = true;

            const s = sceneConfig.rodSharpness;
            const thickness = 2.0 - (s * 1.95);
            activeTip.scale.set(thickness, 1 + s * 2, thickness);
        }

        const tweens = [];
        function simpleTween(obj, prop, target, duration) {
            const start = obj[prop].getHex();
            const startTime = Date.now();
            const tObj = {
                update: () => {
                    const now = Date.now();
                    const p = Math.min((now - startTime) / duration, 1);
                    const c1 = new THREE.Color(start);
                    const c2 = new THREE.Color(target);
                    obj[prop].copy(c1.lerp(c2, p));
                    return p < 1;
                }
            };
            tweens.push(tObj);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            for (let i = tweens.length - 1; i >= 0; i--) {
                if (!tweens[i].update()) tweens.splice(i, 1);
            }
            if (sceneConfig.sceneIndex === 0) updateTeardrop();
            else updateRod();
            renderer.render(scene, camera);
        }
        animate();

        // --- LIGHTNING SYSTEM ---

        function showStatus(text, type) {
            const el = document.getElementById('console-log');
            el.innerText = text;
            el.className = type === 'safe' ? 'status-safe' : 'status-danger';
            el.style.opacity = 1;
            setTimeout(() => { el.style.opacity = 0; }, 4000);
        }

        function createLightningBranch(start, end, depth, maxDepth) {
            const points = [];
            const distance = start.distanceTo(end);
            const steps = 10;
            let curr = start.clone();

            for (let i = 0; i <= steps; i++) {
                points.push(curr.clone());
                const prog = i / steps;
                const target = new THREE.Vector3().lerpVectors(start, end, prog);
                const jitterAmp = Math.sin(prog * Math.PI) * (distance * 0.15);
                const offset = new THREE.Vector3(
                    (Math.random() - .5) * jitterAmp,
                    (Math.random() - .5) * jitterAmp,
                    (Math.random() - .5) * jitterAmp
                );
                curr.copy(target).add(offset);
            }
            points[points.length - 1].copy(end);

            const geo = new THREE.BufferGeometry().setFromPoints(points);
            const mat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const line = new THREE.Line(geo, mat);
            groupRod.add(line);

            if (depth < maxDepth && Math.random() > 0.3) {
                const idx = Math.floor(Math.random() * (points.length - 2)) + 1;
                const subStart = points[idx];
                const subEnd = subStart.clone().add(new THREE.Vector3(
                    (Math.random() - 0.5) * 5,
                    -5 - Math.random() * 5,
                    (Math.random() - 0.5) * 5
                ));
                const subBranch = createLightningBranch(subStart, subEnd, depth + 1, maxDepth);
                line.userData.children = [subBranch];
            }

            return line;
        }

        function removeLightning(obj) {
            if (obj.userData.children) {
                obj.userData.children.forEach(c => removeLightning(c));
            }
            if (obj.parent) obj.parent.remove(obj);
            if (obj.geometry) obj.geometry.dispose();
        }

        function triggerLightning() {
            // Lower threshold (0.5) to allow easier visualization of success
            const isSharp = sceneConfig.rodSharpness > 0.5;
            const start = new THREE.Vector3(0, 25, 0);

            let end, msg;
            const boltColor = 0xffffff;

            if (isSharp) {
                const tipY = 12.8 + 0.5 + 2.5 + 1.5 + (sceneConfig.rodSharpness);
                end = new THREE.Vector3(0, tipY, 0);
                msg = "FIELD INTENSITY CRITICAL.\nPILOT STREAMER ESTABLISHED.";

                setTimeout(() => {
                    wire.material.emissive.setHex(0x00ffff);
                    wire.material.color.setHex(0xffffff);
                    activeTip.material.emissive.setHex(0xffaa00);

                    simpleTween(wire.material, 'emissive', 0x000000, 1500);
                    simpleTween(wire.material, 'color', 0x222222, 1500);
                    simpleTween(activeTip.material, 'emissive', 0x000000, 1000);
                }, 50);

                showStatus(msg, 'safe');
            } else {
                const angle = Math.random() * Math.PI * 2;
                end = new THREE.Vector3(Math.cos(angle) * 5, 12, Math.sin(angle) * 5);
                msg = "INSUFFICIENT IONIZATION.\nLEADER CONNECTION FAILED.";
                showStatus(msg, 'danger');
            }

            const mainBolt = createLightningBranch(start, end, 0, 2);

            const flash = new THREE.PointLight(boltColor, 20, 100);
            flash.position.set(0, 15, 0);
            groupRod.add(flash);

            scene.fog.color.setHex(0x333333);

            const overlay = document.getElementById('flash-overlay');
            overlay.style.opacity = 0.6;
            setTimeout(() => overlay.style.opacity = 0, 100);

            let shake = 0;
            const shaker = setInterval(() => {
                shake++;
                camera.position.x += (Math.random() - 0.5) * 0.5;
                camera.position.y += (Math.random() - 0.5) * 0.5;
                if (shake > 8) clearInterval(shaker);
            }, 16);

            setTimeout(() => {
                removeLightning(mainBolt);
                groupRod.remove(flash);
                scene.fog.color.setHex(0x050508);
            }, 120 + Math.random() * 100);
        }

        // --- STORY ENGINE ---
        const steps = [
            {
                title: "Electrostatic Equilibrium",
                text: "Free charges on a conductive surface will always move to achieve equilibrium. Governed by <em>Coulomb's Law</em>, like charges repel one another with a force inversely proportional to the square of their distance.<br><br>On a sphere, the surface curvature is constant. Therefore, the only way for the net force on any single electron to be zero is for them to distribute themselves perfectly evenly across the surface area.",
                controls: `<div style="padding:10px; color:#666; font-size:12px; text-align:center;">Rotate camera to inspect the uniform field.</div>`,
                setup: () => {
                    sceneConfig.sceneIndex = 0;
                    sceneConfig.morph = 0;
                    groupDist.visible = true; groupRod.visible = false;
                    scene.fog.density = 0;
                    scene.fog.color.setHex(0x050508);
                    camera.position.set(0, 0, 30);
                    controls.target.set(0, 0, 0);
                }
            },
            {
                title: "Geometry and Repulsion",
                text: "Observe what occurs as we deform the sphere into a teardrop. At the flatter end, charges push their neighbors away effectively because the repulsive force vector is mostly tangential to the surface.<br><br>However, at the sharp tip, the surface curves away rapidly. The component of the repulsive force pushing charges 'sideways' (away from the tip) diminishes. Consequently, charges must pack much tighter to create enough repulsive force to balance the system. This results in extremely high <strong>Surface Charge Density (σ)</strong> at the point.",
                controls: `
                <label>Radius of Curvature</label>
                <input type="range" min="0" max="1" step="0.01" value="0" oninput="setMorph(this.value)">
                <div style="display:flex; justify-content:space-between; font-size:10px; color:#555;">
                    <span>Uniform (R=C)</span><span>Sharp (R→0)</span>
                </div>
            `,
                setup: () => { },
            },
            {
                title: "Conclusion",
                text: "We apply this principle to a Lightning Rod. The electric field <em>E</em> just outside a conductor is directly proportional to the charge density (<em>E = σ/ε₀</em>).<br><br>A sharp tip creates such a massive electric field that it rips electrons off nearby air molecules (Ionization). This creates a conductive plasma channel—a <strong>Pilot Streamer</strong>—that rises to meet the downward lightning leader. A blunt rod fails to generate enough field intensity to initiate this connection, leaving the strike point to chance.",
                controls: `
                <label>Tip Geometry (Field Intensity)</label>
                <input type="range" min="0" max="1" step="0.05" value="0" oninput="setSharpness(this.value)">
                <br>
                <button onclick="triggerLightning()">Initiate Storm</button>
            `,
                setup: () => {
                    sceneConfig.sceneIndex = 1;
                    groupDist.visible = false; groupRod.visible = true;
                    scene.fog.density = 0.02;
                    camera.position.set(25, 15, 25);
                    controls.target.set(0, 8, 0);
                    document.getElementById('lbl-density').style.opacity = 0;
                    document.getElementById('btn-next').innerText = "Next Lesson";
                    document.getElementById('btn-next').disabled = false;
                }
            }
        ];

        let currentStep = 0;
        function loadStep(idx) {
            currentStep = idx;
            const s = steps[idx];
            document.querySelector('#story-container').innerHTML = `
            <div class="chapter-title">${s.title}</div>
            <div class="text-content">${s.text}</div>
        `;
            document.getElementById('dynamic-controls').innerHTML = s.controls;
            s.setup();

            const btn = document.getElementById('btn-next');
            if (currentStep === steps.length - 1) {
                btn.innerHTML = "Next Lesson";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next";
                btn.disabled = false;
            }
        }

        function nextStep() {
            if (currentStep < steps.length - 1) {
                loadStep(currentStep + 1);
            } else {
                window.parent.location.href = '/lesson/chapter6/field_energy';
            }
        }

        function prevStep() { if (currentStep > 0) loadStep(currentStep - 1); }

        window.setMorph = (val) => { sceneConfig.morph = parseFloat(val); };
        window.setSharpness = (val) => { sceneConfig.rodSharpness = parseFloat(val); };

        loadStep(0);

        window.addEventListener('resize', () => {
            camera.aspect = viewport.offsetWidth / viewport.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewport.offsetWidth, viewport.offsetHeight);
        });

    </script>
</body>

</html>