

===== START OF 10_charge_dist_non_spherical.html =====

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Maxwell's Notebook: The Action of Points</title>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        :root {
            --bg: #050508;
            --panel: #141416;
            --text: #e0e0e0;
            --accent: #ff9f43;
            --danger: #ff4757;
            --safe: #2ed573;
            --border: #333;
        }

        body { margin: 0; height: 100vh; display: flex; background: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        
        aside {
            width: 400px; background: var(--panel); border-right: 1px solid var(--border);
            display: flex; flex-direction: column; z-index: 10; box-shadow: 10px 0 30px rgba(0,0,0,0.8);
        }

        header { padding: 20px; background: rgba(0,0,0,0.5); border-bottom: 1px solid var(--border); }
        h1 { margin: 0; font-size: 18px; color: var(--accent); text-transform: uppercase; letter-spacing: 2px; }
        .subtitle { font-size: 12px; color: #888; margin-top: 5px; }

        #story-container { flex: 1; padding: 25px; overflow-y: auto; }
        .chapter-title { font-size: 22px; color: #fff; margin-bottom: 15px; border-left: 3px solid var(--accent); padding-left: 10px; }
        .text-content { line-height: 1.6; font-size: 14px; color: #ccc; text-align: justify; }
        .text-content strong { color: #fff; }
        .text-content em { color: var(--accent); font-style: normal; }

        #controls { background: #0a0a0a; padding: 20px; border-top: 1px solid var(--border); }
        label { display: block; font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
        input[type=range] { width: 100%; accent-color: var(--accent); cursor: pointer; margin-bottom: 15px; }
        
        button {
            background: #2a2a2a; color: #fff; border: 1px solid #444; padding: 12px;
            width: 100%; cursor: pointer; font-weight: bold; transition: 0.2s; text-transform: uppercase; font-size: 12px;
        }
        button:hover { background: var(--accent); color: #111; border-color: var(--accent); box-shadow: 0 0 10px var(--accent); }
        button:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); box-shadow: none; }

        #nav { padding: 15px; display: flex; gap: 10px; background: #000; border-top: 1px solid var(--border); }
        .nav-btn { flex: 1; }
        .next-btn { background: var(--accent); color: #111; border: none; }
        .next-btn:hover { background: #ffb875; }

        main { flex: 1; position: relative; overflow: hidden; background: linear-gradient(to bottom, #020205, #111); }
        
        /* Overlay Labels */
        .overlay-label {
            position: absolute; color: var(--accent); font-size: 12px; font-weight: bold;
            background: rgba(0,0,0,0.8); padding: 4px 8px; border: 1px solid var(--accent);
            border-radius: 4px; pointer-events: none; opacity: 0; transition: opacity 0.3s;
        }

        /* Status Console */
        #console-log {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 400px; text-align: center;
            background: rgba(0,0,0,0.9); border: 1px solid #444; border-radius: 8px;
            padding: 15px; font-family: 'Courier New', monospace; font-size: 14px;
            pointer-events: none; opacity: 0; transition: opacity 0.5s;
            box-shadow: 0 0 30px rgba(0,0,0,0.9); z-index: 100;
        }
        .status-safe { color: var(--safe); border-color: var(--safe) !important; box-shadow: 0 0 15px rgba(46, 213, 115, 0.4) !important; }
        .status-danger { color: var(--danger); border-color: var(--danger) !important; box-shadow: 0 0 15px rgba(255, 71, 87, 0.4) !important; }

        /* Flash overlay for lightning */
        #flash-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: #fff; opacity: 0; pointer-events: none; mix-blend-mode: overlay;
        }

    </style>
</head>
<body>

<aside>
    <header>
        <h1>Maxwell's Notebook</h1>
        <div class="subtitle">Chapter 8: The Action of Points</div>
    </header>
    <div id="story-container">
        <div id="content"></div>
    </div>
    <div id="controls">
        <div id="dynamic-controls"></div>
    </div>
    <div id="nav">
        <button class="nav-btn" onclick="prevStep()">Back</button>
        <button class="nav-btn next-btn" id="btn-next" onclick="nextStep()">Next</button>
    </div>
</aside>

<main id="viewport">
    <div id="flash-overlay"></div>
    <div id="lbl-density" class="overlay-label">High Surface Charge Density (σ)</div>
    <div id="console-log">System Standby</div>
</main>

<script>
    // --- CONFIGURATION ---
    const sceneConfig = {
        morph: 0,
        rodSharpness: 0,
        sceneIndex: 0 // 0 = Distribution, 1 = Lightning Rod
    };

    // --- THREE.JS SETUP ---
    const viewport = document.getElementById('viewport');
    
    // Scene
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050508, 0.00);

    // Camera
    const camera = new THREE.PerspectiveCamera(45, viewport.offsetWidth / viewport.offsetHeight, 0.1, 500);
    camera.position.set(0, 0, 30);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(viewport.offsetWidth, viewport.offsetHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.outputEncoding = THREE.sRGBEncoding;
    viewport.appendChild(renderer.domElement);

    // Controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // --- LIGHTING ---
    const ambientLight = new THREE.AmbientLight(0x404060, 0.5); 
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
    mainLight.position.set(20, 30, 20);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 2048;
    mainLight.shadow.mapSize.height = 2048;
    scene.add(mainLight);

    // --- SCENE 1: CHARGE DISTRIBUTION (TEARDROP) ---
    const groupDist = new THREE.Group();
    scene.add(groupDist);

    const geomDist = new THREE.SphereGeometry(6, 128, 128); 
    const matDist = new THREE.MeshStandardMaterial({
        color: 0x333333, roughness: 0.4, metalness: 0.6,
        polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1
    });
    const meshDist = new THREE.Mesh(geomDist, matDist);
    meshDist.castShadow = true;
    groupDist.add(meshDist);

    // Save original positions
    const originalPos = [];
    const posAttr = geomDist.attributes.position;
    for(let i=0; i<posAttr.count; i++){
        originalPos.push(new THREE.Vector3().fromBufferAttribute(posAttr, i));
    }

    // Charges (Blue Electrons)
    const chargeCount = 1200; 
    const chargeGeom = new THREE.SphereGeometry(0.12, 6, 6);
    const chargeMat = new THREE.MeshBasicMaterial({ color: 0x00d2ff });
    const charges = [];
    const chargeGroup = new THREE.Group();
    groupDist.add(chargeGroup);

    for(let i=0; i<chargeCount; i++) {
        const c = new THREE.Mesh(chargeGeom, chargeMat);
        
        // Fibonacci Sphere Algorithm for uniform initial distribution
        const phi = Math.acos(1 - 2 * (i + 0.5) / chargeCount);
        const theta = Math.PI * (1 + Math.sqrt(5)) * i;
        
        const x = Math.cos(theta) * Math.sin(phi);
        const y = Math.sin(theta) * Math.sin(phi);
        const z = Math.cos(phi);
        
        const vec = new THREE.Vector3(x, y, z).applyAxisAngle(new THREE.Vector3(0,0,1), -Math.PI/2);

        c.userData = { 
            baseVec: vec.clone(),
            angleFromTip: vec.angleTo(new THREE.Vector3(1, 0, 0)) 
        };
        
        chargeGroup.add(c);
        charges.push(c);
    }

    // --- SCENE 2: DETAILED LIGHTNING ENVIRONMENT ---
    const groupRod = new THREE.Group();
    groupRod.visible = false;
    scene.add(groupRod);

    // 1. Clouds
    const cloudGroup = new THREE.Group();
    groupRod.add(cloudGroup);
    
    const cloudGeo = new THREE.DodecahedronGeometry(1, 0);
    const cloudMat = new THREE.MeshStandardMaterial({ 
        color: 0x333344, flatShading: true, roughness: 0.9, transparent: true, opacity: 0.9 
    });
    
    for(let i=0; i<60; i++) {
        const puff = new THREE.Mesh(cloudGeo, cloudMat);
        const r = 10 + Math.random() * 25;
        const a = Math.random() * Math.PI * 2;
        puff.position.set(Math.cos(a)*r, 22 + Math.random()*4, Math.sin(a)*r);
        const scale = 3 + Math.random() * 5;
        puff.scale.set(scale, scale*0.6, scale);
        puff.rotation.set(Math.random(), Math.random(), Math.random());
        cloudGroup.add(puff);
    }

    // 2. Ground
    const groundGeo = new THREE.CircleGeometry(60, 32);
    const groundMat = new THREE.MeshStandardMaterial({ 
        color: 0x111611, roughness: 1, metalness: 0 
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.position.y = -5;
    ground.receiveShadow = true;
    groupRod.add(ground);

    // 3. Rain
    const rainGeo = new THREE.BufferGeometry();
    const rainCount = 2000;
    const rainPos = new Float32Array(rainCount * 3);
    for(let i=0; i<rainCount*3; i++) {
        rainPos[i] = (Math.random()-0.5)*80;
        if (i%3===1) rainPos[i] = Math.random() * 40; 
    }
    rainGeo.setAttribute('position', new THREE.BufferAttribute(rainPos, 3));
    const rainMat = new THREE.PointsMaterial({ color: 0x8899aa, size: 0.2, transparent: true, opacity: 0.4 });
    const rainSystem = new THREE.Points(rainGeo, rainMat);
    groupRod.add(rainSystem);

    // 4. House
    const bldgGroup = new THREE.Group();
    groupRod.add(bldgGroup);
    bldgGroup.position.y = -5;

    const houseBody = new THREE.Mesh(new THREE.BoxGeometry(10, 8, 10), new THREE.MeshStandardMaterial({ color: 0x4a4a4a }));
    houseBody.position.y = 4;
    houseBody.receiveShadow = true;
    houseBody.castShadow = true;
    bldgGroup.add(houseBody);

    const roofGeo = new THREE.ConeGeometry(9, 5, 4);
    const roofMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
    const roof = new THREE.Mesh(roofGeo, roofMat);
    roof.position.y = 10.5;
    roof.rotation.y = Math.PI/4;
    bldgGroup.add(roof);

    const chimney = new THREE.Mesh(new THREE.BoxGeometry(2, 4, 2), new THREE.MeshStandardMaterial({ color: 0x5c3a3a }));
    chimney.position.set(2.5, 10, 2.5);
    bldgGroup.add(chimney);

    const winGeo = new THREE.PlaneGeometry(2, 2.5);
    const winMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xffaa00, emissiveIntensity: 0.5 });
    
    const w1 = new THREE.Mesh(winGeo, winMat); w1.position.set(2.5, 5, 5.01);
    const w2 = new THREE.Mesh(winGeo, winMat); w2.position.set(-2.5, 5, 5.01);
    const w3 = new THREE.Mesh(winGeo, winMat); w3.position.set(0, 5, -5.01); w3.rotation.y = Math.PI;
    bldgGroup.add(w1); bldgGroup.add(w2); bldgGroup.add(w3);

    // Rod
    const rodAssembly = new THREE.Group();
    bldgGroup.add(rodAssembly);
    rodAssembly.position.y = 12.8;

    const insulator = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1), new THREE.MeshStandardMaterial({ color: 0xeeeeee }));
    insulator.position.y = 0.5;
    rodAssembly.add(insulator);

    const mast = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 4), new THREE.MeshStandardMaterial({ color: 0x888888 }));
    mast.position.y = 2.5;
    rodAssembly.add(mast);

    const tipGeo = new THREE.CylinderGeometry(0.05, 0.1, 1.5, 16);
    tipGeo.translate(0, 0.75, 0); 
    const tipMat = new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: 1.0, roughness: 0.2, emissive: 0x000000 });
    const activeTip = new THREE.Mesh(tipGeo, tipMat);
    activeTip.position.y = 4.5;
    rodAssembly.add(activeTip);

    const wirePath = new THREE.CatmullRomCurve3([
        new THREE.Vector3(0, 4.5, 0),
        new THREE.Vector3(0.3, 4, 0),
        new THREE.Vector3(0.3, -2, 5.2),
        new THREE.Vector3(0.3, -12, 5.2),
        new THREE.Vector3(2, -13, 7)
    ]);
    const wireGeo = new THREE.TubeGeometry(wirePath, 64, 0.05, 8, false);
    const wireMat = new THREE.MeshStandardMaterial({ color: 0x222222, emissive: 0x000000 });
    const wire = new THREE.Mesh(wireGeo, wireMat);
    rodAssembly.add(wire);

    // --- LOGIC ---

    function getDeformedPosition(dir, morph) {
        const R = 6;
        const v = dir.clone();
        v.multiplyScalar(R);
        
        if(v.x > 0) {
            const factor = 1 + morph * 2.2; 
            v.x *= factor;
            
            const xNorm = v.x / (R * factor);
            let pinch = 1.0;
            if (morph > 0) {
                 pinch = Math.pow(Math.cos(xNorm * Math.PI / 2 * 0.95), morph * 1.5);
            }
            v.y *= pinch;
            v.z *= pinch;
        } else {
            v.x *= (1 - morph * 0.1);
        }
        return v;
    }

    function updateTeardrop() {
        if (!groupDist.visible) return;

        const m = sceneConfig.morph;
        const positions = meshDist.geometry.attributes.position;
        
        for (let i = 0; i < originalPos.length; i++) {
            const v = originalPos[i].clone().normalize();
            const newPos = getDeformedPosition(v, m);
            positions.setXYZ(i, newPos.x, newPos.y, newPos.z);
        }
        positions.needsUpdate = true;
        meshDist.geometry.computeVertexNormals();

        charges.forEach(c => {
            const originalDir = c.userData.baseVec.clone();
            const angle = c.userData.angleFromTip;
            
            // Physics Simulation Approximation:
            // As m increases, the component of repulsive force tangent to the surface 
            // decreases near the tip due to high curvature.
            let bias = 0;
            if (m > 0) {
                const slide = (1 - Math.cos(angle)) * 0.5; 
                bias = m * (1 - slide) * 0.7; 
            }
            
            const newAngle = angle * (1 - bias);
            const axis = new THREE.Vector3(1,0,0).cross(originalDir).normalize();
            if(axis.lengthSq() > 0) {
                originalDir.set(1,0,0).applyAxisAngle(axis, newAngle);
            }

            const finalPos = getDeformedPosition(originalDir, m);
            const normal = finalPos.clone().normalize(); 
            c.position.copy(finalPos).add(normal.multiplyScalar(0.15));
        });

        const lblDen = document.getElementById('lbl-density');
        if(m > 0.8) {
            const tipPos = new THREE.Vector3(19, 0, 0);
            tipPos.project(camera);
            const x = (tipPos.x * .5 + .5) * viewport.offsetWidth;
            const y = (-(tipPos.y * .5) + .5) * viewport.offsetHeight;
            lblDen.style.left = x + 'px'; lblDen.style.top = (y - 50) + 'px'; lblDen.style.opacity = 1;
        } else {
            lblDen.style.opacity = 0;
        }
    }

    function updateRod() {
        if (!groupRod.visible) return;
        cloudGroup.rotation.y += 0.001;
        const positions = rainSystem.geometry.attributes.position.array;
        for(let i=1; i<positions.length; i+=3) {
            positions[i] -= 0.8; 
            if(positions[i] < 0) positions[i] = 40; 
        }
        rainSystem.geometry.attributes.position.needsUpdate = true;

        const s = sceneConfig.rodSharpness;
        const thickness = 2.0 - (s * 1.95); 
        activeTip.scale.set(thickness, 1 + s*2, thickness);
    }

    const tweens = [];
    function simpleTween(obj, prop, target, duration) {
        const start = obj[prop].getHex();
        const startTime = Date.now();
        const tObj = {
            update: () => {
                const now = Date.now();
                const p = Math.min((now - startTime) / duration, 1);
                const c1 = new THREE.Color(start);
                const c2 = new THREE.Color(target);
                obj[prop].copy(c1.lerp(c2, p));
                return p < 1;
            }
        };
        tweens.push(tObj);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        for(let i=tweens.length-1; i>=0; i--) {
            if(!tweens[i].update()) tweens.splice(i, 1);
        }
        if (sceneConfig.sceneIndex === 0) updateTeardrop();
        else updateRod();
        renderer.render(scene, camera);
    }
    animate();
    
    // --- LIGHTNING SYSTEM ---

    function showStatus(text, type) {
        const el = document.getElementById('console-log');
        el.innerText = text;
        el.className = type === 'safe' ? 'status-safe' : 'status-danger';
        el.style.opacity = 1;
        setTimeout(() => { el.style.opacity = 0; }, 4000);
    }

    function createLightningBranch(start, end, depth, maxDepth) {
        const points = [];
        const distance = start.distanceTo(end);
        const steps = 10;
        let curr = start.clone();

        for(let i=0; i<=steps; i++){
            points.push(curr.clone());
            const prog = i/steps;
            const target = new THREE.Vector3().lerpVectors(start, end, prog);
            const jitterAmp = Math.sin(prog * Math.PI) * (distance * 0.15); 
            const offset = new THREE.Vector3(
                (Math.random()-.5)*jitterAmp, 
                (Math.random()-.5)*jitterAmp, 
                (Math.random()-.5)*jitterAmp
            );
            curr.copy(target).add(offset);
        }
        points[points.length-1].copy(end); 

        const geo = new THREE.BufferGeometry().setFromPoints(points);
        const mat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
        const line = new THREE.Line(geo, mat);
        groupRod.add(line);

        if (depth < maxDepth && Math.random() > 0.3) {
            const idx = Math.floor(Math.random() * (points.length - 2)) + 1;
            const subStart = points[idx];
            const subEnd = subStart.clone().add(new THREE.Vector3(
                (Math.random()-0.5)*5, 
                -5 - Math.random()*5, 
                (Math.random()-0.5)*5
            ));
            const subBranch = createLightningBranch(subStart, subEnd, depth + 1, maxDepth);
            line.userData.children = [subBranch]; 
        }

        return line;
    }

    function removeLightning(obj) {
        if(obj.userData.children) {
            obj.userData.children.forEach(c => removeLightning(c));
        }
        if(obj.parent) obj.parent.remove(obj);
        if(obj.geometry) obj.geometry.dispose();
    }

    function triggerLightning() {
        // Lower threshold (0.5) to allow easier visualization of success
        const isSharp = sceneConfig.rodSharpness > 0.5;
        const start = new THREE.Vector3(0, 25, 0); 
        
        let end, msg;
        const boltColor = 0xffffff; 
        
        if(isSharp) {
            const tipY = 12.8 + 0.5 + 2.5 + 1.5 + (sceneConfig.rodSharpness);
            end = new THREE.Vector3(0, tipY, 0); 
            msg = "FIELD INTENSITY CRITICAL.\nPILOT STREAMER ESTABLISHED.";
            
            setTimeout(() => {
                wire.material.emissive.setHex(0x00ffff);
                wire.material.color.setHex(0xffffff);
                activeTip.material.emissive.setHex(0xffaa00);
                
                simpleTween(wire.material, 'emissive', 0x000000, 1500);
                simpleTween(wire.material, 'color', 0x222222, 1500);
                simpleTween(activeTip.material, 'emissive', 0x000000, 1000);
            }, 50);

            showStatus(msg, 'safe');
        } else {
            const angle = Math.random() * Math.PI * 2;
            end = new THREE.Vector3(Math.cos(angle)*5, 12, Math.sin(angle)*5);
            msg = "INSUFFICIENT IONIZATION.\nLEADER CONNECTION FAILED.";
            showStatus(msg, 'danger');
        }

        const mainBolt = createLightningBranch(start, end, 0, 2);

        const flash = new THREE.PointLight(boltColor, 20, 100);
        flash.position.set(0, 15, 0);
        groupRod.add(flash);
        
        scene.fog.color.setHex(0x333333); 
        
        const overlay = document.getElementById('flash-overlay');
        overlay.style.opacity = 0.6;
        setTimeout(() => overlay.style.opacity = 0, 100);

        let shake = 0;
        const shaker = setInterval(() => {
            shake++;
            camera.position.x += (Math.random()-0.5)*0.5;
            camera.position.y += (Math.random()-0.5)*0.5;
            if(shake > 8) clearInterval(shaker);
        }, 16);

        setTimeout(() => {
            removeLightning(mainBolt);
            groupRod.remove(flash);
            scene.fog.color.setHex(0x050508);
        }, 120 + Math.random()*100);
    }

    // --- STORY ENGINE ---
    const steps = [
        {
            title: "Electrostatic Equilibrium",
            text: "Free charges on a conductive surface will always move to achieve equilibrium. Governed by <em>Coulomb's Law</em>, like charges repel one another with a force inversely proportional to the square of their distance.<br><br>On a sphere, the surface curvature is constant. Therefore, the only way for the net force on any single electron to be zero is for them to distribute themselves perfectly evenly across the surface area.",
            controls: `<div style="padding:10px; color:#666; font-size:12px; text-align:center;">Rotate camera to inspect the uniform field.</div>`,
            setup: () => {
                sceneConfig.sceneIndex = 0;
                sceneConfig.morph = 0;
                groupDist.visible = true; groupRod.visible = false;
                scene.fog.density = 0;
                scene.fog.color.setHex(0x050508);
                camera.position.set(0, 0, 30);
                controls.target.set(0,0,0);
            }
        },
        {
            title: "Geometry and Repulsion",
            text: "Observe what occurs as we deform the sphere into a teardrop. At the flatter end, charges push their neighbors away effectively because the repulsive force vector is mostly tangential to the surface.<br><br>However, at the sharp tip, the surface curves away rapidly. The component of the repulsive force pushing charges 'sideways' (away from the tip) diminishes. Consequently, charges must pack much tighter to create enough repulsive force to balance the system. This results in extremely high <strong>Surface Charge Density (σ)</strong> at the point.",
            controls: `
                <label>Radius of Curvature</label>
                <input type="range" min="0" max="1" step="0.01" value="0" oninput="setMorph(this.value)">
                <div style="display:flex; justify-content:space-between; font-size:10px; color:#555;">
                    <span>Uniform (R=C)</span><span>Sharp (R→0)</span>
                </div>
            `,
            setup: () => {},
        },
        {
            title: "Dielectric Breakdown",
            text: "We apply this principle to a Lightning Rod. The electric field <em>E</em> just outside a conductor is directly proportional to the charge density (<em>E = σ/ε₀</em>).<br><br>A sharp tip creates such a massive electric field that it rips electrons off nearby air molecules (Ionization). This creates a conductive plasma channel—a <strong>Pilot Streamer</strong>—that rises to meet the downward lightning leader. A blunt rod fails to generate enough field intensity to initiate this connection, leaving the strike point to chance.",
            controls: `
                <label>Tip Geometry (Field Intensity)</label>
                <input type="range" min="0" max="1" step="0.05" value="0" oninput="setSharpness(this.value)">
                <br>
                <button onclick="triggerLightning()">Initiate Storm</button>
            `,
            setup: () => {
                sceneConfig.sceneIndex = 1;
                groupDist.visible = false; groupRod.visible = true;
                scene.fog.density = 0.02;
                camera.position.set(25, 15, 25);
                controls.target.set(0, 8, 0);
                document.getElementById('lbl-density').style.opacity = 0;
            }
        }
    ];

    let currentStep = 0;
    function loadStep(idx) {
        currentStep = idx;
        const s = steps[idx];
        document.querySelector('#story-container').innerHTML = `
            <div class="chapter-title">${s.title}</div>
            <div class="text-content">${s.text}</div>
        `;
        document.getElementById('dynamic-controls').innerHTML = s.controls;
        s.setup();
        document.getElementById('btn-next').disabled = (idx === steps.length - 1);
    }

    function nextStep() { if(currentStep < steps.length-1) loadStep(currentStep+1); }
    function prevStep() { if(currentStep > 0) loadStep(currentStep-1); }

    window.setMorph = (val) => { sceneConfig.morph = parseFloat(val); };
    window.setSharpness = (val) => { sceneConfig.rodSharpness = parseFloat(val); };

    loadStep(0);
    
    window.addEventListener('resize', () => {
        camera.aspect = viewport.offsetWidth / viewport.offsetHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(viewport.offsetWidth, viewport.offsetHeight);
    });

</script>
</body>
</html>

===== END OF 10_charge_dist_non_spherical.html =====


===== START OF 1_conservative_forces.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Conservative Forces & The Closed Loop Integral</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        .math-block {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #333;
            color: #fff;
            text-align: center;
        }

        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            border: none;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }

        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Chapter 5: Electric Potential</div>
        </header>

        <div id="story-container">
            <div id="chapter-content"></div>
        </div>

        <div id="controls-area">
            <div class="control-row" id="ctrl-intro">
                <label>Step 1: Place Charge</label>
                <button id="btn-intro" onclick="placeCharge()">Add Source Charge (+Q)</button>
            </div>

            <div class="control-row" id="ctrl-path">
                <label>Step 2: Draw Path</label>
                <button id="btn-path" onclick="drawClosedPath()">Show Closed Loop Path</button>
            </div>

            <div class="control-row" id="ctrl-calc">
                <label>Step 3: Calculate Integral</label>
                <button id="btn-calc" onclick="calculateIntegral()">∮ E · dl = ?</button>
            </div>

            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Experiment Control</label>
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Electric Field</div>
    </main>

    <script>
        const state = {
            chargeVisible: false,
            pathVisible: false,
            integralCalculated: false,
            time: 0
        };

        const scene = new THREE.Scene();
        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 40;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );
        camera.position.set(20, 25, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('world').appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8, metalness: 0.2 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -10;
        floor.receiveShadow = true;
        scene.background = new THREE.Color(0x151515);

        const gridHelper = new THREE.GridHelper(100, 20, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -9.9;
        scene.add(floor);
        scene.add(gridHelper);

        // Source Charge
        const sourceGroup = new THREE.Group();
        const sourceGeo = new THREE.IcosahedronGeometry(3, 1);
        const sourceMat = new THREE.MeshStandardMaterial({ color: 0xff6b6b, flatShading: true, emissive: 0x550000 });
        const sourceMesh = new THREE.Mesh(sourceGeo, sourceMat);
        sourceMesh.castShadow = true;
        sourceGroup.add(sourceMesh);
        scene.add(sourceGroup);
        sourceGroup.visible = false;

        // Field Lines
        const fieldGroup = new THREE.Group();
        for (let r = 6; r < 25; r += 6) {
            const count = r * 1.5;
            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2;
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;

                const arrowGeo = new THREE.CylinderGeometry(0.1, 0.1, 2, 4);
                arrowGeo.translate(0, 1, 0);
                arrowGeo.rotateZ(-Math.PI / 2);
                const arrowMat = new THREE.MeshBasicMaterial({ color: 0x54a0ff, transparent: true, opacity: 0.4 });
                const arrow = new THREE.Mesh(arrowGeo, arrowMat);
                arrow.position.set(x, 0, z);

                const dir = new THREE.Vector3(x, 0, z).normalize();
                const axisX = new THREE.Vector3(1, 0, 0);
                const quat = new THREE.Quaternion().setFromUnitVectors(axisX, dir);
                arrow.rotation.setFromQuaternion(quat);

                fieldGroup.add(arrow);
            }
        }
        scene.add(fieldGroup);
        fieldGroup.visible = false;

        // Closed Loop Path
        const pathGroup = new THREE.Group();
        const pathPoints = [];
        const radius = 15;
        for (let i = 0; i <= 64; i++) {
            const angle = (i / 64) * Math.PI * 2;
            pathPoints.push(new THREE.Vector3(
                Math.cos(angle) * radius,
                0,
                Math.sin(angle) * radius
            ));
        }
        const pathGeo = new THREE.BufferGeometry().setFromPoints(pathPoints);
        const pathMat = new THREE.LineBasicMaterial({ color: 0xfeca57, linewidth: 2 });
        const pathLine = new THREE.Line(pathGeo, pathMat);
        pathGroup.add(pathLine);
        scene.add(pathGroup);
        pathGroup.visible = false;

        // Result Text
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 128;
        const ctx = canvas.getContext('2d');
        ctx.font = 'bold 40px Arial';
        ctx.fillStyle = '#2ed573';
        ctx.textAlign = 'center';
        const tex = new THREE.CanvasTexture(canvas);
        const spriteMat = new THREE.SpriteMaterial({ map: tex });
        const resultSprite = new THREE.Sprite(spriteMat);
        resultSprite.scale.set(15, 4, 1);
        resultSprite.position.set(0, 8, 0);
        scene.add(resultSprite);
        resultSprite.visible = false;

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.02;

            if (state.chargeVisible) {
                sourceMesh.position.y = Math.sin(state.time) * 0.2;
                sourceMesh.rotation.y += 0.005;
            }

            renderer.render(scene, camera);
        }
        animate();

        let currentChapter = 0;

        function placeCharge() {
            state.chargeVisible = true;
            sourceGroup.visible = true;
            fieldGroup.visible = true;
            document.getElementById('btn-intro').disabled = true;
            checkAdvance();
        }

        function drawClosedPath() {
            state.pathVisible = true;
            pathGroup.visible = true;
            document.getElementById('btn-path').disabled = true;
            checkAdvance();
        }

        function calculateIntegral() {
            state.integralCalculated = true;
            ctx.fillText('∮ E · dl = 0', 256, 80);
            tex.needsUpdate = true;
            resultSprite.visible = true;
            document.getElementById('btn-calc').disabled = true;
            checkAdvance();
        }

        function resetSim() {
            state.chargeVisible = false;
            state.pathVisible = false;
            state.integralCalculated = false;

            sourceGroup.visible = false;
            fieldGroup.visible = false;
            pathGroup.visible = false;
            resultSprite.visible = false;

            document.getElementById('btn-intro').disabled = false;
            document.getElementById('btn-path').disabled = false;
            document.getElementById('btn-calc').disabled = false;

            loadLesson(0);
        }

        const lessons = [
            {
                title: "Introduction: The Field",
                text: "We've learned about electric fields and forces. But there's another fundamental concept: <strong>Electric Potential</strong>. Before we can understand potential, we need to explore a special property of electrostatic fields.<br><br><span class='instruction-inline'>Click 'ADD SOURCE CHARGE'</span> to begin.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-intro');
                },
                check: () => state.chargeVisible
            },
            {
                title: "The Closed Loop",
                text: "Imagine moving a test charge around this field in a complete circuit—starting and ending at the same point. What is the total work done by the electric field?<br><br>The mathematical expression for this is the <strong>closed loop integral</strong>:<br><div class='math-block'>∮ E · dl</div><br>The circle on the integral symbol means we're integrating around a closed path.<br><br><span class='instruction-inline'>Click 'SHOW CLOSED LOOP PATH'</span>.",
                setup: () => {
                    unlock('ctrl-path');
                },
                check: () => state.pathVisible
            },
            {
                title: "Conservative Forces",
                text: "For <strong>electrostatic</strong> (static, non-changing) fields, this integral always equals <strong>zero</strong>. No matter what path you take, if you return to your starting point, the net work done is zero.<br><br>This makes the electric field a <strong>Conservative Force</strong>—just like gravity. The work done depends only on start and end points, not the path taken.<br><br><span class='instruction-inline'>Click '∮ E · dl = ?'</span> to calculate.",
                setup: () => {
                    unlock('ctrl-calc');
                },
                check: () => state.integralCalculated
            },
            {
                title: "Implications",
                text: "This zero result has profound implications:<br><br>1. <strong>Path Independence:</strong> The work to move a charge from point A to B is the same regardless of the route.<br><br>2. <strong>Potential Difference:</strong> We can define a unique value (potential) for each point in space.<br><br>3. <strong>Energy Conservation:</strong> The electric field conserves energy.<br><br>In the next lesson, we'll use this property to derive the electric field from potential.",
                setup: () => { },
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div>
                 <div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');

            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }

            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.location.href = '2_field_from_potential.html';
            }
        }

        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }

        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        loadLesson(0);

        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * newAspect / 2;
            camera.right = viewSize * newAspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });
    </script>
</body>

</html>

===== END OF 1_conservative_forces.html =====


===== START OF 2_field_from_potential.html =====

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Calculating Field from Potential</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg); }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }

        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        .math-block {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #333;
            color: #fff;
            text-align: center;
        }

        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button, input[type=range] {
            width: 100%;
            accent-color: var(--accent);
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        .nav-btn.next {
            background: var(--accent);
            color: #151515;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }

        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Chapter 5: Field from Potential</div>
        </header>

        <div id="story-container">
            <div id="chapter-content"></div>
        </div>

        <div id="controls-area">
            <div class="control-row" id="ctrl-potential">
                <label>Step 1: Show Potential</label>
                <button onclick="showPotential()">Display V(r) Field</button>
            </div>

            <div class="control-row" id="ctrl-derive">
                <label>Step 2: Take Derivative</label>
                <button onclick="deriveField()">Calculate E = -dV/dr</button>
            </div>

            <div class="control-row" id="ctrl-slider">
                <label>Step 3: Move Point (r)</label>
                <input type="range" id="position-slider" min="5" max="25" value="15" step="0.5">
            </div>

            <div class="control-row" id="ctrl-reset" style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Potential & Field</div>
    </main>

    <script>
        const state = {
            potentialVisible: false,
            fieldDerived: false,
            position: 15,
            time: 0
        };

        const scene = new THREE.Scene();
        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 40;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );
        camera.position.set(20, 25, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        document.getElementById('world').appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        scene.add(dirLight);

        const gridHelper = new THREE.GridHelper(100, 20, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -0.1;
        scene.add(gridHelper);
        scene.background = new THREE.Color(0x151515);

        // Source charge
        const sourceGeo = new THREE.IcosahedronGeometry(3, 1);
        const sourceMat = new THREE.MeshStandardMaterial({ color: 0xff6b6b, emissive: 0x550000 });
        const source = new THREE.Mesh(sourceGeo, sourceMat);
        scene.add(source);

        // Test point
        const testGeo = new THREE.SphereGeometry(0.8);
        const testMat = new THREE.MeshStandardMaterial({ color: 0xfeca57 });
        const testPoint = new THREE.Mesh(testGeo, testMat);
        testPoint.position.set(15, 0, 0);
        scene.add(testPoint);

        // Potential surfaces
        const potentialGroup = new THREE.Group();
        for (let r = 5; r <= 25; r += 5) {
            const geo = new THREE.RingGeometry(r - 0.2, r + 0.2, 64);
            const mat = new THREE.MeshBasicMaterial({ 
                color: 0x4ecdc4, 
                transparent: true, 
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(geo, mat);
            ring.rotation.x = -Math.PI / 2;
            potentialGroup.add(ring);
        }
        scene.add(potentialGroup);
        potentialGroup.visible = false;

        // Field arrow
        const arrowGroup = new THREE.Group();
        const shaftGeo = new THREE.CylinderGeometry(0.2, 0.2, 5, 8);
        shaftGeo.translate(0, 2.5, 0);
        shaftGeo.rotateZ(-Math.PI / 2);
        const arrowMat = new THREE.MeshStandardMaterial({ color: 0x54a0ff });
        const shaft = new THREE.Mesh(shaftGeo, arrowMat);
        const headGeo = new THREE.ConeGeometry(0.5, 1, 8);
        headGeo.rotateZ(-Math.PI / 2);
        headGeo.translate(5, 0, 0);
        const head = new THREE.Mesh(headGeo, arrowMat);
        arrowGroup.add(shaft, head);
        scene.add(arrowGroup);
        arrowGroup.visible = false;

        document.getElementById('position-slider').addEventListener('input', (e) => {
            state.position = parseFloat(e.target.value);
            testPoint.position.x = state.position;
            arrowGroup.position.x = state.position;
            checkAdvance();
        });

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.02;
            source.position.y = Math.sin(state.time) * 0.2;
            renderer.render(scene, camera);
        }
        animate();

        let currentChapter = 0;

        function showPotential() {
            state.potentialVisible = true;
            potentialGroup.visible = true;
            document.querySelector('button[onclick="showPotential()"]').disabled = true;
            checkAdvance();
        }

        function deriveField() {
            state.fieldDerived = true;
            arrowGroup.visible = true;
            arrowGroup.position.x = state.position;
            document.querySelector('button[onclick="deriveField()"]').disabled = true;
            checkAdvance();
        }

        function resetSim() {
            state.potentialVisible = false;
            state.fieldDerived = false;
            state.position = 15;
            potentialGroup.visible = false;
            arrowGroup.visible = false;
            testPoint.position.x = 15;
            document.getElementById('position-slider').value = 15;
            document.querySelector('button[onclick="showPotential()"]').disabled = false;
            document.querySelector('button[onclick="deriveField()"]').disabled = false;
            loadLesson(0);
        }

        const lessons = [
            {
                title: "From Potential to Field",
                text: "We know that electric potential V varies with position. For a point charge, V = kQ/r. But can we go backwards—calculate the electric field E from the potential?<br><br>The answer is yes. The field is the <strong>derivative</strong> of the potential.<br><br><span class='instruction-inline'>Click 'DISPLAY V(r) FIELD'</span>.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-potential');
                },
                check: () => state.potentialVisible
            },
            {
                title: "The Derivative",
                text: "The equipotential surfaces (rings) show where V is constant. To find the electric field, we take the <strong>rate of change</strong> of V with respect to distance:<br><div class='math-block'>E = -dV/dr</div><br>The negative sign indicates that E points from high to low potential—down the potential 'hill'.<br><br><span class='instruction-inline'>Click 'CALCULATE E = -dV/dr'</span>.",
                setup: () => {
                    unlock('ctrl-derive');
                },
                check: () => state.fieldDerived
            },
            {
                title: "Sign Convention",
                text: "The blue arrow shows the electric field direction. Notice:<br><br>1. E points <strong>radially outward</strong> (away from +Q)<br>2. E is <strong>perpendicular</strong> to equipotential surfaces<br>3. The magnitude E = kQ/r² decreases as r increases<br><br><span class='instruction-inline'>Move the slider</span> to see how E changes with position.",
                setup: () => {
                    unlock('ctrl-slider');
                },
                check: () => Math.abs(state.position - 15) > 3
            },
            {
                title: "Unit Vectors",
                text: "In mathematical notation, this relationship is written as:<br><div class='math-block'>E = -dV/dr r̂</div><br>Where <strong>r̂</strong> (r-hat) is the unit vector pointing radially outward. This tells us both the magnitude (from the derivative) and direction (radial).<br><br>Next, we'll explore how field lines relate to equipotential surfaces.",
                setup: () => {},
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div><div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');
            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }
            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.location.href = '3_equipotentials.html';
            }
        }

        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }

        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        loadLesson(0);

        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * newAspect / 2;
            camera.right = viewSize * newAspect / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });
    </script>
</body>
</html>


===== END OF 2_field_from_potential.html =====


===== START OF 3_equipotentials.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Equipotentials & Field Line Orthogonality</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        .math-block {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #333;
            color: #fff;
            text-align: center;
        }

        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        .nav-btn.next {
            background: var(--accent);
            color: #151515;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }

        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Chapter 5: Equipotentials</div>
        </header>

        <div id="story-container">
            <div id="chapter-content"></div>
        </div>

        <div id="controls-area">
            <div class="control-row" id="ctrl-equip">
                <label>Step 1: Show Equipotentials</label>
                <button onclick="showEquipotentials()">Display V = constant</button>
            </div>

            <div class="control-row" id="ctrl-field">
                <label>Step 2: Show Field Lines</label>
                <button onclick="showFieldLines()">Display E Field</button>
            </div>

            <div class="control-row" id="ctrl-charge">
                <label>Step 3: Move Test Charge</label>
                <button onclick="moveTestCharge()">Move Along Equipotential</button>
            </div>

            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Equipotential Surfaces</div>
    </main>

    <script>
        const state = {
            equipVisible: false,
            fieldVisible: false,
            chargeMoving: false,
            time: 0,
            chargeAngle: 0
        };

        const scene = new THREE.Scene();
        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 40;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );
        camera.position.set(20, 25, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        document.getElementById('world').appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        scene.add(dirLight);

        const gridHelper = new THREE.GridHelper(100, 20, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -0.1;
        scene.add(gridHelper);
        scene.background = new THREE.Color(0x151515);

        // Source charge
        const sourceGeo = new THREE.IcosahedronGeometry(3, 1);
        const sourceMat = new THREE.MeshStandardMaterial({ color: 0xff6b6b, emissive: 0x550000 });
        const source = new THREE.Mesh(sourceGeo, sourceMat);
        scene.add(source);

        // Equipotential surfaces
        const equipGroup = new THREE.Group();
        const radii = [5, 10, 15, 20, 25];
        radii.forEach((r, i) => {
            const geo = new THREE.RingGeometry(r - 0.3, r + 0.3, 64);
            const mat = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(0.5 + i * 0.1, 0.7, 0.5),
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(geo, mat);
            ring.rotation.x = -Math.PI / 2;
            equipGroup.add(ring);
        });
        scene.add(equipGroup);
        equipGroup.visible = false;

        // Field lines
        const fieldGroup = new THREE.Group();
        for (let a = 0; a < Math.PI * 2; a += Math.PI / 8) {
            const points = [];
            for (let r = 5; r <= 30; r += 1) {
                points.push(new THREE.Vector3(
                    Math.cos(a) * r,
                    0,
                    Math.sin(a) * r
                ));
            }
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            const mat = new THREE.LineBasicMaterial({ color: 0x54a0ff, transparent: true, opacity: 0.6 });
            const line = new THREE.Line(geo, mat);
            fieldGroup.add(line);
        }
        scene.add(fieldGroup);
        fieldGroup.visible = false;

        // Test charge
        const testGeo = new THREE.SphereGeometry(0.8);
        const testMat = new THREE.MeshStandardMaterial({ color: 0xfeca57 });
        const testCharge = new THREE.Mesh(testGeo, testMat);
        testCharge.position.set(15, 0, 0);
        scene.add(testCharge);

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.02;
            source.position.y = Math.sin(state.time) * 0.2;

            if (state.chargeMoving) {
                state.chargeAngle += 0.01;
                const r = 15;
                testCharge.position.x = Math.cos(state.chargeAngle) * r;
                testCharge.position.z = Math.sin(state.chargeAngle) * r;
            }

            renderer.render(scene, camera);
        }
        animate();

        let currentChapter = 0;

        function showEquipotentials() {
            state.equipVisible = true;
            equipGroup.visible = true;
            document.querySelector('button[onclick="showEquipotentials()"]').disabled = true;
            checkAdvance();
        }

        function showFieldLines() {
            state.fieldVisible = true;
            fieldGroup.visible = true;
            document.querySelector('button[onclick="showFieldLines()"]').disabled = true;
            checkAdvance();
        }

        function moveTestCharge() {
            state.chargeMoving = true;
            document.querySelector('button[onclick="moveTestCharge()"]').disabled = true;
            checkAdvance();
        }

        function resetSim() {
            state.equipVisible = false;
            state.fieldVisible = false;
            state.chargeMoving = false;
            state.chargeAngle = 0;
            equipGroup.visible = false;
            fieldGroup.visible = false;
            testCharge.position.set(15, 0, 0);
            document.querySelector('button[onclick="showEquipotentials()"]').disabled = false;
            document.querySelector('button[onclick="showFieldLines()"]').disabled = false;
            document.querySelector('button[onclick="moveTestCharge()"]').disabled = false;
            loadLesson(0);
        }

        const lessons = [
            {
                title: "Equipotential Surfaces",
                text: "An <strong>equipotential surface</strong> is a surface where the electric potential V is constant everywhere. These are like the contour lines on a topographic map—they connect points of equal height (or in this case, equal potential).<br><br><span class='instruction-inline'>Click 'DISPLAY V = constant'</span> to see them.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-equip');
                },
                check: () => state.equipVisible
            },
            {
                title: "Perpendicular Field Lines",
                text: "Electric field lines are <strong>always perpendicular</strong> to equipotential surfaces. Why? Because the field points in the direction of maximum potential decrease, and that direction is perpendicular to surfaces of constant potential.<br><br><span class='instruction-inline'>Click 'DISPLAY E FIELD'</span> to see this relationship.",
                setup: () => {
                    unlock('ctrl-field');
                },
                check: () => state.fieldVisible
            },
            {
                title: "No Work on Equipotentials",
                text: "If you move a charge <strong>along</strong> an equipotential surface, no work is done. Why? Because work = qΔV, and ΔV = 0 on an equipotential.<br><br>The force (qE) is perpendicular to the motion, so F·d = 0.<br><br><span class='instruction-inline'>Click 'MOVE ALONG EQUIPOTENTIAL'</span> to see this.",
                setup: () => {
                    unlock('ctrl-charge');
                },
                check: () => state.chargeMoving
            },
            {
                title: "Summary",
                text: "Key takeaways:<br><br>1. Equipotential surfaces have constant potential (ΔV = 0)<br>2. Electric field lines are <strong>perpendicular</strong> to equipotentials<br>3. No work is done moving charges along equipotentials<br>4. Field lines point from high to low potential<br><br>Next, we'll extend this to 3D using gradients.",
                setup: () => { },
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div><div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');
            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }
            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.location.href = '4_gradient.html';
            }
        }

        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }

        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        loadLesson(0);

        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * newAspect / 2;
            camera.right = viewSize * newAspect / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });
    </script>
</body>

</html>

===== END OF 3_equipotentials.html =====


===== START OF 4_gradient.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>The Gradient in Cartesian Coordinates</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        .math-block {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #333;
            color: #fff;
            text-align: center;
        }

        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
        }

        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        .nav-btn.next {
            background: var(--accent);
            color: #151515;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }

        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Chapter 5: The Gradient</div>
        </header>

        <div id="story-container">
            <div id="chapter-content"></div>
        </div>

        <div id="controls-area">
            <div class="control-row active" id="ctrl-probe">
                <label>Move Gradient Probe</label>
                <input type="range" id="probe-x" min="-15" max="15" value="10" step="0.5">
                <div style="font-size: 10px; color: #555; margin-top: 5px;">X Position: <span id="x-val">10</span></div>
            </div>

            <div class="control-row" id="ctrl-show">
                <label>Step 1: Show Gradient Field</label>
                <button onclick="showGradientField()">Display ∇V Field</button>
            </div>

            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">3D Potential Landscape</div>
    </main>

    <script>
        const state = {
            probeX: 10,
            gradientVisible: false,
            componentsVisible: false,
            time: 0
        };

        const scene = new THREE.Scene();
        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 40;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );
        camera.position.set(25, 30, 25);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        document.getElementById('world').appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(10, 20, 5);
        scene.add(dirLight);

        scene.background = new THREE.Color(0x151515);

        // Create potential surface (cone-like shape showing V = k/r)
        const surfaceGroup = new THREE.Group();
        const resolution = 40;
        for (let i = 0; i < resolution; i++) {
            const angle = (i / resolution) * Math.PI * 2;
            const points = [];
            for (let r = 3; r <= 25; r += 1) {
                const height = 15 / r; // V ~ 1/r
                points.push(new THREE.Vector3(
                    Math.cos(angle) * r,
                    height,
                    Math.sin(angle) * r
                ));
            }
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            const mat = new THREE.LineBasicMaterial({
                color: 0x4ecdc4,
                transparent: true,
                opacity: 0.3
            });
            const line = new THREE.Line(geo, mat);
            surfaceGroup.add(line);
        }
        scene.add(surfaceGroup);

        // Ground plane
        const gridHelper = new THREE.GridHelper(60, 30, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -0.1;
        scene.add(gridHelper);

        // Source charge at origin
        const sourceGeo = new THREE.IcosahedronGeometry(2, 1);
        const sourceMat = new THREE.MeshStandardMaterial({
            color: 0xff6b6b,
            emissive: 0x550000,
            flatShading: true
        });
        const source = new THREE.Mesh(sourceGeo, sourceMat);
        scene.add(source);

        // Gradient probe (ball that moves)
        const probeGeo = new THREE.SphereGeometry(0.8);
        const probeMat = new THREE.MeshStandardMaterial({ color: 0xfeca57 });
        const probe = new THREE.Mesh(probeGeo, probeMat);
        scene.add(probe);

        // Gradient arrow from probe
        const gradArrowGroup = new THREE.Group();
        const shaftGeo = new THREE.CylinderGeometry(0.15, 0.15, 1, 8);
        shaftGeo.translate(0, 0.5, 0);
        shaftGeo.rotateZ(-Math.PI / 2);
        const headGeo = new THREE.ConeGeometry(0.4, 0.8, 8);
        headGeo.rotateZ(-Math.PI / 2);
        headGeo.translate(1, 0, 0);
        const arrowMat = new THREE.MeshStandardMaterial({ color: 0x54a0ff });
        const shaft = new THREE.Mesh(shaftGeo, arrowMat);
        const head = new THREE.Mesh(headGeo, arrowMat);
        gradArrowGroup.add(shaft, head);
        scene.add(gradArrowGroup);
        gradArrowGroup.visible = false;

        // Gradient field removed - too confusing in 2D

        function updateProbe() {
            const x = state.probeX;
            const z = 0;
            const r = Math.sqrt(x * x + z * z);
            const height = r > 0 ? 15 / r : 5;

            probe.position.set(x, height, z);
            gradArrowGroup.position.set(x, height, z);

            // Update arrow scale and direction
            if (r > 0) {
                // Calculate gradient in 3D: ∇V = (∂V/∂x, ∂V/∂y, ∂V/∂z)
                // For V = 15/r, we have ∂V/∂r = -15/r²
                const dVdx = -15 * x / (r * r * r);
                const dVdz = -15 * z / (r * r * r);

                // Electric field components: E = -∇V
                const Ex = -dVdx;  // Points radially outward
                const Ez = -dVdz;
                // Vertical component: as we move radially out, height decreases
                const Ey = -(-15 / (r * r)); // Points down the potential slope

                // USE SAME SCALING FACTOR for both blue arrow and RGB components!
                const scaleFactor = 3; // Single unified scale factor

                // Blue gradient arrow - total field vector
                const gradDir = new THREE.Vector3(Ex, Ey, Ez);
                const gradMag = gradDir.length();
                gradDir.normalize();

                const blueArrowLength = gradMag * scaleFactor;
                gradArrowGroup.scale.set(blueArrowLength, 1, 1);

                // Orient arrow to point in gradient direction
                const quat = new THREE.Quaternion().setFromUnitVectors(
                    new THREE.Vector3(1, 0, 0),
                    gradDir
                );
                gradArrowGroup.quaternion.copy(quat);
            }

            document.getElementById('x-val').innerText = x.toFixed(1);
        }

        document.getElementById('probe-x').addEventListener('input', (e) => {
            state.probeX = parseFloat(e.target.value);
            updateProbe();
            checkAdvance();
        });

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.01;
            source.rotation.y += 0.005;
            renderer.render(scene, camera);
        }
        animate();

        let currentChapter = 0;

        function showGradientField() {
            state.gradientVisible = true;
            gradArrowGroup.visible = true;
            document.querySelector('button[onclick="showGradientField()"]').disabled = true;
            checkAdvance();
        }



        function resetSim() {
            state.probeX = 10;
            state.gradientVisible = false;

            gradArrowGroup.visible = false;

            document.getElementById('probe-x').value = 10;
            document.querySelector('button[onclick="showGradientField()"]').disabled = false;

            updateProbe();
            loadLesson(0);
        }

        const lessons = [
            {
                title: "The Potential Landscape",
                text: "You're looking at a 3D visualization of electric potential. The curved surface shows V(r) = k/r for a point charge. The yellow probe sits on this surface.<br><br>Move the slider to change the probe's position. Notice how the probe's height changes—that's the potential at that point.<br><br><span class='instruction-inline'>Move the slider</span> to explore the potential landscape.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-probe');
                },
                check: () => Math.abs(state.probeX - 10) > 3
            },
            {
                title: "The Gradient: ∇V",
                text: "The <strong>gradient</strong> (∇V) is a 3D vector field that points in the direction of steepest increase of potential:<br><div class='math-block'>∇V = (∂V/∂x, ∂V/∂y, ∂V/∂z)</div><br>The electric field is E = -∇V, pointing <em>downhill</em> from high to low potential. The blue arrow at the probe position shows this direction.<br><br><span class='instruction-inline'>Click 'DISPLAY ∇V FIELD'</span> to show it.",
                setup: () => {
                    unlock('ctrl-show');
                },
                check: () => state.gradientVisible
            },
            {
                title: "Understanding the Gradient",
                text: "The gradient has three components (∂V/∂x, ∂V/∂y, ∂V/∂z) called <strong>partial derivatives</strong>—they measure how V changes in each direction.<br><br>For our point charge:<br>• Near the charge: steep gradient → strong field → long blue arrow<br>• Far from charge: gentle gradient → weak field → short blue arrow<br><br>The blue arrow shows both the magnitude AND direction of the electric field.",
                setup: () => { },
                check: () => true
            },
            {
                title: "Units: Volts per Meter",
                text: "The electric field has units of <strong>V/m</strong> (volts per meter):<br><div class='math-block'>E = -∇V = -dV/dr</div><br>This is the rate of change of voltage with distance. A steeper potential gradient means a stronger field.<br><br>For a point charge: E = kQ/r²<br><br>Next, we'll apply this to parallel plates where the field is uniform.",
                setup: () => { },
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div><div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');
            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }
            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.location.href = '5_parallel_plates.html';
            }
        }

        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }

        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() {
            document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active'));
        }
        function unlock(id) {
            document.getElementById(id).classList.add('active');
        }

        updateProbe();
        loadLesson(0);

        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * newAspect / 2;
            camera.right = viewSize * newAspect / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });
    </script>
</body>

</html>

===== END OF 4_gradient.html =====


===== START OF 5_parallel_plates.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Parallel Plates - Linear Potential</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        .math-block {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #333;
            color: #fff;
            text-align: center;
        }

        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
        }

        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        .nav-btn.next {
            background: var(--accent);
            color: #151515;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }

        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Chapter 5: Parallel Plates</div>
        </header>

        <div id="story-container">
            <div id="chapter-content"></div>
        </div>

        <div id="controls-area">
            <div class="control-row active" id="ctrl-probe">
                <label>Move Test Probe</label>
                <input type="range" id="probe-x" min="-10" max="10" value="0" step="0.5">
                <div style="font-size: 10px; color: #555; margin-top: 5px;">Position: <span id="x-val">0.0</span> | V =
                    <span id="v-val">50</span>V</div>
            </div>

            <div class="control-row" id="ctrl-field">
                <label>Step 1: Show Electric Field</label>
                <button onclick="showField()">Display E Field</button>
            </div>

            <div class="control-row" id="ctrl-gradient">
                <label>Step 2: Calculate Gradient</label>
                <button onclick="calculateGradient()">E = -dV/dx</button>
            </div>

            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Capacitor</div>
    </main>

    <script>
        const state = {
            probeX: 0,
            fieldVisible: false,
            gradientCalculated: false,
            time: 0
        };

        const scene = new THREE.Scene();
        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 25;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );
        camera.position.set(0, 15, 30);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        document.getElementById('world').appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        scene.background = new THREE.Color(0x151515);

        // Parallel plates
        const plateGeo = new THREE.BoxGeometry(2, 15, 15);

        // Left plate (positive)
        const plateMat1 = new THREE.MeshStandardMaterial({
            color: 0xff6b6b,
            metalness: 0.8,
            roughness: 0.2,
            emissive: 0x331111
        });
        const leftPlate = new THREE.Mesh(plateGeo, plateMat1);
        leftPlate.position.x = -12;
        scene.add(leftPlate);

        // Right plate (negative)
        const plateMat2 = new THREE.MeshStandardMaterial({
            color: 0x54a0ff,
            metalness: 0.8,
            roughness: 0.2,
            emissive: 0x111133
        });
        const rightPlate = new THREE.Mesh(plateGeo, plateMat2);
        rightPlate.position.x = 12;
        scene.add(rightPlate);

        // Grid lines showing potential
        const potentialGroup = new THREE.Group();
        for (let x = -10; x <= 10; x += 2) {
            const V = 50 + 5 * x; // V = 50 + 5x (linear!)
            const color = new THREE.Color().setHSL(0.15 + V / 200, 0.7, 0.5);

            const lineGeo = new THREE.PlaneGeometry(0.1, 12);
            const lineMat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const line = new THREE.Mesh(lineGeo, lineMat);
            line.position.x = x;
            potentialGroup.add(line);
        }
        scene.add(potentialGroup);

        // Test probe
        const probeGeo = new THREE.SphereGeometry(0.6);
        const probeMat = new THREE.MeshStandardMaterial({ color: 0xfeca57 });
        const probe = new THREE.Mesh(probeGeo, probeMat);
        scene.add(probe);

        // Electric field arrows
        const fieldGroup = new THREE.Group();
        for (let y = -5; y <= 5; y += 2.5) {
            for (let z = -5; z <= 5; z += 2.5) {
                const arrowLen = 3;
                const shaftGeo = new THREE.CylinderGeometry(0.1, 0.1, arrowLen, 8);
                shaftGeo.translate(0, arrowLen / 2, 0);
                shaftGeo.rotateZ(-Math.PI / 2);
                const shaft = new THREE.Mesh(shaftGeo, new THREE.MeshStandardMaterial({
                    color: 0x54a0ff,
                    emissive: 0x002266
                }));

                const headGeo = new THREE.ConeGeometry(0.25, 0.5, 8);
                headGeo.rotateZ(-Math.PI / 2);
                headGeo.translate(arrowLen, 0, 0);
                const head = new THREE.Mesh(headGeo, new THREE.MeshStandardMaterial({
                    color: 0x54a0ff,
                    emissive: 0x002266
                }));

                const arrow = new THREE.Group();
                arrow.add(shaft, head);
                arrow.position.set(0, y, z);
                fieldGroup.add(arrow);
            }
        }
        scene.add(fieldGroup);
        fieldGroup.visible = false;

        // Result text
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 128;
        const ctx = canvas.getContext('2d');
        ctx.font = 'bold 36px Arial';
        ctx.fillStyle = '#2ed573';
        ctx.textAlign = 'center';
        const tex = new THREE.CanvasTexture(canvas);
        const spriteMat = new THREE.SpriteMaterial({ map: tex });
        const resultSprite = new THREE.Sprite(spriteMat);
        resultSprite.scale.set(15, 4, 1);
        resultSprite.position.set(0, -10, 0);
        scene.add(resultSprite);
        resultSprite.visible = false;

        function updateProbe() {
            const x = state.probeX;
            probe.position.x = x;

            // Linear potential: V = 50 + 5x
            const V = 50 + 5 * x;
            document.getElementById('x-val').innerText = x.toFixed(1);
            document.getElementById('v-val').innerText = V.toFixed(0);
        }

        document.getElementById('probe-x').addEventListener('input', (e) => {
            state.probeX = parseFloat(e.target.value);
            updateProbe();
            checkAdvance();
        });

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.01;
            renderer.render(scene, camera);
        }
        animate();

        let currentChapter = 0;

        function showField() {
            state.fieldVisible = true;
            fieldGroup.visible = true;
            document.querySelector('button[onclick="showField()"]').disabled = true;
            checkAdvance();
        }

        function calculateGradient() {
            state.gradientCalculated = true;
            ctx.clearRect(0, 0, 512, 128);
            ctx.fillText('E = -dV/dx = -5 V/m', 256, 70);
            tex.needsUpdate = true;
            resultSprite.visible = true;
            document.querySelector('button[onclick="calculateGradient()"]').disabled = true;
            checkAdvance();
        }

        function resetSim() {
            state.probeX = 0;
            state.fieldVisible = false;
            state.gradientCalculated = false;

            fieldGroup.visible = false;
            resultSprite.visible = false;

            document.getElementById('probe-x').value = 0;
            document.querySelector('button[onclick="showField()"]').disabled = false;
            document.querySelector('button[onclick="calculateGradient()"]').disabled = false;

            updateProbe();
            loadLesson(0);
        }

        const lessons = [
            {
                title: "Two Charged Plates",
                text: "You're looking at a <strong>parallel plate capacitor</strong>. The left plate (red) is positively charged, the right plate (blue) is negatively charged.<br><br>Between them, the potential varies <strong>linearly</strong>: V(x) = 50 + 5x. The colored lines show equipotential surfaces.<br><br><span class='instruction-inline'>Move the slider</span> to see how potential changes with position.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-probe');
                },
                check: () => Math.abs(state.probeX) > 3
            },
            {
                title: "Linear Potential",
                text: "Notice that V changes <strong>at a constant rate</strong>:<br><div class='math-block'>V(x) = 100,000 · x</div><br>(In this simplified view, V = 50 + 5x)<br><br>This linear relationship is the key feature of parallel plates. No matter where you are between the plates, the potential gradient is the same.<br><br><span class='instruction-inline'>Click 'DISPLAY E FIELD'</span> to see what this means for the electric field.",
                setup: () => {
                    unlock('ctrl-field');
                },
                check: () => state.fieldVisible
            },
            {
                title: "Uniform Electric Field",
                text: "Look at the field arrows—they're all the <strong>same length and direction</strong>! This is a <strong>uniform field</strong>.<br><br>Why? Because E = -dV/dx, and when V is linear, its derivative (slope) is constant.<br><br>A linear potential → constant gradient → uniform field.<br><br><span class='instruction-inline'>Click 'E = -dV/dx'</span> to calculate the field strength.",
                setup: () => {
                    unlock('ctrl-gradient');
                },
                check: () => state.gradientCalculated
            },
            {
                title: "Practical Applications",
                text: "Parallel plate capacitors create uniform electric fields, which are incredibly useful:<br><br>• <strong>Capacitors:</strong> Energy storage in circuits<br>• <strong>Particle accelerators:</strong> Uniform acceleration<br>• <strong>Sensors:</strong> Touch screens, keyboards<br><br>The simplicity of E = -dV/dx = constant makes calculations easy.<br><br>Next, we'll explore conductors and electrostatic equilibrium.",
                setup: () => { },
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div><div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');
            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }
            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.location.href = '6_conductors.html';
            }
        }

        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }

        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() {
            document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active'));
        }
        function unlock(id) {
            document.getElementById(id).classList.add('active');
        }

        updateProbe();
        loadLesson(0);

        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * newAspect / 2;
            camera.right = viewSize * newAspect / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });
    </script>
</body>

</html>

===== END OF 5_parallel_plates.html =====


===== START OF 6_conductors.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Conductors and Electrostatic Equilibrium</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        .math-block {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #333;
            color: #fff;
            text-align: center;
        }

        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        .nav-btn.next {
            background: var(--accent);
            color: #151515;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }

        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        #graph-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 400px;
            height: 250px;
            background: rgba(26, 26, 26, 0.95);
            border: 2px solid #333;
            border-radius: 8px;
            padding: 15px;
            display: none;
        }

        #graph-canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Chapter 5: Conductors</div>
        </header>

        <div id="story-container">
            <div id="chapter-content"></div>
        </div>

        <div id="controls-area">
            <div class="control-row" id="ctrl-charges">
                <label>Step 1: Place Charges</label>
                <button onclick="addCharges()">Add Charges Inside</button>
            </div>

            <div class="control-row" id="ctrl-field">
                <label>Step 2: Check Internal Field</label>
                <button onclick="checkField()">Measure E Inside</button>
            </div>

            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div id="graph-container">
            <canvas id="graph-canvas"></canvas>
        </div>
    </main>

    <script>
        const state = {
            chargesAdded: false,
            equilibrium: false,
            fieldChecked: false,
            time: 0
        };

        const scene = new THREE.Scene();
        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 30;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );
        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        document.getElementById('world').appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(10, 20, 5);
        scene.add(dirLight);

        scene.background = new THREE.Color(0x151515);

        // Add OrbitControls for rotation
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enableZoom = true;
        controls.enablePan = false;

        // Conductor sphere
        const conductorGeo = new THREE.IcosahedronGeometry(8, 2);
        const conductorMat = new THREE.MeshStandardMaterial({
            color: 0x888888,
            metalness: 0.9,
            roughness: 0.1,
            transparent: true,
            opacity: 0.7
        });
        const conductor = new THREE.Mesh(conductorGeo, conductorMat);
        scene.add(conductor);

        // Charges that will animate to surface
        const initialChargesGroup = new THREE.Group();
        const numCharges = 24;
        const goldenRatio = (1 + Math.sqrt(5)) / 2;

        for (let i = 0; i < numCharges; i++) {
            // Start position (inside)
            const angle = (i / numCharges) * Math.PI * 2 + (Math.random() - 0.5) * 0.3;
            const r = 3 + Math.random() * 3;

            const chargeGeo = new THREE.SphereGeometry(0.4);
            const chargeMat = new THREE.MeshStandardMaterial({
                color: 0xff6b6b,
                emissive: 0x550000
            });
            const charge = new THREE.Mesh(chargeGeo, chargeMat);
            charge.position.set(
                Math.cos(angle) * r,
                (Math.random() - 0.5) * 6,
                Math.sin(angle) * r
            );

            // Target position (on surface using golden spiral)
            const theta = 2 * Math.PI * i / goldenRatio;
            const phi = Math.acos(1 - 2 * (i + 0.5) / numCharges);
            const targetX = 8.2 * Math.sin(phi) * Math.cos(theta);
            const targetY = 8.2 * Math.sin(phi) * Math.sin(theta);
            const targetZ = 8.2 * Math.cos(phi);

            charge.userData.target = new THREE.Vector3(targetX, targetY, targetZ);
            charge.userData.settled = false;
            initialChargesGroup.add(charge);
        }
        scene.add(initialChargesGroup);
        initialChargesGroup.visible = false;



        // Graph in HTML overlay
        const graphCanvas = document.getElementById('graph-canvas');
        const graphCtx = graphCanvas.getContext('2d');
        graphCanvas.width = 370;
        graphCanvas.height = 220;

        function drawGraph() {
            const w = 370, h = 220;
            graphCtx.fillStyle = 'transparent';
            graphCtx.clearRect(0, 0, w, h);

            // Title
            graphCtx.fillStyle = '#2ed573';
            graphCtx.font = 'bold 16px Arial';
            graphCtx.textAlign = 'center';
            graphCtx.fillText('Electric Field vs Distance', w / 2, 20);

            // Axes
            graphCtx.strokeStyle = '#666';
            graphCtx.lineWidth = 2;
            graphCtx.beginPath();
            graphCtx.moveTo(40, h - 30);
            graphCtx.lineTo(w - 20, h - 30);
            graphCtx.moveTo(40, 30);
            graphCtx.lineTo(40, h - 30);
            graphCtx.stroke();

            // Labels
            graphCtx.fillStyle = '#aaa';
            graphCtx.font = '12px Arial';
            graphCtx.textAlign = 'center';
            graphCtx.fillText('r', w / 2, h - 10);
            graphCtx.save();
            graphCtx.translate(15, h / 2);
            graphCtx.rotate(-Math.PI / 2);
            graphCtx.fillText('E', 0, 0);
            graphCtx.restore();

            // Conductor radius marker
            const conductorX = 40 + (8 / 15) * (w - 60);
            graphCtx.strokeStyle = '#ff6b6b';
            graphCtx.setLineDash([3, 3]);
            graphCtx.beginPath();
            graphCtx.moveTo(conductorX, 30);
            graphCtx.lineTo(conductorX, h - 30);
            graphCtx.stroke();
            graphCtx.setLineDash([]);
            graphCtx.fillStyle = '#ff6b6b';
            graphCtx.font = '11px Arial';
            graphCtx.fillText('R', conductorX, h - 35);

            // E-field plot
            graphCtx.strokeStyle = '#54a0ff';
            graphCtx.lineWidth = 2;
            graphCtx.beginPath();

            // Inside: E = 0
            for (let r = 0; r <= 8; r += 0.1) {
                const x = 40 + (r / 15) * (w - 60);
                const y = h - 30;
                if (r === 0) graphCtx.moveTo(x, y);
                else graphCtx.lineTo(x, y);
            }

            // Outside: E ~ 1/r²
            for (let r = 8; r <= 15; r += 0.1) {
                const x = 40 + (r / 15) * (w - 60);
                const E = 64 / (r * r);
                const y = h - 30 - E * 20;
                graphCtx.lineTo(x, y);
            }
            graphCtx.stroke();

            // Label
            graphCtx.fillStyle = '#2ed573';
            graphCtx.font = 'bold 14px Arial';
            graphCtx.textAlign = 'left';
            graphCtx.fillText('E = 0', 50, 80);

            document.getElementById('graph-container').style.display = 'block';
        }

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.01;
            controls.update();

            // Animate charge movement to surface (slower, smoother)
            if (state.chargesAdded && !state.equilibrium) {
                let allSettled = true;
                initialChargesGroup.children.forEach(charge => {
                    if (!charge.userData.settled) {
                        const distToTarget = charge.position.distanceTo(charge.userData.target);
                        if (distToTarget > 0.05) {
                            charge.position.lerp(charge.userData.target, 0.015); // Slow smooth movement
                            allSettled = false;
                        } else {
                            charge.position.copy(charge.userData.target);
                            charge.userData.settled = true;
                        }
                    }
                });

                // All charges reached surface
                if (allSettled) {
                    state.equilibrium = true;
                }
            }

            renderer.render(scene, camera);
        }
        animate();



        let currentChapter = 0;

        function addCharges() {
            state.chargesAdded = true;
            state.equilibrium = false;
            initialChargesGroup.visible = true;

            // Reset settled flags
            initialChargesGroup.children.forEach(charge => {
                charge.userData.settled = false;
            });

            document.querySelector('button[onclick="addCharges()"]').disabled = true;

            checkAdvance();
        }

        function checkField() {
            state.fieldChecked = true;
            drawGraph();
            document.querySelector('button[onclick="checkField()"]').disabled = true;
            checkAdvance();
        }

        function resetSim() {
            state.chargesAdded = false;
            state.equilibrium = false;
            state.fieldChecked = false;

            initialChargesGroup.visible = false;
            document.getElementById('graph-container').style.display = 'none';

            // Reset charge positions to random inside positions
            initialChargesGroup.children.forEach((charge, i) => {
                const angle = (i / 24) * Math.PI * 2 + (Math.random() - 0.5) * 0.3;
                const r = 3 + Math.random() * 3;
                charge.position.set(
                    Math.cos(angle) * r,
                    (Math.random() - 0.5) * 6,
                    Math.sin(angle) * r
                );
                charge.userData.settled = false;
            });

            document.querySelector('button[onclick="addCharges()"]').disabled = false;
            document.querySelector('button[onclick="checkField()"]').disabled = false;

            loadLesson(0);
        }

        const lessons = [
            {
                title: "What is a Conductor?",
                text: "A <strong>conductor</strong> is a material where electrons can move freely. Metals like copper, aluminum, and gold are excellent conductors.<br><br>You're looking at a spherical conductor. When we place charges on it, something remarkable happens.<br><br><span class='instruction-inline'>Click 'ADD CHARGES INSIDE'</span> to place some charges.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-charges');
                },
                check: () => state.chargesAdded
            },
            {
                title: "Electrostatic Equilibrium",
                text: "Watch as the charges automatically move! They experience mutual repulsion and push each other away until they reach <strong>electrostatic equilibrium</strong> on the <strong>outer surface</strong>.<br><br>In a conductor, free charges always redistribute to minimize energy. The surface is as far apart as they can get!<br><br>Once settled, <span class='instruction-inline'>click 'MEASURE E INSIDE'</span> to analyze the field.",
                setup: () => {
                    unlock('ctrl-field');
                },
                check: () => state.fieldChecked
            },
            {
                title: "Zero Field Inside",
                text: "<strong>Key principle:</strong> In electrostatic equilibrium:<br><div class='math-block'>E<sub>inside</sub> = 0</div><br>Why? If there were a field, free charges would move until they canceled it out. Equilibrium means zero net field everywhere inside.<br><br>By <strong>Gauss's Law</strong>: ∮ E · dA = Q<sub>enc</sub>/ε₀<br>Since all charge is on the surface, Q<sub>enc</sub> = 0 inside.<br><br><span class='instruction-inline'>Click 'MEASURE E INSIDE'</span> to see the E vs r graph.",
                setup: () => {
                    unlock('ctrl-field');
                },
                check: () => state.fieldChecked
            },
            {
                title: "Why This Matters",
                text: "This principle has profound consequences:<br><br>1. <strong>Faraday cages:</strong> Metal enclosures block external fields<br>2. <strong>Shielding:</strong> Sensitive electronics protected from interference<br>3. <strong>Hollow conductors:</strong> The inside is field-free<br><br>The graph shows E = 0 inside (r < R) and E ~ 1/r² outside (r > R).<br><br>Next, we'll demonstrate this with a hollow conductor experiment.",
                setup: () => { },
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div><div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');
            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }
            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.location.href = '7_hollow_conductor.html';
            }
        }

        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }

        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() {
            document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active'));
        }
        function unlock(id) {
            document.getElementById(id).classList.add('active');
        }

        loadLesson(0);

        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * newAspect / 2;
            camera.right = viewSize * newAspect / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });
    </script>
</body>

</html>

===== END OF 6_conductors.html =====


===== START OF 7_hollow_conductor.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Hollow Conductors & Shielding</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* --- STYLING FROM THE "GRADIENT" SCRIPT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43; /* Orange Accent from Reference */
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* Custom Scrollbars */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }
        
        .story-text em {
            color: var(--accent);
            font-style: normal;
        }

        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            transition: 0.3s;
            filter: grayscale(0);
            opacity: 1;
        }

        /* Adapted logic: The gradient script used .active to show, 
           this script uses .disabled to hide. Styling adapted to match visual result. */
        .control-row.disabled {
            opacity: 0.5;
            pointer-events: none;
            filter: grayscale(1);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
            margin-bottom: 5px;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        /* Primary button style using the new Orange accent */
        button.primary {
            background: #2a2a2a;
            border-color: var(--accent);
            color: var(--accent);
        }
        
        button.primary:hover {
            background: var(--accent);
            color: #111;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
        }

        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        .nav-btn.next {
            background: var(--accent);
            color: #151515;
        }
        
        .nav-btn.next:hover {
            background: var(--accent-hover);
        }

        .nav-btn.next:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #444;
            color: #888;
        }

        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Chapter 5: Hollow Conductors</div>
        </header>

        <div id="story-container">
            <div id="chapter-content"></div>
        </div>

        <div id="controls-area">
            <!-- View Control -->
            <div class="control-row">
                <label>View Options</label>
                <button class="primary" onclick="toggleCut()">Toggle Cutaway View</button>
            </div>

            <!-- Combined Insertion and Induction -->
            <div class="control-row disabled" id="ctrl-place">
                <label>Step 1: Introduction</label>
                <button onclick="insertCharge()">Insert +Q Charge</button>
            </div>

            <div class="control-row disabled" id="ctrl-move">
                <label>Step 2: Experimentation</label>
                <input type="range" id="charge-pos" min="-4" max="4" value="0" step="0.1">
                <div style="font-size: 10px; color: #555; margin-top: 5px;">Internal Charge Position</div>
            </div>

            <div class="control-row" style="margin-top:20px; border-top:1px solid #333; padding-top:15px;">
                <button onclick="resetSim()">Reset Experiment</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Electrostatics Lab</div>
    </main>

    <script>
        // --- 1. Scene Setup ---
        const state = {
            isCut: false, // Starts as full sphere
            chargePlaced: false,
            sourcePos: 0,
            time: 0
        };

        const scene = new THREE.Scene();
        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 35;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );
        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        document.getElementById('world').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // Background color handled by CSS (radial gradient), but we set clear color for alpha
        // scene.background = new THREE.Color(0x151515); // Removed to let CSS gradient show through

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- 2. Geometry Construction ---

        const R_inner = 8;
        const R_outer = 11;
        const CUT_ANGLE = Math.PI * 1.5; 
        
        // Materials
        const metalMaterial = new THREE.MeshStandardMaterial({
            color: 0x888888,
            metalness: 0.7,
            roughness: 0.2,
            side: THREE.DoubleSide
        });
        
        const cutFaceMaterial = new THREE.MeshStandardMaterial({
            color: 0x555555,
            metalness: 0.5,
            roughness: 0.6,
            side: THREE.DoubleSide
        });

        const conductorGroup = new THREE.Group();
        const geometryContainer = new THREE.Group(); 
        conductorGroup.add(geometryContainer);
        scene.add(conductorGroup);
        
        conductorGroup.rotation.y = -Math.PI / 4; 

        function updateConductorGeometry() {
            while(geometryContainer.children.length > 0){ 
                geometryContainer.remove(geometryContainer.children[0]); 
            }

            const phiLen = state.isCut ? CUT_ANGLE : Math.PI * 2;

            // Outer Shell
            const outGeo = new THREE.SphereGeometry(R_outer, 48, 48, 0, phiLen);
            const outMesh = new THREE.Mesh(outGeo, metalMaterial);
            geometryContainer.add(outMesh);

            // Inner Shell (BackSide for interior)
            const inGeo = new THREE.SphereGeometry(R_inner, 48, 48, 0, phiLen);
            const inMat = metalMaterial.clone(); 
            inMat.side = THREE.BackSide;
            const inMesh = new THREE.Mesh(inGeo, inMat);
            geometryContainer.add(inMesh);

            // Side Walls
            if (state.isCut) {
                const capGeo = new THREE.RingGeometry(R_inner, R_outer, 32, 1, 0, Math.PI);

                const cap1 = new THREE.Mesh(capGeo, cutFaceMaterial);
                cap1.rotation.y = Math.PI / 2; 
                cap1.rotation.z = Math.PI / 2;
                geometryContainer.add(cap1);

                const cap2 = new THREE.Mesh(capGeo, cutFaceMaterial);
                cap2.rotation.y = Math.PI / 2 + CUT_ANGLE;
                cap2.rotation.z = Math.PI / 2;
                geometryContainer.add(cap2);
            }
        }

        updateConductorGeometry();

        // --- 3. Charges Setup ---

        const chargesContainer = new THREE.Group();
        conductorGroup.add(chargesContainer); 

        // Source Charge (+Q) - RED
        const sourceGeo = new THREE.SphereGeometry(1.5);
        const sourceMat = new THREE.MeshStandardMaterial({ color: 0xff4444, emissive: 0x550000 });
        const sourceCharge = new THREE.Mesh(sourceGeo, sourceMat);
        sourceCharge.visible = false;
        scene.add(sourceCharge); 

        // Induced Charges Arrays
        const innerCharges = [];
        const outerCharges = [];
        const chargeCount = 60;

        // Materials for small charges
        // MODIFICATION: Changed electron color to Blue (0x2980b9) instead of Cyan
        const negMat = new THREE.MeshStandardMaterial({ color: 0x2980b9, emissive: 0x003366 }); 
        const posMat = new THREE.MeshStandardMaterial({ color: 0xff6b6b, emissive: 0x550000 }); 

        for (let i = 0; i < chargeCount; i++) {
            const u = Math.random();
            const v = Math.random();
            const theta_g = 2 * Math.PI * u;
            const phi_g = Math.acos(2 * v - 1);

            const dir = new THREE.Vector3(
                Math.sin(phi_g) * Math.cos(theta_g),
                Math.cos(phi_g),
                Math.sin(phi_g) * Math.sin(theta_g)
            );

            // Inner Charge (Electrons - Blue)
            const nC = new THREE.Mesh(new THREE.SphereGeometry(0.35), negMat);
            nC.userData = { dir: dir.clone() };
            chargesContainer.add(nC);
            innerCharges.push(nC);

            // Outer Charge (Positive - Red)
            const pC = new THREE.Mesh(new THREE.SphereGeometry(0.35), posMat);
            pC.userData = { dir: dir.clone() };
            chargesContainer.add(pC);
            outerCharges.push(pC);
        }

        // Hide initially
        innerCharges.forEach(c => c.visible = false);
        outerCharges.forEach(c => c.visible = false);

        // --- 4. Logic & Animation ---

        function updateCharges() {
            if (!state.chargePlaced) return;

            // Source position in world space
            const sourcePosWorld = new THREE.Vector3(state.sourcePos, 0, 0);
            const invRot = conductorGroup.quaternion.clone().invert();
            const localSource = sourcePosWorld.clone().applyQuaternion(invRot);

            // 1. Update Inner Negative Charges (React to Source)
            innerCharges.forEach(c => {
                // Cut visibility logic
                const angle = Math.atan2(c.userData.dir.z, c.userData.dir.x);
                let normAngle = angle; if(normAngle < 0) normAngle += Math.PI*2;
                
                if(state.isCut && normAngle > CUT_ANGLE) {
                    c.visible = false;
                } else {
                    c.visible = true;
                }

                // Physics: Inner charges attract to source
                // Calculate vector from center to surface
                let basePos = c.userData.dir.clone();
                // Calculate vector from source to this point on surface
                let surfacePoint = basePos.clone().multiplyScalar(R_inner);
                let dist = surfacePoint.distanceTo(localSource);
                
                // Simple visual approximation of induction concentration
                // The closer the source is to the wall, the more charges bunch there
                let weight = 1 / (dist * dist + 0.1);
                
                // Move the charge along the sphere surface towards the source projection
                let toSource = new THREE.Vector3().subVectors(localSource, new THREE.Vector3(0,0,0)).normalize();
                
                // Interpolate between original random position and source direction
                // Strength of pull depends on how close source is to the wall
                const pullStrength = (Math.abs(state.sourcePos)/5) * 0.8;
                
                const finalDir = new THREE.Vector3().lerpVectors(c.userData.dir, toSource, pullStrength).normalize();
                
                c.position.copy(finalDir).multiplyScalar(R_inner - 0.4);
            });

            // 2. Update Outer Positive Charges (Shielded)
            outerCharges.forEach(c => {
                const angle = Math.atan2(c.userData.dir.z, c.userData.dir.x);
                let normAngle = angle; if(normAngle < 0) normAngle += Math.PI*2;
                if(state.isCut && normAngle > CUT_ANGLE) {
                    c.visible = false;
                } else {
                    c.visible = true;
                }

                // Physics: Outer charges stay uniform because E-field inside metal is 0.
                // The outer charges repel each other equally.
                c.position.copy(c.userData.dir).multiplyScalar(R_outer + 0.4);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.01;
            controls.update();

            if (state.chargePlaced) {
                updateCharges();
            }

            renderer.render(scene, camera);
        }
        animate();

        // --- 5. Interactions ---

        function toggleCut() {
            state.isCut = !state.isCut;
            updateConductorGeometry();
        }

        function insertCharge() {
            state.chargePlaced = true;
            sourceCharge.scale.set(0,0,0);
            sourceCharge.visible = true;
            
            // Auto-switch to cut view if not already, so they see the effect
            if(!state.isCut) {
                toggleCut();
            }

            // Pop in animation for central charge
            let s = 0;
            const id = setInterval(() => {
                s += 0.1;
                sourceCharge.scale.set(s,s,s);
                if(s>=1) clearInterval(id);
            }, 16);

            // Pop in animation for induced charges (they appear instantly)
            updateCharges();
            
            document.querySelector('button[onclick="insertCharge()"]').parentElement.classList.add('disabled');
            checkAdvance();
        }

        document.getElementById('charge-pos').addEventListener('input', (e) => {
            state.sourcePos = parseFloat(e.target.value);
            sourceCharge.position.x = state.sourcePos;
            checkAdvance();
        });

        // --- 6. Story Engine (Updated Narration) ---

        let currentChapter = 0;
        const lessons = [
            {
                title: "The Conductor",
                text: "Welcome to the Electrostatics Lab. Before you is a hollow metallic sphere.<br><br><strong>Physics Principle:</strong> Metals are full of 'free electrons'. These electrons can move around easily, like a fluid.<br><br>Currently, the sphere is <em>neutral</em>. The positive nuclei and negative electrons are perfectly balanced everywhere. Click <strong>Toggle Cutaway View</strong> to inspect the interior.",
                setup: () => {
                    lockAll();
                    document.getElementById('ctrl-place').classList.remove('disabled');
                },
                check: () => state.chargePlaced
            },
            {
                title: "Induction",
                text: "You have placed a positive charge <strong>+Q (Red)</strong> inside. Look what happened immediately!<br><br><strong>1. Attraction:</strong> The +Q attracts the metal's free electrons (Blue) to the <em>inner surface</em>. They want to get as close to +Q as possible.<br><br><strong>2. Conservation:</strong> Since the metal was neutral, moving electrons to the inside leaves a deficit on the outside. This creates a net <strong>Positive Charge (Red)</strong> on the <em>outer surface</em>.<br><br>This separation of charge is called <em>Electrostatic Induction</em>.",
                setup: () => {
                    // Nothing to unlock, just reading
                },
                check: () => true
            },
            {
                title: "Shielding",
                text: "Now, use the slider to <strong>Move the Internal Charge</strong> off-center.<br><br>Observe carefully:<br>1. The <strong>inner blue electrons</strong> shift to follow the +Q source.<br>2. The <strong>outer red charges</strong> <em>do not move</em>. They stay perfectly uniform.<br><br><strong>Why?</strong> The electric field inside the metal wall must be zero. The inner electrons adjust perfectly to cancel the source's field. The outside world is completely 'shielded' from what is happening in the cavity.",
                setup: () => {
                    document.getElementById('ctrl-move').classList.remove('disabled');
                },
                check: () => Math.abs(state.sourcePos) > 2.5
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Topic: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div><div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');
            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Conclusion Reached";
                btn.disabled = true;
            } else {
                btn.innerHTML = "Next Explanation &rarr;";
                btn.disabled = !l.check();
            }
            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            }
        }

        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }

        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() {
            document.getElementById('ctrl-place').classList.add('disabled');
            document.getElementById('ctrl-move').classList.add('disabled');
        }

        function resetSim() {
            state.chargePlaced = false;
            state.sourcePos = 0;
            state.isCut = false;
            updateConductorGeometry();

            sourceCharge.position.x = 0;
            sourceCharge.visible = false;
            
            innerCharges.forEach(c => c.visible = false);
            outerCharges.forEach(c => c.visible = false);
            
            document.getElementById('charge-pos').value = 0;
            document.querySelector('button[onclick="insertCharge()"]').parentElement.classList.remove('disabled');
            
            loadLesson(0);
        }

        loadLesson(0);

        window.addEventListener('resize', () => {
            aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * aspect / 2;
            camera.right = viewSize * aspect / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });
    </script>
</body>
</html>

===== END OF 7_hollow_conductor.html =====


===== START OF 8_farady_cage.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Faraday Cage: First Principles</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* --- CORE STYLING (MATCHING PREVIOUS MODULE) --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            
            /* UPDATED: Orange Accent from First Script */
            --accent: #ff9f43; 
            --accent-hover: #e58e3c;
            
            /* Physics Colors (Kept separate for scientific accuracy) */
            --red: #ff7675;
            --blue: #74b9ff;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong { color: #fff; font-weight: 600; }
        .story-text .h-red { color: var(--red); font-weight: bold; }
        .story-text .h-blue { color: var(--blue); font-weight: bold; }

        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row { margin-bottom: 15px; transition: 0.3s; }
        .control-row.disabled { opacity: 0.5; pointer-events: none; filter: grayscale(1); }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
            margin-bottom: 5px;
        }

        button:hover { background: #444; color: #fff; }
        
        button.primary { background: #2a2a2a; border-color: var(--accent); color: var(--accent); }
        button.primary:hover { background: var(--accent); color: #111; }

        input[type=range] { width: 100%; accent-color: var(--accent); }

        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn { width: 48%; background: #333; color: #fff; border: none; }
        .nav-btn.next { background: var(--accent); color: #151515; }
        .nav-btn.next:hover { background: var(--accent-hover); }
        .nav-btn.next:disabled { opacity: 0.5; cursor: not-allowed; background: #444; }

        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        /* Overlay for vector math visualization */
        #vector-hud {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border: 1px solid #444;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            pointer-events: none;
        }
        .hud-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .bar-container { width: 80px; background: #333; height: 6px; margin-top: 6px; border-radius:3px; overflow:hidden;}
        .bar { height: 100%; transition: width 0.1s; }
    </style>
</head>

<body>
    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Chapter 6: The Faraday Cage</div>
        </header>

        <div id="story-container">
            <div id="chapter-content"></div>
        </div>

        <div id="controls-area">
            <div class="control-row" id="ctrl-field">
                <label>Step 1: External Environment</label>
                <button class="primary" onclick="toggleExternalField()">Activate External Field (E-Ext)</button>
            </div>

            <div class="control-row disabled" id="ctrl-physics">
                <label>Step 2: Conductor Response</label>
                <input type="range" id="separation-slider" min="0" max="1" step="0.01" value="0">
                <div style="font-size: 10px; color: #555; margin-top: 5px; display:flex; justify-content:space-between;">
                    <span>Random (Neutral)</span>
                    <span>Separated (Polarized)</span>
                </div>
            </div>

            <div class="control-row" style="margin-top:20px; border-top:1px solid #333; padding-top:15px;">
                <button onclick="resetSim()">Reset Simulation</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="location.reload()">Back</button> <!-- Placeholder logic -->
            <button class="nav-btn next" id="btn-next" disabled onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div id="vector-hud" style="opacity:0; transition: opacity 0.5s;">
            <div style="text-align:center; color:#888; margin-bottom:10px;">FIELD SENSOR (CENTER)</div>
            <div class="hud-row">
                <span style="color:var(--red)">E-External</span>
                <div class="bar-container"><div class="bar" id="bar-ext" style="background:var(--red); width:0%"></div></div>
            </div>
            <div class="hud-row">
                <span style="color:var(--blue)">E-Induced</span>
                <div class="bar-container"><div class="bar" id="bar-ind" style="background:var(--blue); width:0%"></div></div>
            </div>
            <div style="border-top:1px solid #555; margin:5px 0;"></div>
            <div class="hud-row">
                <span style="color:#fff; font-weight:bold;">E-NET</span>
                <div class="bar-container"><div class="bar" id="bar-net" style="background:#fff; width:0%"></div></div>
            </div>
        </div>
    </main>

    <script>
        // --- 1. Scene Setup ---
        const state = {
            fieldActive: false,
            separation: 0, // 0 to 1
            time: 0
        };

        const scene = new THREE.Scene();
        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 40;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );
        camera.position.set(20, 15, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        document.getElementById('world').appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minZoom = 0.5;
        controls.maxZoom = 2;

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);

        // --- 2. Geometry: The Cage ---
        const cageRadius = 10;
        const cageGroup = new THREE.Group();
        scene.add(cageGroup);

        // Visual Cage (Wireframe + Transparent Shell)
        const geometry = new THREE.IcosahedronGeometry(cageRadius, 2);
        
        // Wireframe
        const wireframeMat = new THREE.MeshBasicMaterial({ color: 0x444444, wireframe: true, transparent: true, opacity: 0.3 });
        const cageMesh = new THREE.Mesh(geometry, wireframeMat);
        cageGroup.add(cageMesh);

        // Aesthetic Lattice (Thicker wires)
        const edges = new THREE.EdgesGeometry(geometry);
        const thickWireMat = new THREE.LineBasicMaterial( { color: 0x888888 } );
        const wireLines = new THREE.LineSegments( edges, thickWireMat );
        cageGroup.add( wireLines );

        // --- 3. Particles (Electrons & Ions) ---
        const particleCount = 120;
        const electrons = [];
        const ions = [];

        // Materials
        const electronMat = new THREE.MeshStandardMaterial({ color: 0x74b9ff, emissive: 0x001133 }); // Blue
        const ionMat = new THREE.MeshStandardMaterial({ color: 0xff7675, emissive: 0x330000 }); // Red

        // Helper to place on sphere surface
        function getSpherePoint() {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            return new THREE.Vector3(
                cageRadius * Math.sin(phi) * Math.cos(theta),
                cageRadius * Math.cos(phi),
                cageRadius * Math.sin(phi) * Math.sin(theta)
            );
        }

        // Initialize Particles randomly
        for(let i=0; i<particleCount; i++) {
            const pos = getSpherePoint();
            
            // Fixed Positive Ion (The lattice structure)
            const ion = new THREE.Mesh(new THREE.SphereGeometry(0.3), ionMat);
            ion.position.copy(pos);
            cageGroup.add(ion);
            ions.push({ mesh: ion, basePos: pos.clone() });

            // Mobile Electron (The sea of charge)
            const elec = new THREE.Mesh(new THREE.SphereGeometry(0.3), electronMat);
            elec.position.copy(pos);
            cageGroup.add(elec);
            
            // Store data for animation
            electrons.push({
                mesh: elec,
                basePos: pos.clone(), // Where it belongs physically in the lattice
                currentPos: pos.clone(),
                velocity: new THREE.Vector3()
            });
        }

        // --- 4. The External Field (Visuals) ---
        const fieldGroup = new THREE.Group();
        scene.add(fieldGroup);
        const arrows = [];

        for(let x = -25; x <= 25; x+=10) {
            for(let y = -15; y <= 15; y+=10) {
                for(let z = -15; z <= 15; z+=10) {
                    if (Math.abs(x) < 8 && Math.abs(y) < 8 && Math.abs(z) < 8) continue; // Skip inside cage

                    const dir = new THREE.Vector3(1, 0, 0); // Field moves +X
                    const arrow = new THREE.ArrowHelper(dir, new THREE.Vector3(x, y, z), 4, 0xff5555, 1, 0.5);
                    arrow.visible = false;
                    fieldGroup.add(arrow);
                    arrows.push({ mesh: arrow, baseX: x });
                }
            }
        }

        // --- 5. Internal Vector Visualization (The Math) ---
        const vecGroup = new THREE.Group();
        scene.add(vecGroup);

        // Red Arrow (External Field)
        const vecExt = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 0, 0xff7675, 1, 1);
        vecGroup.add(vecExt);

        // Blue Arrow (Induced Field)
        const vecInd = new THREE.ArrowHelper(new THREE.Vector3(-1,0,0), new THREE.Vector3(0,0,0), 0, 0x74b9ff, 1, 1);
        vecGroup.add(vecInd);

        // --- 6. Physics & Animation Logic ---

        function updatePhysics() {
            // Target positions based on state.separation
            // If separation = 1, electrons cluster on LEFT (-x), leaving + on RIGHT (+x).
            
            // We simulate this by defining a "Target" point for every electron.
            // If Field is ON, target is -X side. If OFF, target is basePos.

            const fieldStrength = state.fieldActive ? 1 : 0;
            
            // Update HUD
            const indMag = state.separation * 5; // Visual scale
            const extMag = fieldStrength * 5;
            const netMag = Math.max(0, extMag - indMag);
            
            // Update Arrow Helpers in Scene
            if(state.fieldActive) {
                vecExt.setLength(extMag, 2, 1);
                vecInd.setLength(indMag, 2, 1);
                
                // Opacity logic for sensor
                document.getElementById('vector-hud').style.opacity = 1;
                document.getElementById('bar-ext').style.width = '100%';
                document.getElementById('bar-ind').style.width = (state.separation * 100) + '%';
                document.getElementById('bar-net').style.width = ((1 - state.separation) * 100) + '%';
            } else {
                vecExt.setLength(0,0,0);
                vecInd.setLength(0,0,0);
                document.getElementById('vector-hud').style.opacity = 0;
            }

            // Animate Electrons
            electrons.forEach(e => {
                let target = e.basePos.clone();

                if (state.fieldActive) {
                    // Logic: Project position onto sphere, but biased towards -X
                    // Simple bias: Lerp the base position towards (-Radius, 0, 0) based on separation
                    const negativePole = new THREE.Vector3(-cageRadius, 0, 0);
                    
                    const bias = new THREE.Vector3(-1, 0, 0).multiplyScalar(state.separation * 15);
                    const biasedPos = e.basePos.clone().add(bias);
                    target = biasedPos.normalize().multiplyScalar(cageRadius);
                }

                // Smooth movement
                e.mesh.position.lerp(target, 0.1);
            });

            // Animate Field Arrows (Flow effect)
            if (state.fieldActive) {
                const time = Date.now() * 0.001;
                arrows.forEach(a => {
                    a.mesh.visible = true;
                    // Wiggle effect to show "flow"
                    a.mesh.position.x = a.baseX + Math.sin(time * 5 + a.baseX) * 0.2;
                });
            } else {
                arrows.forEach(a => a.mesh.visible = false);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updatePhysics();
            renderer.render(scene, camera);
        }
        animate();

        // --- 7. Interactions ---

        function toggleExternalField() {
            state.fieldActive = true;
            document.querySelector('button[onclick="toggleExternalField()"]').parentElement.classList.add('disabled');
            checkAdvance();
        }

        document.getElementById('separation-slider').addEventListener('input', (e) => {
            state.separation = parseFloat(e.target.value);
            checkAdvance();
        });

        function resetSim() {
            state.fieldActive = false;
            state.separation = 0;
            document.getElementById('separation-slider').value = 0;
            document.querySelector('button[onclick="toggleExternalField()"]').parentElement.classList.remove('disabled');
            loadLesson(0);
        }

        // --- 8. Story Engine ---

        const lessons = [
            {
                title: "The External Threat",
                text: "We begin with a neutral conductive cage in empty space. <br><br>Click <strong>Activate External Field</strong> to apply a strong electric field ($E_{ext}$) moving from Left to Right (Red Arrows).<br><br>Notice that initially, the field lines penetrate the space. If you were inside, you would feel this force.",
                check: () => state.fieldActive,
                setup: () => {
                    document.getElementById('ctrl-physics').classList.add('disabled');
                }
            },
            {
                title: "Charge Migration",
                text: "This is a conductor. It is filled with free electrons (Blue) that can move.<br><br><strong>First Principle:</strong> An Electric Field applies a force $F = qE$.<br>Since electrons are negative, they feel a force to the <strong>Left</strong> (upstream against the Red field).<br><br>Use the slider to simulate the <strong>Conductor Response</strong>. As you drag it, watch the electrons migrate.",
                check: () => state.separation > 0.1,
                setup: () => {
                    document.getElementById('ctrl-physics').classList.remove('disabled');
                }
            },
            {
                title: "Equilibrium",
                text: "Drag the slider to the max.<br><br>1. Electrons bunch up on the Left (-).<br>2. Positive ions are left exposed on the Right (+).<br><br>This separation creates a <strong>New Internal Field</strong> (Blue Arrow) pointing from + to - (Right to Left).<br><br>Look at the Sensor in the center. The Induced Field eventually equals the External Field in strength but opposite in direction. <br><br><strong>Net Field = 0.</strong> The cage has cancelled the field inside itself.",
                check: () => state.separation > 0.9,
                setup: () => {}
            }
        ];

        let currentChapter = 0;

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Chapter 6: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div><div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');
            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Conclusion";
                btn.disabled = true;
            } else {
                btn.innerHTML = "Next Step &rarr;";
                btn.disabled = !l.check();
            }
            if(l.setup) l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            }
        }

        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        window.addEventListener('resize', () => {
            aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * aspect / 2;
            camera.right = viewSize * aspect / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

        loadLesson(0);

    </script>
</body>
</html>

===== END OF 8_farady_cage.html =====


===== START OF 9_shielding_appplications.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Shielding Applications</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* --- THEME SETTINGS (ORANGE ACCENT) --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            
            /* Updated to Orange to match Chapter 5 */
            --accent: #ff9f43; 
            --accent-hover: #e58e3c;
            
            --danger: #ff7675;
            --good: #55efc4;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* --- SIDEBAR --- */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        /* --- STORY & CONTENT --- */
        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .scenario-tag {
            display: inline-block;
            background: #333;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            text-transform: uppercase;
            margin-bottom: 10px;
            border: 1px solid #555;
        }

        .chapter-title {
            font-size: 22px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 15px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.7;
            font-size: 14px;
            color: #ccc;
            margin-bottom: 20px;
        }
        
        .story-text strong { color: #fff; }

        /* --- CONTROLS --- */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 12px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
            margin-bottom: 10px;
        }

        button:hover { background: #444; color: #fff; }
        
        button.action-btn {
            background: #2d3436;
            border-color: var(--accent);
            color: var(--accent);
        }
        button.action-btn:hover { background: var(--accent); color: #111; }
        
        button.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
            filter: grayscale(1);
        }

        /* --- NAVIGATION --- */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn { width: 48%; border: none; background: #333; color: white;}
        .nav-btn.next { background: var(--accent); color: #111; }
        .nav-btn.next:hover { background: var(--accent-hover); }

        /* --- MAIN VIEWPORT --- */
        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #2d3436 0%, #000000 100%);
            overflow: hidden;
        }

        /* --- HUD ELEMENTS --- */
        .hud-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            padding: 15px;
            border-radius: 8px;
            color: #fff;
            font-family: monospace;
            width: 200px;
            pointer-events: none;
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        .status-val { font-weight: bold; }
        .val-danger { color: var(--danger); }
        .val-safe { color: var(--good); }

        #scope-canvas {
            width: 100%;
            height: 60px;
            background: #111;
            border: 1px solid #333;
            margin-top: 5px;
        }
    </style>
</head>

<body>
    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Chapter 7: Real-World Applications</div>
        </header>

        <div id="story-container">
            <div id="chapter-content"></div>
        </div>

        <div id="controls-area">
            <div id="dynamic-controls"></div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevScenario()">Previous</button>
            <button class="nav-btn next" id="btn-next" onclick="nextScenario()">Next Scenario &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div id="hud" class="hud-panel" style="display:none;">
            <div style="border-bottom:1px solid #444; margin-bottom:10px; padding-bottom:5px; color:#888;">SENSOR READINGS</div>
            <div id="hud-content"></div>
        </div>
    </main>

    <script>
        // --- 1. THREE.JS BOILERPLATE ---
        const scene = new THREE.Scene();
        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        
        const camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
        camera.position.set(30, 20, 30);
        camera.lookAt(0, 5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        document.getElementById('world').appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);
        const pointLight = new THREE.PointLight(0xff9f43, 0.5); // Orange glow for atmosphere
        pointLight.position.set(0, 10, 0);
        scene.add(pointLight);

        // --- 2. SCENARIO OBJECTS ---
        
        const groupCar = new THREE.Group();
        const groupCable = new THREE.Group();
        const groupMRI = new THREE.Group();
        scene.add(groupCar);
        scene.add(groupCable);
        scene.add(groupMRI);

        groupCar.visible = false;
        groupCable.visible = false;
        groupMRI.visible = false;

        // === SCENARIO 1: THE CAR ===
        const carMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.2, metalness: 0.8 });
        const carBody = new THREE.Mesh(new THREE.BoxGeometry(10, 3, 18), carMat);
        carBody.position.y = 3;
        const carTop = new THREE.Mesh(new THREE.BoxGeometry(9, 2.5, 10), carMat);
        carTop.position.y = 5.5;
        
        // Wheels
        const wheelGeo = new THREE.CylinderGeometry(1.5, 1.5, 1, 16);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        [[-4, 1.5, 6], [4, 1.5, 6], [-4, 1.5, -6], [4, 1.5, -6]].forEach(pos => {
            const w = new THREE.Mesh(wheelGeo, wheelMat);
            w.rotation.z = Math.PI/2;
            w.position.set(...pos);
            groupCar.add(w);
        });
        groupCar.add(carBody, carTop);

        const ground = new THREE.Mesh(new THREE.CircleGeometry(25, 32), new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 1 }));
        ground.rotation.x = -Math.PI/2;
        groupCar.add(ground);

        // Lightning Vars
        const lightningMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 3 });
        let lightningLine = null;

        // === SCENARIO 2: COAXIAL CABLE ===
        const cableLength = 20;
        
        // Inner Conductor
        const innerGeo = new THREE.CylinderGeometry(0.5, 0.5, cableLength, 16);
        const innerMat = new THREE.MeshStandardMaterial({ color: 0xff6b6b }); 
        const innerWire = new THREE.Mesh(innerGeo, innerMat);
        innerWire.rotation.z = Math.PI/2;
        groupCable.add(innerWire);

        // Insulator
        const dielecGeo = new THREE.CylinderGeometry(2, 2, cableLength, 16, 1, true);
        const dielecMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
        const dielectric = new THREE.Mesh(dielecGeo, dielecMat);
        dielectric.rotation.z = Math.PI/2;
        groupCable.add(dielectric);

        // Shield
        const shieldGeo = new THREE.CylinderGeometry(2.1, 2.1, cableLength, 16, 1, true);
        const shieldMat = new THREE.MeshStandardMaterial({ 
            color: 0xaaaaaa, 
            side: THREE.DoubleSide, 
            wireframe: true, 
            transparent: true,
            opacity: 0.1 
        }); 
        const cableShield = new THREE.Mesh(shieldGeo, shieldMat);
        cableShield.rotation.z = Math.PI/2;
        groupCable.add(cableShield);

        const noiseParticles = new THREE.Group();
        groupCable.add(noiseParticles);

        // === SCENARIO 3: MRI ROOM (Detailed) ===
        
        // 1. The Copper Room (Cage)
        // Using a copper color to signify the shielding
        const roomGeo = new THREE.BoxGeometry(16, 12, 16);
        const roomMat = new THREE.MeshBasicMaterial({ color: 0xb87333, wireframe: true }); // Copper
        const mriRoom = new THREE.Mesh(roomGeo, roomMat);
        mriRoom.position.y = 6;
        groupMRI.add(mriRoom);

        // 2. The Scanner Construction
        const scannerGroup = new THREE.Group();
        groupMRI.add(scannerGroup);
        scannerGroup.position.set(0, 4.5, 0);

        // Main Bore (White Plastic)
        const boreMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3, metalness: 0.1 });
        const boreOuter = new THREE.Mesh(new THREE.CylinderGeometry(3.5, 3.5, 5, 32, 1, true), boreMat);
        const boreInner = new THREE.Mesh(new THREE.CylinderGeometry(2.0, 2.0, 5, 32, 1, true), new THREE.MeshStandardMaterial({ color: 0xeeeeee, side: THREE.DoubleSide }));
        boreOuter.rotation.z = Math.PI/2;
        boreInner.rotation.z = Math.PI/2;
        scannerGroup.add(boreOuter, boreInner);

        // Front Face (Donut Ring)
        const ringGeo = new THREE.RingGeometry(2.0, 3.5, 32);
        const frontFace = new THREE.Mesh(ringGeo, boreMat);
        frontFace.rotation.y = Math.PI/2;
        frontFace.position.x = 2.5;
        const backFace = frontFace.clone();
        backFace.position.x = -2.5;
        backFace.rotation.y = -Math.PI/2;
        scannerGroup.add(frontFace, backFace);

        // Support Base
        const baseGeo = new THREE.BoxGeometry(4, 3, 4);
        const base = new THREE.Mesh(baseGeo, new THREE.MeshStandardMaterial({color: 0xdddddd}));
        base.position.y = -2.5; 
        scannerGroup.add(base);

        // Patient Table (Sliding out)
        const tableGeo = new THREE.BoxGeometry(8, 0.2, 1.8);
        const table = new THREE.Mesh(tableGeo, new THREE.MeshStandardMaterial({color: 0x333333}));
        table.position.set(3, -0.5, 0); 
        scannerGroup.add(table);

        // Control Window (Glass in the copper wall)
        const winGeo = new THREE.PlaneGeometry(6, 4);
        const winMat = new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
        const windowPane = new THREE.Mesh(winGeo, winMat);
        windowPane.position.set(0, 6, -8); // On back wall
        groupMRI.add(windowPane);

        // 3. The Door (Shield)
        const doorGeo = new THREE.PlaneGeometry(6, 10);
        const doorMat = new THREE.MeshStandardMaterial({ color: 0xb87333, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
        const door = new THREE.Mesh(doorGeo, doorMat);
        door.position.set(0, 6, 8); // Front wall
        groupMRI.add(door);

        const waveGroup = new THREE.Group();
        groupMRI.add(waveGroup);


        // --- 3. ANIMATION STATE ---
        const appState = {
            scenario: 0,
            flashIntensity: 0,
            lightningActive: false,
            shieldEnabled: false,
            signalTime: 0,
            doorClosed: false
        };

        // --- 4. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Car Flash
            if (appState.flashIntensity > 0) {
                appState.flashIntensity -= 0.05;
                carMat.emissive.setScalar(appState.flashIntensity * 0.5);
            }

            // Cable Noise
            if(groupCable.visible) {
                appState.signalTime += 0.2;
                renderOscilloscope();
                animateNoiseParticles();
            }

            // MRI Waves
            if(groupMRI.visible) {
                animateMRIWaves();
            }

            renderer.render(scene, camera);
        }

        function animateNoiseParticles() {
            if(Math.random() > 0.8) {
                const p = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({color: 0xffff00}));
                const angle = Math.random() * Math.PI * 2;
                p.position.set((Math.random() - 0.5) * 20, Math.sin(angle) * 6, Math.cos(angle) * 6);
                p.userData = { vel: new THREE.Vector3(0, -Math.sin(angle)*0.2, -Math.cos(angle)*0.2) };
                noiseParticles.add(p);
            }

            for(let i=noiseParticles.children.length-1; i>=0; i--){
                const p = noiseParticles.children[i];
                p.position.add(p.userData.vel);
                const dist = Math.sqrt(p.position.y**2 + p.position.z**2);
                
                if(appState.shieldEnabled && dist < 2.2) {
                    p.material.color.setHex(0xaaaaaa);
                    p.scale.multiplyScalar(0.8);
                    if(p.scale.x < 0.1) noiseParticles.remove(p);
                } 
                else if (!appState.shieldEnabled && dist < 0.6) {
                    noiseParticles.remove(p);
                    appState.signalTime += Math.random() * 5; 
                }
            }
        }

        function animateMRIWaves() {
            // Generate expanding rings outside
            if(Math.random() > 0.9) {
                const ring = new THREE.Mesh(
                    new THREE.RingGeometry(1, 1.2, 32),
                    new THREE.MeshBasicMaterial({ color: 0xff9f43, transparent: true, opacity: 0.8, side: THREE.DoubleSide })
                );
                ring.position.set((Math.random()-0.5)*40, (Math.random())*20, (Math.random()-0.5)*40);
                ring.lookAt(0, 6, 0); 
                if(ring.position.distanceTo(new THREE.Vector3(0,6,0)) > 10) {
                    waveGroup.add(ring);
                }
            }

            for(let i=waveGroup.children.length-1; i>=0; i--){
                const r = waveGroup.children[i];
                const center = new THREE.Vector3(0,6,0);
                const dir = new THREE.Vector3().subVectors(center, r.position).normalize();
                r.position.add(dir.multiplyScalar(0.2));
                const dist = r.position.distanceTo(center);

                // Hit Room Walls (approx radius 8)
                if(dist < 8) {
                    if(appState.doorClosed) {
                        r.material.opacity -= 0.1;
                        if(r.material.opacity <= 0) waveGroup.remove(r);
                    } else {
                        if(dist < 2) waveGroup.remove(r);
                    }
                }
            }
        }

        // --- 5. INTERACTION LOGIC ---

        function strikeLightning() {
            if(appState.lightningActive) return;
            appState.lightningActive = true;
            appState.flashIntensity = 1.0;

            const points = [];
            points.push(new THREE.Vector3(0, 30, 0));
            let curr = new THREE.Vector3(0, 30, 0);
            for(let i=0; i<10; i++) {
                curr.y -= 2.5;
                curr.x += (Math.random()-0.5)*2;
                curr.z += (Math.random()-0.5)*2;
                points.push(curr.clone());
            }
            points.push(new THREE.Vector3(0, 5.5, 0));

            const groundPath1 = [new THREE.Vector3(0,5.5,0), new THREE.Vector3(5,3,0), new THREE.Vector3(5,0,0)];
            const groundPath2 = [new THREE.Vector3(0,5.5,0), new THREE.Vector3(-5,3,0), new THREE.Vector3(-5,0,0)];

            if(lightningLine) scene.remove(lightningLine);
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            lightningLine = new THREE.Line(geo, lightningMaterial);
            scene.add(lightningLine);

            const arcMat = new THREE.LineBasicMaterial({color: 0x00ffff});
            const arc1 = new THREE.Line(new THREE.BufferGeometry().setFromPoints(groundPath1), arcMat);
            const arc2 = new THREE.Line(new THREE.BufferGeometry().setFromPoints(groundPath2), arcMat);
            scene.add(arc1, arc2);

            updateHUD("Car", "STRIKE DETECTED", "Surface Flow", "0 V/m");

            setTimeout(() => {
                scene.remove(lightningLine);
                scene.remove(arc1);
                scene.remove(arc2);
                appState.lightningActive = false;
                document.getElementById('btn-next').disabled = false;
            }, 500);
        }

        function toggleCableShield() {
            appState.shieldEnabled = !appState.shieldEnabled;
            const btn = document.getElementById('btn-shield');
            
            if(appState.shieldEnabled) {
                cableShield.material.opacity = 0.8;
                cableShield.material.wireframe = false;
                cableShield.material.color.setHex(0xefefef);
                btn.innerText = "Deactivate Braided Shield";
                btn.classList.remove('action-btn');
                updateHUD("Cable", "Shield ACTIVE", "Clean Signal", "Protected");
            } else {
                cableShield.material.opacity = 0.1;
                cableShield.material.wireframe = true;
                cableShield.material.color.setHex(0xaaaaaa);
                btn.innerText = "Activate Braided Shield";
                btn.classList.add('action-btn');
                updateHUD("Cable", "Shield OFF", "High Noise", "Vulnerable");
            }
            document.getElementById('btn-next').disabled = false;
        }

        function toggleMRIDoor() {
            appState.doorClosed = !appState.doorClosed;
            const btn = document.getElementById('btn-door');

            if(appState.doorClosed) {
                door.material.opacity = 0.9;
                door.material.color.setHex(0xb87333); 
                btn.innerText = "Open RF Door";
                updateHUD("MRI", "Cage SEALED", "Scan Quality: 100%", "Quiet");
            } else {
                door.material.opacity = 0.1;
                btn.innerText = "Close RF Door";
                updateHUD("MRI", "Door OPEN", "Scan Quality: 15%", "Noisy");
            }
            document.getElementById('btn-next').disabled = false;
        }

        // --- 6. 2D CANVAS RENDERING ---
        function renderOscilloscope() {
            const canvas = document.getElementById('scope-canvas');
            if(!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#111';
            ctx.fillRect(0,0,w,h);
            ctx.beginPath();
            ctx.strokeStyle = '#ff6b6b'; 
            ctx.lineWidth = 2;
            
            const t = appState.signalTime;
            for(let x=0; x<w; x++) {
                let y = Math.sin((x + t*10) * 0.05) * (h/3);
                if(!appState.shieldEnabled) {
                    y += (Math.random() - 0.5) * (h/1.5);
                }
                ctx.lineTo(x, h/2 + y);
            }
            ctx.stroke();
        }

        function updateHUD(mode, status, detail, field) {
            const hud = document.getElementById('hud');
            hud.style.display = 'block';
            const content = document.getElementById('hud-content');
            
            let colorClass = status.includes("OFF") || status.includes("OPEN") ? "val-danger" : "val-safe";
            if(mode === "Car") colorClass = "val-safe"; 

            content.innerHTML = `
                <div class="status-row"><span>System:</span> <span class="status-val">${mode}</span></div>
                <div class="status-row"><span>Status:</span> <span class="status-val ${colorClass}">${status}</span></div>
                <div class="status-row"><span>Detail:</span> <span class="status-val">${detail}</span></div>
                <div class="status-row"><span>Interior Field:</span> <span class="status-val">${field}</span></div>
            `;
            
            if(mode === "Cable") {
                content.innerHTML += `<canvas id="scope-canvas" width="170" height="60"></canvas>`;
            }
        }

        // --- 7. STORY ENGINE ---

        const scenarios = [
            {
                id: 0,
                group: groupCar,
                title: "Faraday Cage on Wheels",
                tag: "Electrostatics",
                text: "Does a car's rubber tires protect you from lightning? <strong>No.</strong><br><br>The car is a metal shell—a Faraday Cage. If lightning strikes, the massive charge flows along the <em>outer skin</em> of the metal body and jumps to the ground.<br><br>The electric field inside the car remains zero. You are safe because of the metal body, not the rubber tires.",
                controls: `<button class="action-btn" onclick="strikeLightning()">Strike Lightning</button>`,
                init: () => {
                    camera.position.set(20, 10, 20);
                    updateHUD("Car", "Standby", "Neutral", "0 V/m");
                    document.getElementById('btn-next').disabled = true;
                }
            },
            {
                id: 1,
                group: groupCable,
                title: "Shielding Electronics",
                tag: "Signal Integrity",
                text: "This is a <strong>Coaxial Cable</strong> carrying delicate data (red wire).<br><br>Electronic 'noise' (yellow particles) from power lines and wifi surrounds us. Without a shield, this noise corrupts the signal (watch the graph glitch).<br><br>The outer braided mesh acts as a flexible Faraday cage, catching the noise and grounding it before it reaches the core.",
                controls: `<button id="btn-shield" class="action-btn" onclick="toggleCableShield()">Activate Braided Shield</button>`,
                init: () => {
                    camera.position.set(15, 15, 0);
                    camera.lookAt(0, 0, 0);
                    appState.shieldEnabled = false;
                    cableShield.material.opacity = 0.1;
                    cableShield.material.wireframe = true;
                    updateHUD("Cable", "Shield OFF", "Noisy", "High");
                    document.getElementById('btn-next').disabled = true;
                }
            },
            {
                id: 2,
                group: groupMRI,
                title: "The Silent Room (MRI)",
                tag: "RF Shielding",
                text: "An MRI machine (white cylinder) detects faint radio signals from your body. <br><br>The surrounding room is lined with a <strong>Copper Mesh</strong> (Faraday Cage) to block external 'RF Smog' (orange waves).<br><br>If the door is open, the cage is incomplete, and external noise ruins the scan.",
                controls: `<button id="btn-door" class="action-btn" onclick="toggleMRIDoor()">Close RF Door</button>`,
                init: () => {
                    camera.position.set(0, 15, 30);
                    camera.lookAt(0, 5, 0);
                    appState.doorClosed = false;
                    door.material.opacity = 0.1;
                    updateHUD("MRI", "Door OPEN", "Interference", "High");
                    document.getElementById('btn-next').disabled = true;
                }
            }
        ];

        function loadScenario(index) {
            appState.scenario = index;
            const s = scenarios[index];

            groupCar.visible = (index === 0);
            groupCable.visible = (index === 1);
            groupMRI.visible = (index === 2);

            document.querySelector('header .subtitle').innerText = `Chapter 7: ${s.title}`;
            document.getElementById('chapter-content').innerHTML = `
                <div class="scenario-tag" style="border-color:var(--accent); color:var(--accent);">${s.tag}</div>
                <div class="chapter-title">${s.title}</div>
                <div class="story-text">${s.text}</div>
            `;
            document.getElementById('dynamic-controls').innerHTML = s.controls;
            
            s.init();
        }

        function nextScenario() {
            if (appState.scenario < scenarios.length - 1) {
                loadScenario(appState.scenario + 1);
            } else {
                alert("Course Complete! You have mastered the applications of Electrostatic Shielding.");
            }
        }
        
        function prevScenario() {
            if (appState.scenario > 0) {
                loadScenario(appState.scenario - 1);
            }
        }

        animate();
        loadScenario(0);

        window.addEventListener('resize', () => {
            aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

    </script>
</body>
</html>

===== END OF 9_shielding_appplications.html =====
