<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Maxwell's Notebook: 3D Capacitor Geometry</title>
    <!-- Load KaTeX for Math Rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body);"></script>

    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        :root {
            --bg: #0f0f0f;
            --panel: #181818;
            --text-main: #e0e0e0;
            --text-muted: #888;
            --accent: #ff9f43;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text-main);
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }

        aside {
            width: 400px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 5px 0 20px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
        }

        h1 {
            margin: 0;
            font-size: 18px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: var(--text-muted);
        }

        #content-area {
            flex: 1;
            padding: 25px;
            overflow-y: auto;
        }

        .chapter-marker {
            font-size: 11px;
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        h2 {
            margin: 0 0 15px 0;
            font-size: 22px;
            color: #fff;
        }

        p {
            line-height: 1.6;
            font-size: 14px;
            color: #ccc;
            margin-bottom: 15px;
        }

        .math-highlight {
            background: rgba(255, 255, 255, 0.03);
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid var(--accent);
            margin: 15px 0;
            text-align: center;
            font-size: 1.1em;
        }

        #controls-wrapper {
            background: #111;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-header {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .control-val {
            color: var(--accent);
            font-family: monospace;
            font-weight: bold;
        }

        .btn-row {
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 11px;
            transition: 0.2s;
        }

        .btn-next {
            background: var(--accent);
            color: #111;
        }

        .btn-back {
            background: transparent;
            border: 1px solid #444;
            color: #888;
        }

        main {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Chapter 6: Geometry of Capacitance</div>
        </header>

        <div id="content-area"></div>

        <div id="controls-wrapper">
            <div id="dynamic-controls"></div>
            <div class="btn-row">
                <button class="btn-back" onclick="prevStep()">Back</button>
                <button class="btn-next" id="btn-next" onclick="nextStep()">Next</button>
            </div>
        </div>
    </aside>

    <main>
        <div id="canvas-container"></div>
    </main>

    <script>
        // --- THREE.JS SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);

        const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(25, 20, 25);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xff9f43, 2, 100);
        pointLight.position.set(15, 15, 15);
        scene.add(pointLight);

        const grid = new THREE.GridHelper(60, 40, 0x222222, 0x111111);
        scene.add(grid);

        // --- GEOMETRY ---
        const SEGMENTS = 500; // Higher segments for smoother spiral
        const STRIP_LENGTH = 45;
        const STRIP_WIDTH = 8;
        const PLATE_GAP = 0.6; // Increased gap to prevent Z-fighting

        const plateMat = new THREE.MeshStandardMaterial({ color: 0xff9f43, side: THREE.DoubleSide, metalness: 0.7, roughness: 0.2 });
        // Dielectric is slightly more opaque to define boundaries
        const dielectricMat = new THREE.MeshStandardMaterial({ color: 0x34495e, side: THREE.DoubleSide, transparent: true, opacity: 0.85 });

        function createRibbon(offsetY, material) {
            const geometry = new THREE.PlaneGeometry(STRIP_LENGTH, STRIP_WIDTH, SEGMENTS, 1);
            geometry.rotateX(-Math.PI / 2);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.y = offsetY;
            mesh.userData = {
                originalPos: geometry.attributes.position.clone(),
                yOffset: offsetY // Store the specific lane (Top, Mid, or Bot)
            };
            return mesh;
        }

        const plateTop = createRibbon(PLATE_GAP, plateMat);
        const dielectric = createRibbon(0, dielectricMat);
        const plateBot = createRibbon(-PLATE_GAP, plateMat);

        const capacitorGroup = new THREE.Group();
        capacitorGroup.add(plateTop, dielectric, plateBot);
        scene.add(capacitorGroup);

        let simState = { rollProgress: 0, targetRoll: 0 };

        function updateGeometry(mesh, progress) {
            const positions = mesh.geometry.attributes.position;
            const original = mesh.userData.originalPos;
            const yOffset = mesh.userData.yOffset; // Lane identifier

            const coreRadius = 2.0;
            const maxTheta = STRIP_LENGTH / coreRadius;

            for (let i = 0; i < positions.count; i++) {
                const ox = original.getX(i);
                const oy = original.getY(i); // This is the local Y (thickness)
                const oz = original.getZ(i);
                const u = (ox + STRIP_LENGTH / 2) / STRIP_LENGTH;

                if (progress < 0.001) {
                    positions.setXYZ(i, ox, oy, oz);
                } else {
                    // spiral wrapping
                    const theta = u * maxTheta * progress * 2.8;

                    // SPIRAL GROWTH (b): Increased to 0.25 to ensure layers don't overlap
                    // as they wrap around.
                    const b = 0.25;

                    // RADIUS CALCULATION:
                    // We add 'yOffset' to the radius. This ensures PlateTop is always 
                    // further from center than Dielectric, which is further than PlateBot.
                    const radius = coreRadius + (b * theta) + (yOffset * progress);

                    const tx = radius * Math.cos(-theta);
                    const ty = oz; // width becomes cylinder height
                    const tz = radius * Math.sin(-theta);

                    positions.setXYZ(i,
                        ox * (1 - progress) + tx * progress,
                        oy * (1 - progress) + ty * progress,
                        oz * (1 - progress) + tz * progress
                    );
                }
            }
            positions.needsUpdate = true;
            mesh.geometry.computeVertexNormals();
        }

        function animate() {
            requestAnimationFrame(animate);
            simState.rollProgress += (simState.targetRoll - simState.rollProgress) * 0.06;

            if (simState.rollProgress > 0.8) {
                capacitorGroup.rotation.y += 0.01;
            } else {
                capacitorGroup.rotation.y *= 0.92;
            }

            updateGeometry(plateTop, simState.rollProgress);
            updateGeometry(dielectric, simState.rollProgress);
            updateGeometry(plateBot, simState.rollProgress);
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = (window.innerWidth - 400) / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - 400, window.innerHeight);
        });

        // --- STEPS ---
        const steps = [
            {
                title: "The Formula",
                content: `<div class="chapter-marker">Introduction</div><h2>Linear Geometry</h2>
            <p>Capacitance ($C$) is determined by the Area ($A$) of conductors and the distance ($d$) between them:</p>
            <div class="math-highlight">$$ C = \\epsilon \\frac{A}{d} $$</div>
            <p>To maximize $C$, we need a massive area, but we must fit it into a tiny electronic device.</p>`,
                controls: `<div class="control-header"><span>Status</span><span class="control-val">Flat Plates</span></div>`,
                onEnter: () => { simState.targetRoll = 0; }
            },
            {
                title: "Spatial Constraints",
                content: `<div class="chapter-marker">The Problem</div><h2>Infinite Length</h2>
            <p>Stretching these plates to increase Area would make the capacitor meters long. This is impractical for a circuit board.</p>`,
                controls: `<div class="control-header"><span>Status</span><span class="control-val">Flat Ribbon</span></div>`,
                onEnter: () => { simState.targetRoll = 0.0; }
            },
            {
                title: "The Solution",
                content: `<div class="chapter-marker">The Transformation</div><h2>The Radial Wrap</h2>
            <p>We roll the "sandwich" into a <b>spiral cylinder</b>.</p>
            <p>Notice how the layers wrap without touching. This geometric trick allows us to pack several square meters of foil into a tiny can.</p>`,
                controls: `<div class="control-header"><span>Status</span><span class="control-val">Rolling...</span></div>`,
                onEnter: () => { simState.targetRoll = 1.0; }
            },
            {
                title: "Conclusion",
                content: `<div class="chapter-marker">Engineering</div><h2>The Jelly Roll</h2>
            <p>This is the "Jelly Roll" construction found inside almost every electrolytic capacitor.</p>
            <p>The cylinder is then sealed in an aluminum casing, creating the familiar electronic component we see today.</p>`,
                controls: `<div class="control-header"><span>Status</span><span class="control-val">Complete Cylinder</span></div>`,
                onEnter: () => {
                    simState.targetRoll = 1.0;
                    document.getElementById('btn-next').innerText = "Next Lesson";
                    document.getElementById('btn-next').disabled = false;
                }
            }
        ];

        let currentStep = 0;
        function loadStep(idx) {
            currentStep = idx;
            const s = steps[idx];
            const area = document.getElementById('content-area');
            area.innerHTML = s.content;
            renderMathInElement(area, { delimiters: [{ left: "$$", right: "$$", display: true }, { left: "$", right: "$", display: false }] });

            document.getElementById('dynamic-controls').innerHTML = s.controls;
            document.querySelector('.btn-back').style.opacity = idx === 0 ? "0.3" : "1";
            document.querySelector('.btn-back').disabled = idx === 0;

            const btn = document.getElementById('btn-next');
            if (currentStep === steps.length - 1) {
                btn.innerHTML = "Next Lesson";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next";
                btn.disabled = false;
            }

            if (s.onEnter) s.onEnter();
        }

        window.nextStep = () => {
            if (currentStep < steps.length - 1) {
                loadStep(currentStep + 1);
            } else {
                window.parent.location.href = '/lesson/chapter6/flash';
            }
        };

        window.prevStep = () => {
            if (currentStep > 0) loadStep(currentStep - 1);
        };

        window.addEventListener('load', () => loadStep(0));

    </script>
</body>

</html>