<!DOCTYPE html>
<html>

<head>
    <title>Capacitor Lesson - Interactive Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #151515;
            font-family: 'Segoe UI', sans-serif;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        /* --- Interface Layout (Orange/Dark Theme) --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            --border: #333;
        }

        .interface-sidebar {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
            color: var(--text);
        }

        .interface-sidebar header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        .interface-sidebar h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .interface-sidebar .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        .story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .highlight {
            color: var(--accent);
        }

        .nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            text-transform: uppercase;
            font-weight: bold;
            transition: background 0.2s;
        }

        .nav-btn:hover {
            background: #444;
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .nav-btn.next {
            background: var(--accent);
            color: #151515;
        }

        .nav-btn.next:hover {
            background: #e08e3d;
        }

        /* Info Panel Overlay */
        #info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 220px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.8);
            border-radius: 5px;
            color: white;
            z-index: 5;
            pointer-events: none;
            /* Let clicks pass through to canvas if not on text */
            display: none;
        }

        #info-panel h3 {
            margin: 0 0 10px 0;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
            color: var(--accent);
        }

        #info-panel p {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 14px;
            color: #ccc;
        }

        #info-panel span {
            color: #fff;
            font-weight: bold;
        }

        /* Sim Container */
        .sim-container {
            position: absolute;
            top: 0;
            left: 420px;
            right: 0;
            bottom: 0;
            background: #151515;
        }
    </style>

    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/geometries/TextGeometry.js"></script>
</head>

<body>

    <!-- Sidebar Interface -->
    <div class="interface-sidebar">
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Chapter 6: The Flash Circuit</div>
        </header>

        <div class="story-container">
            <div class="chapter-title" id="story-title">Step 1: Introduction</div>
            <div class="story-text" id="story-content">
                <!-- Text injected via JS -->
            </div>
        </div>

        <div class="nav-footer">
            <button class="nav-btn" id="btn-back" onclick="changeStep(-1)">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="changeStep(1)">Next &rarr;</button>
        </div>
    </div>

    <!-- Simulation Area -->
    <div class="sim-container">
        <!-- Info Panel (Floating) -->
        <div id="info-panel">
            <h3 id="info-title">Component</h3>
            <div id="dynamic-info"></div>
        </div>
    </div>

    <script>
        // --- STORY DATA ---
        const STORY_STEPS = [
            {
                title: "Step 1: Introduction (The Setup)",
                text: `Class, look at the screen. We are going to apply what we just learned about Electric Fields.<br><br>
            On the left, we have a <strong>Battery</strong>. Don't think of it as a power source yet—think of it as an 'Electron Pump.' It creates a constant pressure (potential) to push charges.<br><br>
            In the middle, that blue cylinder? That is our <strong>Capacitor</strong>.<br>
            Inside that cylinder are two metal plates effectively separated by a gap. Electrons cannot jump across that gap.<br><br>
            On the right, we have a <strong>Lamp</strong>. Ideally, it needs moving charges to light up.`
            },
            {
                title: "Step 2: Charging",
                text: `Now, watch closely. Toggle the <strong>Left Switch</strong> to connect the pump (Battery) to the Capacitor.<br><br>
            <span class="highlight">Click the Left Switch to turn it ON (Close it).</span><br><br>
            Current flows, but stop and think—it doesn't flow <em>through</em> the capacitor.
            Instead, the battery is ripping electrons off one plate and shoving them onto the other.<br><br>
            Positive charges are building up on the left plate; negative charges are piling up on the right plate.<br>
            What is happening inside that gap? <strong>An Electric Field is building up.</strong><br><br>
            We are storing energy—not in the wires, but in the stress of that field holding those opposite charges apart.`
            },
            {
                title: "Step 3: The Disconnect",
                text: `Now, open the switch. The battery is gone.<br><br>
            <span class="highlight">Click the Left Switch again to turn it OFF (Open it).</span><br><br>
            Is the energy gone? <strong>No.</strong><br><br>
            The electrons on the negative plate are trapped. They desperately want to get back to the positive plate to neutralize, but they can't jump the gap. The electric field is still there, holding that energy, waiting for a path.`
            },
            {
                title: "Step 4: Discharging",
                text: `Now, we give them a path. Connect the Capacitor to the Lamp.<br><br>
            <span class="highlight">Click the Right Switch to turn it ON.</span><br><br>
            <strong>Boom! Light!</strong><br><br>
            Why? The electrons rush from the negative plate, through the wire, through the filament of the bulb, creating heat and light, to get back to the positive plate.<br><br>
            But watch... the light is getting dimmer... and dimmer...<br>
            Why? As the charges neutralize, the separation decreases. The Electric Field gets weaker. The 'push' gets softer.<br>
            Eventually, the plates are neutral again. The field is gone. The energy is spent.`
            },
            {
                title: "Conclusion",
                text: `So, a <strong>Capacitor</strong> isn't a battery. It doesn't create energy.<br><br> 
            It’s a bucket. We poured the electric field in, stored it, and then poured it out through the lamp.<br><br>
            <em>Feel free to experiment with the switches to repeat the cycle.</em>`
            }
        ];

        let currentStepIndex = 0;

        function renderStory() {
            const step = STORY_STEPS[currentStepIndex];
            document.getElementById('story-title').innerText = step.title;
            document.getElementById('story-content').innerHTML = step.text;

            document.getElementById('btn-back').disabled = (currentStepIndex === 0);

            const btn = document.getElementById('btn-next');
            if (currentStepIndex === STORY_STEPS.length - 1) {
                btn.innerHTML = "Next Lesson";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = false;
            }
        }

        function changeStep(delta) {
            if (currentStepIndex + delta >= 0 && currentStepIndex + delta < STORY_STEPS.length) {
                currentStepIndex += delta;
                renderStory();
            } else if (currentStepIndex + delta >= STORY_STEPS.length) {
                window.top.location.href = '/theapplefalls/lesson/chapter6/combined';
            }
        }

        // Initialize Story
        renderStory();

        // --- SIMULATION DATA (Battery -> Switch -> Cap -> Switch -> Lamp) ---
        window.STANDALONE_DATA = {
            "components": [
                { "id": 0, "type": "battery", "position": { "x": -12, "y": 0, "z": 0 }, "isOn": true },
                { "id": 1, "type": "switch", "position": { "x": -6, "y": 0, "z": -4 }, "isOn": false }, // Charge Switch
                { "id": 2, "type": "capacitor", "position": { "x": 0, "y": 0, "z": 0 }, "isOn": true },
                { "id": 3, "type": "switch", "position": { "x": 6, "y": 0, "z": -4 }, "isOn": false }, // Discharge Switch
                { "id": 4, "type": "bulb", "position": { "x": 12, "y": 0, "z": 0 }, "isOn": true }
            ],
            "wires": [
                { "start": { "componentId": 0, "nodeIndex": 0 }, "end": { "componentId": 1, "nodeIndex": 0 }, "controlPoints": [{ "x": -12, "y": 3, "z": -4 }] },
                { "start": { "componentId": 1, "nodeIndex": 1 }, "end": { "componentId": 2, "nodeIndex": 0 }, "controlPoints": [{ "x": 0, "y": 3, "z": -4 }] },
                { "start": { "componentId": 2, "nodeIndex": 1 }, "end": { "componentId": 0, "nodeIndex": 1 }, "controlPoints": [{ "x": -6, "y": 0, "z": 4 }] },
                { "start": { "componentId": 2, "nodeIndex": 0 }, "end": { "componentId": 3, "nodeIndex": 0 }, "controlPoints": [{ "x": 0, "y": 4, "z": -4 }] },
                { "start": { "componentId": 3, "nodeIndex": 1 }, "end": { "componentId": 4, "nodeIndex": 0 }, "controlPoints": [{ "x": 12, "y": 3, "z": -4 }] },
                { "start": { "componentId": 4, "nodeIndex": 1 }, "end": { "componentId": 2, "nodeIndex": 1 }, "controlPoints": [{ "x": 6, "y": 0, "z": 4 }] }
            ]
        };

        // --- 3D SIMULATION ENGINE ---
        const scene = new THREE.Scene();
        const simContainer = document.querySelector('.sim-container');
        const width = simContainer.clientWidth;
        const height = simContainer.clientHeight;

        const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
        camera.position.set(0, 25, 30); // Overhead View

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        simContainer.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 0, 0);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        const gridHelper = new THREE.GridHelper(50, 50, 0x333333, 0x222222);
        scene.add(gridHelper);

        let components = [], wires = [];
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedComponent = null;

        const nodeMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, visible: false });

        function createComponent(data) {
            const mesh = new THREE.Group();
            mesh.position.set(data.position.x, data.position.y, data.position.z);

            let compObj = {
                id: data.id,
                type: data.type,
                mesh: mesh,
                nodes: [],
                isOn: data.isOn,
                voltage: 0,
                charge: 0,
                capacitance: 0.1,
                isPowered: false,
                polarityDirection: 1
            };

            if (data.type === 'battery') {
                compObj.voltage = 9.0;
                const body = new THREE.Mesh(new THREE.BoxGeometry(2, 3, 2), new THREE.MeshStandardMaterial({ color: 0x333333 }));
                body.position.y = 1.5;
                const t1 = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.5), new THREE.MeshStandardMaterial({ color: 0xcccccc }));
                t1.position.set(0, 3.25, 0);
                mesh.add(body, t1);
                addLabel(mesh, "+", new THREE.Vector3(0, 2, 1.1), 0xffffff);
                addNode(compObj, new THREE.Vector3(0, 3.5, 0));
                addNode(compObj, new THREE.Vector3(0, 0, 0));
            }
            else if (data.type === 'capacitor') {
                const body = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 3, 32), new THREE.MeshStandardMaterial({ color: 0x0077be }));
                body.position.y = 1.5;
                mesh.add(body);
                addLabel(mesh, "1.0F", new THREE.Vector3(0, 1.5, 1.6), 0xffffff);
                addNode(compObj, new THREE.Vector3(0, 3, 0));
                addNode(compObj, new THREE.Vector3(0, 0, 0));
            }
            else if (data.type === 'bulb') {
                const base = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.5), new THREE.MeshStandardMaterial({ color: 0x555555 }));
                base.position.y = 0.25;
                const glass = new THREE.Mesh(new THREE.SphereGeometry(1.2, 32, 32), new THREE.MeshStandardMaterial({ color: 0x444444, transparent: true, opacity: 0.8 }));
                glass.position.y = 1.2;
                glass.name = 'glass';
                mesh.add(base, glass);
                addNode(compObj, new THREE.Vector3(0, 0, 0));
                addNode(compObj, new THREE.Vector3(0, 2.4, 0));
            }
            else if (data.type === 'switch') {
                const base = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 2), new THREE.MeshStandardMaterial({ color: 0x444444 }));
                const lever = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 0.5), new THREE.MeshStandardMaterial({ color: 0xff9f43 }));

                // --- FIX: Initial Visual State ---
                // If ON (Closed): Lever is Flat (Rot 0), Low (0.2)
                // If OFF (Open): Lever is Tilted (Rot PI/6), High (1.0)
                if (compObj.isOn) {
                    lever.rotation.z = 0;
                    lever.position.set(0, 0.2, 0);
                } else {
                    lever.rotation.z = Math.PI / 6;
                    lever.position.set(0, 1.0, 0);
                }

                lever.name = 'lever';
                mesh.add(base, lever);
                addNode(compObj, new THREE.Vector3(-1.4, 0, 0));
                addNode(compObj, new THREE.Vector3(1.4, 0, 0));
            }

            mesh.userData = compObj;
            scene.add(mesh);
            components.push(compObj);
            return compObj;
        }

        function addNode(comp, loc) {
            const n = new THREE.Mesh(new THREE.SphereGeometry(0.2), nodeMat);
            n.position.copy(loc);
            n.userData = { component: comp };
            comp.mesh.add(n);
            comp.nodes.push(n);
        }

        function addLabel(parent, text, pos, color) {
            const loader = new THREE.FontLoader();
            loader.load('https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                const geo = new THREE.TextGeometry(text, { font: font, size: 0.6, height: 0.1 });
                geo.center();
                const mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: color }));
                mesh.position.copy(pos);
                parent.add(mesh);
            });
        }

        function createWire(d) {
            const c1 = components.find(c => c.id === d.start.componentId);
            const c2 = components.find(c => c.id === d.end.componentId);
            if (!c1 || !c2) return;
            const n1 = c1.nodes[d.start.nodeIndex];
            const n2 = c2.nodes[d.end.nodeIndex];

            const pathPoints = [
                n1.getWorldPosition(new THREE.Vector3()),
                ...d.controlPoints.map(p => new THREE.Vector3(p.x, p.y, p.z)),
                n2.getWorldPosition(new THREE.Vector3())
            ];

            const curve = new THREE.CatmullRomCurve3(pathPoints);
            const geo = new THREE.TubeGeometry(curve, 20, 0.1, 8, false);
            const mat = new THREE.MeshStandardMaterial({ color: 0xb87333 });
            const mesh = new THREE.Mesh(geo, mat);

            scene.add(mesh);
            wires.push({ startNode: n1, endNode: n2, mesh: mesh });
        }

        const data = window.STANDALONE_DATA;
        data.components.forEach(createComponent);
        setTimeout(() => { data.wires.forEach(createWire); }, 100);

        // --- INTERACTION ---
        function onMouseDown(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            const hit = intersects.find(i => i.object.parent && i.object.parent.userData && i.object.parent.userData.id !== undefined);

            if (hit) {
                const comp = hit.object.parent.userData;
                selectedComponent = comp;
                updateInfoPanel(comp);

                if (comp.type === 'switch') {
                    comp.isOn = !comp.isOn;
                    // --- FIX: Animation Logic ---
                    // If ON (Closed): Lever goes Flat (Rot 0)
                    // If OFF (Open): Lever goes Tilted (Rot PI/6)
                    const lever = comp.mesh.getObjectByName('lever');
                    lever.rotation.z = comp.isOn ? 0 : Math.PI / 6;
                    lever.position.y = comp.isOn ? 0.2 : 1.0;
                }
            } else {
                selectedComponent = null;
                document.getElementById('info-panel').style.display = 'none';
            }
        }

        function updateInfoPanel(comp) {
            const panel = document.getElementById('info-panel');
            const content = document.getElementById('dynamic-info');
            const title = document.getElementById('info-title');

            if (!comp) { panel.style.display = 'none'; return; }

            panel.style.display = 'block';
            title.innerText = comp.type.toUpperCase();

            let html = '';
            if (comp.type === 'battery') {
                html += `<p>Voltage <span>${comp.voltage.toFixed(1)} V</span></p>`;
            } else if (comp.type === 'capacitor') {
                html += `<p>Charge <span>${comp.charge.toFixed(3)} C</span></p>`;
                html += `<p>Voltage <span>${comp.voltage.toFixed(2)} V</span></p>`;
                html += `<p>Status <span>${comp.isPowered ? 'Active' : 'Idle'}</span></p>`;
            } else if (comp.type === 'bulb') {
                html += `<p>Status <span>${comp.isPowered ? 'ON' : 'OFF'}</span></p>`;
            } else if (comp.type === 'switch') {
                html += `<p>State <span>${comp.isOn ? 'CLOSED (On)' : 'OPEN (Off)'}</span></p>`;
            }
            content.innerHTML = html;
        }

        renderer.domElement.addEventListener('pointerdown', onMouseDown);

        // --- SIMULATION LOGIC ---
        function simulate(dt) {
            const bat = components.find(c => c.id === 0);
            const swCharge = components.find(c => c.id === 1);
            const cap = components.find(c => c.id === 2);
            const swDischarge = components.find(c => c.id === 3);
            const bulb = components.find(c => c.id === 4);

            let isCharging = false;
            if (swCharge.isOn) isCharging = true;

            if (isCharging) {
                let chargeRate = (bat.voltage - cap.voltage) * 2.0;
                if (chargeRate < 0) chargeRate = 0;
                cap.charge = Math.min(cap.charge + chargeRate * dt, cap.capacitance * bat.voltage);
            }

            let isDischarging = false;
            if (swDischarge.isOn) isDischarging = true;

            bulb.isPowered = false;

            if (isDischarging && cap.voltage > 0.1) {
                let R = 10;
                let current = cap.voltage / R;
                cap.charge = Math.max(0, cap.charge - current * dt);

                bulb.isPowered = true;
                let brightness = Math.min(current / 0.5, 1.0);
                bulb.mesh.getObjectByName('glass').material.emissive.setHex(0xffaa00);
                bulb.mesh.getObjectByName('glass').material.emissiveIntensity = brightness;
            } else {
                bulb.mesh.getObjectByName('glass').material.emissive.setHex(0x000000);
            }

            cap.voltage = cap.charge / cap.capacitance;
            cap.isPowered = (Math.abs(cap.charge) > 0.01);

            if (selectedComponent) updateInfoPanel(selectedComponent);
        }

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            simulate(dt);
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            const w = simContainer.clientWidth;
            const h = simContainer.clientHeight;
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
        });

        animate();
    </script>
</body>

</html>