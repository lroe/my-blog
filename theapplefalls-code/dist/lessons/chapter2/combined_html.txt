

===== START OF 10_dipole.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Maxwell's Notebook: The Polarized Stream</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        /* CONTROLS AREA */
        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
            height: 6px;
            background: #333;
            border-radius: 3px;
        }

        /* NAVIGATION FOOTER */
        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        /* NEXT BUTTON STYLING FIX */
        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            border: none;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
            transform: none;
            animation: none;
        }

        /* MAIN CANVAS */
        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }

        .readout {
            float: right;
            color: var(--accent);
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Simulation: Electro-Hydrodynamics</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- 1. Gravity / Flow -->
            <div class="control-row" id="ctrl-flow">
                <label>Step 1: The Medium</label>
                <button id="btn-flow" onclick="toggleWater()">Open Valve</button>
            </div>

            <!-- 2. Static Charge -->
            <div class="control-row" id="ctrl-charge">
                <label>Step 2: Charge Density (Q)</label>
                <input type="range" id="slider-charge" min="0" max="100" value="0">
            </div>

            <!-- 3. Oscillation -->
            <div class="control-row" id="ctrl-freq">
                <label>Step 3: Polarity Switch <span class="readout" id="freq-val">0 Hz</span></label>
                <input type="range" id="slider-freq" min="0" max="20" value="0" step="0.1">
            </div>

            <!-- Reset -->
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Experiment Control</label>
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Lab Frame</div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const state = {
            waterFlowing: false,
            charge: 0,
            frequency: 0,
            time: 0
        };

        const scene = new THREE.Scene();

        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 45;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );

        camera.position.set(30, 30, 30);
        camera.lookAt(0, -5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('world').appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // --- GROUND & FLOOR ---
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({
            color: 0x222222, roughness: 0.9, metalness: 0.1
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -15;
        floor.receiveShadow = true;
        scene.add(floor);
        scene.background = new THREE.Color(0x151515);

        // Grid (Visual Guide for the Ground)
        const gridHelper = new THREE.GridHelper(100, 20, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -14.9;
        scene.add(gridHelper);

        // Common Material
        const metalMat = new THREE.MeshStandardMaterial({ color: 0x555, roughness: 0.3, metalness: 0.8 });

        // --- OBJECTS ---

        // 1. Van de Graaff Generator (The Source)
        const machineGroup = new THREE.Group();

        // Base
        const baseGeo = new THREE.BoxGeometry(6, 2, 6);
        const base = new THREE.Mesh(baseGeo, metalMat);
        base.position.y = -14;
        base.castShadow = true;

        // Column
        const colGeo = new THREE.CylinderGeometry(1, 1, 15, 16);
        const plasticMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.2, transparent: true, opacity: 0.4 });
        const col = new THREE.Mesh(colGeo, plasticMat);
        col.position.y = -6.5;

        // Dome
        const domeGeo = new THREE.IcosahedronGeometry(4, 2);
        const domeMat = new THREE.MeshStandardMaterial({ color: 0xcdcfd1, roughness: 0.1, metalness: 1.0 });
        const dome = new THREE.Mesh(domeGeo, domeMat);
        dome.position.y = 1;
        dome.castShadow = true;

        // Sparks (Visual feedback for charge)
        const glowGeo = new THREE.IcosahedronGeometry(4.2, 1);
        const glowMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.0, wireframe: true });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        dome.add(glow);

        machineGroup.add(base, col, dome);
        machineGroup.position.set(10, 0, 0);
        scene.add(machineGroup);

        // 2. The Faucet Assembly (Modified to include Ground Support)
        const faucetGroup = new THREE.Group();

        // Horizontal Arm
        const pipeGeo = new THREE.CylinderGeometry(0.5, 0.5, 10, 8);
        pipeGeo.rotateZ(Math.PI / 2);
        const pipe = new THREE.Mesh(pipeGeo, metalMat);
        pipe.position.set(-8, 12, 0);
        pipe.castShadow = true;

        // Nozzle (Water comes out here)
        const nozzleGeo = new THREE.CylinderGeometry(0.5, 0.8, 2, 8);
        const nozzle = new THREE.Mesh(nozzleGeo, metalMat);
        nozzle.position.set(-3, 11, 0);
        nozzle.castShadow = true;

        // NEW: Vertical Supply Pipe (Attached to Ground)
        const supplyHeight = 26; // Distance from y=12 down to y=-14
        const supplyGeo = new THREE.CylinderGeometry(0.6, 0.6, supplyHeight, 8);
        const supplyPipe = new THREE.Mesh(supplyGeo, metalMat);
        // Position x=-12 (back of horizontal pipe), y centered between 12 and -14
        supplyPipe.position.set(-12, -1, 0);
        supplyPipe.castShadow = true;
        supplyPipe.receiveShadow = true;

        // NEW: Pipe Base (Concrete block on the floor)
        const pipeBaseGeo = new THREE.BoxGeometry(4, 1.5, 4);
        const pipeBase = new THREE.Mesh(pipeBaseGeo, metalMat);
        pipeBase.position.set(-12, -14.25, 0); // Resting on the floor at y=-15
        pipeBase.receiveShadow = true;

        // NEW: Elbow Connector (Top left join)
        const elbowGeo = new THREE.SphereGeometry(0.8, 16, 16);
        const elbow = new THREE.Mesh(elbowGeo, metalMat);
        elbow.position.set(-12, 12, 0);

        faucetGroup.add(pipe, nozzle, supplyPipe, pipeBase, elbow);
        scene.add(faucetGroup);

        // 3. Water Particle System
        const particleCount = 400;
        const waterGeo = new THREE.IcosahedronGeometry(0.3, 0);
        const waterMat = new THREE.MeshPhongMaterial({
            color: 0x00d2d3,
            emissive: 0x004444,
            specular: 0xffffff,
            shininess: 100,
            flatShading: true
        });

        const particles = [];
        const gravity = -0.15;

        for (let i = 0; i < particleCount; i++) {
            const mesh = new THREE.Mesh(waterGeo, waterMat);
            mesh.visible = false;
            mesh.userData = {
                active: false,
                velocity: new THREE.Vector3(),
                life: 0
            };
            scene.add(mesh);
            particles.push(mesh);
        }

        // Collection Basin (Where water lands)
        const basinGeo = new THREE.CylinderGeometry(4, 3, 2, 16);
        const basinMat = new THREE.MeshStandardMaterial({ color: 0x333, side: THREE.DoubleSide });
        const basin = new THREE.Mesh(basinGeo, basinMat);
        basin.position.set(-3, -14, 0);
        basin.receiveShadow = true;
        scene.add(basin);


        // ==========================================
        // PART 2: PHYSICS ENGINE
        // ==========================================

        function spawnParticle() {
            const p = particles.find(p => !p.userData.active);
            if (p) {
                p.userData.active = true;
                p.position.set(-3, 10, 0); // Start at nozzle
                p.userData.velocity.set(
                    (Math.random() - 0.5) * 0.05,
                    -0.1,
                    (Math.random() - 0.5) * 0.05
                );
                p.userData.life = 0;
                p.visible = true;
            }
        }

        function updatePhysics() {
            const domePos = new THREE.Vector3(10, 1, 0);
            let currentCharge = state.charge;

            if (state.frequency > 0) {
                currentCharge = state.charge * Math.cos(state.time * state.frequency);
            }

            glow.material.opacity = Math.abs(currentCharge) / 200;
            glow.scale.setScalar(1 + Math.abs(currentCharge) / 300);

            particles.forEach(p => {
                if (!p.userData.active) return;

                p.userData.velocity.y += gravity * 0.05;

                const dist = p.position.distanceTo(domePos);

                if (currentCharge !== 0) {
                    const dir = new THREE.Vector3().subVectors(domePos, p.position).normalize();

                    let forceMag = (Math.abs(currentCharge) * 1.5) / (dist * dist);
                    if (currentCharge < 0) forceMag *= -0.5;

                    if (Math.abs(state.charge) > 80) {
                        p.userData.velocity.x += (Math.random() - 0.5) * 0.02;
                        p.userData.velocity.z += (Math.random() - 0.5) * 0.02;
                    }

                    p.userData.velocity.add(dir.multiplyScalar(forceMag * 0.05));
                }

                p.position.add(p.userData.velocity);

                if (p.position.y < -14) {
                    p.userData.active = false;
                    p.visible = false;
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.05;

            if (state.waterFlowing) {
                spawnParticle();
                spawnParticle();
            }

            updatePhysics();
            renderer.render(scene, camera);
        }
        animate();

        // ==========================================
        // PART 3: NARRATIVE CONTROLLER
        // ==========================================

        let currentChapter = 0;

        document.getElementById('slider-charge').addEventListener('input', (e) => {
            state.charge = parseFloat(e.target.value);
            checkAdvance();
        });

        document.getElementById('slider-freq').addEventListener('input', (e) => {
            state.frequency = parseFloat(e.target.value);
            document.getElementById('freq-val').innerText = state.frequency + " Hz";
            checkAdvance();
        });

        function toggleWater() {
            state.waterFlowing = !state.waterFlowing;
            const btn = document.getElementById('btn-flow');
            btn.innerText = state.waterFlowing ? "Close Valve" : "Open Valve";
            checkAdvance();
        }

        function resetSim() {
            state.waterFlowing = false;
            state.charge = 0;
            state.frequency = 0;

            document.getElementById('slider-charge').value = 0;
            document.getElementById('slider-freq').value = 0;
            document.getElementById('freq-val').innerText = "0 Hz";
            document.getElementById('btn-flow').innerText = "Open Valve";

            particles.forEach(p => { p.userData.active = false; p.visible = false; });

            loadLesson(0);
        }

        const lessons = [
            {
                title: "Principles: The Dipole",
                text: "Water (<strong style='color:#00d2d3'>Hâ‚‚O</strong>) is not just a liquid; it is a collection of magnetic-like magnets called <strong>dipoles</strong>. The oxygen atom hogs electrons, making one side negative, while the hydrogens remain positive.<br><br>Right now, gravity is the only force acting on the stream. It falls straight down.<br><br><span class='instruction-inline'>Click 'OPEN VALVE'</span> to establish the baseline stream.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-flow');
                },
                check: () => state.waterFlowing
            },
            {
                title: "The Electric Field Gradient",
                text: "We have a Van de Graaff generator nearby. When charged, it creates a non-uniform <strong>Electric Field (E)</strong>.<br><br>Because the field is stronger near the dome, the attractive force on the water's dipoles is stronger than the repulsive force. This creates a <strong>Net Force</strong> towards the sphere.<br><br><span class='instruction-inline'>Increase Charge (Q)</span> to about 50% to see the stream bend.",
                setup: () => {
                    unlock('ctrl-charge');
                },
                check: () => state.charge > 40
            },
            {
                title: "Supercharged: Induction & Chaos",
                text: "Bending is classic physics. Now let's supercharge it.<br><br>If we rapidly flip the polarity of the charge (AC), or create extreme charge density, two things happen:<br>1. <strong>Mechanical Oscillation:</strong> The stream tries to follow the changing field direction.<br>2. <strong>Rayleigh Instability:</strong> Repulsive forces inside the water overcome surface tension, causing the stream to spray or split.<br><br><span class='instruction-inline'>Increase Hz</span> to oscillate the field.",
                setup: () => {
                    unlock('ctrl-freq');
                },
                check: () => state.frequency > 5
            },
            {
                title: "Observation Log",
                text: "You are now manipulating matter without touching it.<br><br>At high frequencies, the water molecules cannot physically rotate fast enough to track the field perfectly, resulting in complex helix patterns or atomization (spraying).<br><br>Feel free to adjust Flow, Charge, and Frequency to create stable helices or chaotic storms. You have completed Chapter 2! You now understand the invisible forces that shape our world.",
                setup: () => {
                    // All open
                },
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Experiment Phase ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div>
             <div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');

            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }

            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                // End of module
                window.parent.location.href = '/';
            }
        }
        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }
        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        // Init
        loadLesson(0);

        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * newAspect / 2;
            camera.right = viewSize * newAspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

    </script>
</body>

</html>

===== END OF 10_dipole.html =====


===== START OF 2_vector.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Maxwell's Notebook: Vector Arrows</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
            --pos-color: #ff6b6b;
            --neg-color: #54a0ff;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        .math-block {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #333;
            color: #fff;
            text-align: center;
        }

        /* CONTROLS AREA */
        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
            height: 6px;
            background: #333;
            border-radius: 3px;
        }

        /* NAVIGATION FOOTER */
        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        /* NEXT BUTTON STYLING FIX */
        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            border: none;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
            transform: none;
            animation: none;
        }

        /* MAIN CANVAS */
        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Simulation: Vector Representation</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- 1. Polarity Toggle -->
            <div class="control-row" id="ctrl-polarity">
                <label>Step 1: Charge Nature</label>
                <button id="btn-polarity" onclick="togglePolarity()">Current: Positive (+)</button>
            </div>

            <!-- 2. Measurement Ring Slider -->
            <div class="control-row" id="ctrl-ring">
                <label>Step 2: Measurement Radius (r)</label>
                <input type="range" id="slider-dist" min="6" max="35" value="10" step="0.1">
            </div>

            <!-- 3. Show Grid -->
            <div class="control-row" id="ctrl-grid">
                <label>Step 3: The Vector Field</label>
                <button id="btn-grid" onclick="toggleFullGrid()">Toggle Full Field Map</button>
            </div>

            <!-- Reset -->
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>System</label>
                <button onclick="resetSim()">Reset Experiment</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Vector Visualization Mode</div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const state = {
            polarity: 1, // 1 for Positive, -1 for Negative
            radius: 10,
            showGrid: false,
            time: 0,
            gridAnimated: false
        };

        const scene = new THREE.Scene();

        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 50;

        // Orthographic Camera for that "Textbook Diagram" look
        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );

        camera.position.set(20, 35, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('world').appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // Floor (Dark Grid)
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({
            color: 0x222222,
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -5;
        floor.receiveShadow = true;
        scene.add(floor);
        scene.background = new THREE.Color(0x151515);

        const gridHelper = new THREE.GridHelper(100, 20, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -4.9;
        scene.add(gridHelper);

        // --- OBJECTS ---

        // 1. Central Charge
        const sourceGeo = new THREE.IcosahedronGeometry(3, 0); // Low poly
        const sourceMat = new THREE.MeshStandardMaterial({
            color: 0xff6b6b,
            flatShading: true,
            emissive: 0x550000,
            emissiveIntensity: 0.5
        });
        const sourceMesh = new THREE.Mesh(sourceGeo, sourceMat);
        sourceMesh.castShadow = true;
        sourceMesh.position.y = 0;
        scene.add(sourceMesh);

        // Charge Label Sprite
        function createTextSprite(text, scale) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 60px Arial';
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.fillText(text, 128, 80);
            const tex = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: tex, depthTest: false });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(scale * 2, scale, 1);
            sprite.renderOrder = 100;
            return sprite;
        }

        const labelQ = createTextSprite("Q (+)", 4);
        labelQ.position.y = 5;
        scene.add(labelQ);

        // 2. Arrow Factory
        const arrowShaftGeo = new THREE.CylinderGeometry(0.15, 0.15, 1, 6);
        arrowShaftGeo.translate(0, 0.5, 0);
        arrowShaftGeo.rotateZ(-Math.PI / 2); // Point +X

        const arrowHeadGeo = new THREE.ConeGeometry(0.4, 0.8, 6);
        arrowHeadGeo.rotateZ(-Math.PI / 2);
        arrowHeadGeo.translate(1, 0, 0);

        const arrowMat = new THREE.MeshStandardMaterial({ color: 0xe0e6ed, flatShading: true });

        function createArrow() {
            const grp = new THREE.Group();
            const shaft = new THREE.Mesh(arrowShaftGeo, arrowMat);
            const head = new THREE.Mesh(arrowHeadGeo, arrowMat);
            shaft.castShadow = true;
            head.castShadow = true;

            // We put the visuals in a child group so we can scale the arrow length 
            // without distorting the 'thickness' of the shaft too much if we wanted,
            // but for simple uniform scaling, this structure is fine.
            const visuals = new THREE.Group();
            visuals.add(shaft, head);
            grp.add(visuals);

            grp.userData = { visuals: visuals };
            return grp;
        }

        // 3. Measurement Ring Arrows (The active demonstration ring)
        const ringArrows = [];
        const ringGroup = new THREE.Group();
        const ringCount = 12;
        for (let i = 0; i < ringCount; i++) {
            const arrow = createArrow();
            ringGroup.add(arrow);
            ringArrows.push(arrow);
        }
        scene.add(ringGroup);

        // 4. Background Grid Arrows (The "Field Map")
        const gridArrows = [];
        const gridGroup = new THREE.Group();
        // Create a circular distribution of background arrows
        for (let r = 8; r <= 35; r += 5) {
            const count = Math.floor(r * 1.5);
            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2 + (r % 2); // Offset rings slightly
                const arrow = createArrow();
                arrow.position.set(Math.cos(angle) * r, 0, Math.sin(angle) * r);

                // Set slight transparency for background arrows
                arrow.userData.visuals.children.forEach(m => {
                    m.material = m.material.clone();
                    m.material.transparent = true;
                    m.material.opacity = 0.3;
                });

                gridGroup.add(arrow);
                gridArrows.push(arrow);
            }
        }
        scene.add(gridGroup);
        gridGroup.visible = false;


        // ==========================================
        // PART 2: LOGIC & ANIMATION
        // ==========================================

        function updateArrows() {
            const center = new THREE.Vector3(0, 0, 0);
            const axisX = new THREE.Vector3(1, 0, 0);

            // 1. Update Measurement Ring
            const r = state.radius;
            // Inverse square calculation for scale. 
            // Max strength at r=5, min at r=40.
            // E ~ 1/r^2. Let's make scale roughly 100/r^2
            let scale = 250 / (r * r);
            scale = Math.min(scale, 8); // Cap max size
            scale = Math.max(scale, 1); // Cap min size

            for (let i = 0; i < ringCount; i++) {
                const angle = (i / ringCount) * Math.PI * 2 + (state.time * 0.1);
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                const arrow = ringArrows[i];

                arrow.position.set(x, 0, z);

                // Direction Logic
                const dir = new THREE.Vector3(x, 0, z).normalize();
                if (state.polarity === -1) dir.negate(); // Point inward if negative

                const quat = new THREE.Quaternion().setFromUnitVectors(axisX, dir);
                arrow.quaternion.copy(quat);

                arrow.userData.visuals.scale.set(scale, 1, 1);
            }

            // 2. Update Background Grid (if visible)
            if (state.showGrid) {
                gridArrows.forEach(arrow => {
                    const dist = arrow.position.distanceTo(center);
                    let gScale = 250 / (dist * dist);
                    gScale = Math.min(gScale, 5);
                    gScale = Math.max(gScale, 0.5);

                    const dir = arrow.position.clone().normalize();
                    if (state.polarity === -1) dir.negate();

                    const quat = new THREE.Quaternion().setFromUnitVectors(axisX, dir);
                    arrow.quaternion.slerp(quat, 0.1); // Smooth transition when polarity changes

                    arrow.userData.visuals.scale.set(gScale, 1, 1);
                });
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.01;

            // Bobbing Source
            sourceMesh.position.y = Math.sin(state.time * 2) * 0.3;
            sourceMesh.rotation.y += 0.005;
            sourceMesh.rotation.z -= 0.002;
            labelQ.position.y = 5 + Math.sin(state.time * 2) * 0.3;

            updateArrows();
            renderer.render(scene, camera);
        }
        animate();

        // ==========================================
        // PART 3: INTERACTION
        // ==========================================

        let currentChapter = 0;

        function togglePolarity() {
            state.polarity *= -1;
            const btn = document.getElementById('btn-polarity');

            if (state.polarity === 1) {
                btn.innerText = "Current: Positive (+)";
                btn.style.borderColor = "#3d4450";
                btn.style.color = "#aaa";
                sourceMat.color.setHex(0xff6b6b);
                sourceMat.emissive.setHex(0x550000);

                // Update Label
                const canvas = labelQ.material.map.image;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, 256, 128);
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.fillText("Q (+)", 128, 80);
                labelQ.material.map.needsUpdate = true;

            } else {
                btn.innerText = "Current: Negative (-)";
                btn.style.borderColor = "#54a0ff";
                btn.style.color = "#54a0ff";
                sourceMat.color.setHex(0x54a0ff);
                sourceMat.emissive.setHex(0x002255);

                // Update Label
                const canvas = labelQ.material.map.image;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, 256, 128);
                ctx.fillStyle = "#54a0ff"; // make text blueish
                ctx.textAlign = "center";
                ctx.fillText("Q (-)", 128, 80);
                labelQ.material.map.needsUpdate = true;
            }
            checkAdvance();
        }

        document.getElementById('slider-dist').addEventListener('input', (e) => {
            state.radius = parseFloat(e.target.value);
            checkAdvance();
        });

        function toggleFullGrid() {
            state.showGrid = !state.showGrid;
            const btn = document.getElementById('btn-grid');
            gridGroup.visible = state.showGrid;

            if (state.showGrid) {
                btn.innerText = "Hide Full Field Map";
                btn.style.background = "#2c313a";
                btn.style.color = "#fff";
            } else {
                btn.innerText = "Toggle Full Field Map";
                btn.style.background = "#2c313a";
                btn.style.color = "#aaa";
            }
            checkAdvance();
        }

        function resetSim() {
            state.polarity = -1; // Toggle function will flip it to 1
            togglePolarity();
            state.radius = 10;
            document.getElementById('slider-dist').value = 10;
            state.showGrid = true;
            toggleFullGrid(); // Will flip to false

            loadLesson(0);
        }

        // --- LESSON CONTENT ---

        const lessons = [
            {
                title: "Direction & Polarity",
                text: "Electric fields are vector fields. This means every point in space has a direction and a magnitude.<br><br><strong>Convention:</strong> Field arrows always point <em>away</em> from Positive charges and <em>toward</em> Negative charges.<br><br>The red sphere is our Positive source. <span class='instruction-inline'>Click 'CHARGE NATURE'</span> to swap it to a Negative source and observe the arrows.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-polarity');
                },
                check: () => state.polarity === -1 // User must have clicked at least once
            },
            {
                title: "Magnitude & Distance",
                text: "The <strong>Length</strong> of the arrow represents the strength (Magnitude) of the field at that specific point.<br><br>According to the inverse-square law ($1/r^2$), the field is very strong close to the source and fades rapidly as you move away.<br><br><span class='instruction-inline'>Move the Slider</span> to change the distance (r) of the measurement ring.",
                setup: () => {
                    unlock('ctrl-ring');
                },
                check: () => state.radius > 20 || state.radius < 8 // Moved slider significantly
            },
            {
                title: "The Vector Map",
                text: "So far, we have only looked at a specific ring. But the field exists everywhere simultaneously.<br><br>By drawing arrows at grid points, we create a <strong>Vector Field Map</strong>. This allows us to visualize the 'texture' of the space surrounding the charge.<br><br>Notice how the arrows are huge near the center and tiny at the edges.<span class='instruction-inline'>Click 'TOGGLE FULL FIELD MAP'</span>.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-grid');
                },
                check: () => state.showGrid
            },
            {
                title: "Analysis Complete",
                text: "You have visualized the two critical components of the Electric Field Vector:<br><br>1. <strong>Direction:</strong> Determined by the sign of the source charge (+/-).<br>2. <strong>Magnitude:</strong> Visualized by arrow length, governed by the $1/r^2$ law.<br><br>This 'porcupine' pattern is the classic signature of a point charge in empty space. But what happens when multiple charges interact? We need to learn how to add these vectors together.",
                setup: () => {
                    unlock('ctrl-polarity');
                    unlock('ctrl-ring');
                },
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div>
             <div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');

            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }

            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.parent.location.href = '/lesson/vec_addition';
            }
        }
        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }
        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        // Init
        loadLesson(0);

        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * newAspect / 2;
            camera.right = viewSize * newAspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

    </script>
</body>

</html>

===== END OF 2_vector.html =====


===== START OF 3_asymptotic_behaviorr.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>The Invisible Web: Asymptotes (Revised)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
            height: 6px;
            background: #333;
            border-radius: 3px;
        }

        .coord-display {
            float: right;
            color: var(--accent);
            font-family: monospace;
        }

        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        /* NEXT BUTTON STYLING FIX */
        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            border: none;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
            transform: none;
            animation: none;
        }

        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Sim: Asymptotic Behavior</div>
        </header>

        <div id="story-container">
            <div id="chapter-content"><!-- Content injected by JS --></div>
        </div>

        <div id="controls-area">
            <div class="control-row" id="ctrl-vis">
                <label>Step 1: Visualization</label>
                <button id="btn-vis" onclick="toggleFieldVectors()">Toggle Vector Field</button>
            </div>
            <div class="control-row" id="ctrl-probe">
                <label>Step 2: Probe Position <span id="val-disp" class="coord-display">x: 0.0</span></label>
                <!-- Extended range to ensure we hit the null point -->
                <input type="range" id="slider-dist" min="-20" max="60" value="0" step="0.1">
                <div style="display:flex; justify-content:space-between; font-size:10px; color:#555; margin-top:5px;">
                    <span>Left Field</span>
                    <span>Far Field &rarr;</span>
                </div>
            </div>
            <!-- Zoom Control Removed -->
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Experiment Control</label>
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Vacuum Space</div>
        <div id="null-point-alert"
            style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:#2ecc71; font-weight:bold; font-size:24px; text-shadow:0 0 10px #000; display:none; pointer-events:none;">
            E = 0 (NULL POINT)</div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const state = { fieldVisible: false, isZoomedOut: false, probeX: 0, time: 0 };
        const scene = new THREE.Scene();
        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        let viewSize = 60;

        const camera = new THREE.OrthographicCamera(-viewSize * aspect / 2, viewSize * aspect / 2, viewSize / 2, -viewSize / 2, 1, 1000);
        camera.position.set(20, 25, 20);
        camera.lookAt(10, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('world').appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Floor & Grid
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8, metalness: 0.2 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -10;
        floor.receiveShadow = true;
        scene.background = new THREE.Color(0x151515);
        const gridHelper = new THREE.GridHelper(300, 60, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -9.9;
        scene.add(floor);
        scene.add(gridHelper);

        // --- COORDINATE SYSTEM VISUALS ---
        function createCoordSystem() {
            const group = new THREE.Group();
            const material = new THREE.LineBasicMaterial({ color: 0x666666, transparent: true, opacity: 0.5 });
            const points = [new THREE.Vector3(-100, 0, 0), new THREE.Vector3(100, 0, 0)];
            const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), material);
            group.add(line);

            for (let x = -80; x <= 80; x += 10) {
                const tick = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(x, 0, -1), new THREE.Vector3(x, 0, 1)]), material);
                group.add(tick);
            }

            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#888'; ctx.font = 'bold 30px monospace';
            ctx.textAlign = 'center'; ctx.fillText('x=0', 64, 40);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true, opacity: 0.7 }));
            sprite.position.set(0, -3, 2);
            sprite.scale.set(4, 2, 1);
            group.add(sprite);
            return group;
        }
        scene.add(createCoordSystem());

        // Charge 1: +3 (Left)
        const q1Group = new THREE.Group();
        q1Group.add(new THREE.Mesh(new THREE.IcosahedronGeometry(3.5, 1), new THREE.MeshStandardMaterial({ color: 0xff6b6b, emissive: 0x550000 })));
        q1Group.position.set(-8, 0, 0);
        scene.add(q1Group);

        // Charge 2: -1 (Right)
        const q2Group = new THREE.Group();
        q2Group.add(new THREE.Mesh(new THREE.IcosahedronGeometry(2, 1), new THREE.MeshStandardMaterial({ color: 0x54a0ff, emissive: 0x002255 })));
        q2Group.position.set(8, 0, 0);
        scene.add(q2Group);

        function createTextSprite(text, color, scale) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 50px Arial';
            ctx.fillStyle = color;
            ctx.textAlign = "center";
            ctx.fillText(text, 128, 80);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
            sprite.scale.set(scale * 2, scale, 1);
            return sprite;
        }
        const labelQ1 = createTextSprite("+3Q", "#ff6b6b", 4); labelQ1.position.y = 5.5; q1Group.add(labelQ1);
        const labelQ2 = createTextSprite("-1Q", "#54a0ff", 3); labelQ2.position.y = 4; q2Group.add(labelQ2);

        // Probe
        const probeGroup = new THREE.Group();
        const probeMesh = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), new THREE.MeshBasicMaterial({ color: 0xfeca57 }));
        probeGroup.add(probeMesh);

        // Arrow Helper
        const arrowHelperGrp = new THREE.Group();
        const arrowShaft = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1, 8).translate(0, 0.5, 0).rotateZ(-Math.PI / 2), new THREE.MeshBasicMaterial({ color: 0xffffff }));
        const arrowHead = new THREE.Mesh(new THREE.ConeGeometry(0.25, 0.6, 8).rotateZ(-Math.PI / 2).translate(1, 0, 0), new THREE.MeshBasicMaterial({ color: 0xffffff }));
        arrowHelperGrp.add(arrowShaft, arrowHead);
        probeGroup.add(arrowHelperGrp);
        scene.add(probeGroup);

        // Field Vectors
        const fieldVectors = [];
        const vectorGroup = new THREE.Group();
        scene.add(vectorGroup);
        vectorGroup.visible = false;

        // Grid Generation
        for (let x = -60; x <= 100; x += 5) { // Extended to 100
            for (let z = -20; z <= 20; z += 5) {
                if (Math.abs(x + 8) < 3 && Math.abs(z) < 3) continue;
                if (Math.abs(x - 8) < 3 && Math.abs(z) < 3) continue;

                const vGroup = new THREE.Group();
                vGroup.position.set(x, 0, z);
                const s = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 1, 4).translate(0, 0.5, 0).rotateZ(-Math.PI / 2), new THREE.MeshBasicMaterial({ color: 0x666666, transparent: true }));
                const h = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.35, 4).rotateZ(-Math.PI / 2).translate(1, 0, 0), new THREE.MeshBasicMaterial({ color: 0x666666, transparent: true }));
                vGroup.add(s, h);
                vGroup.userData = { origin: new THREE.Vector3(x, 0, z) };
                vectorGroup.add(vGroup);
                fieldVectors.push(vGroup);
            }
        }

        // ==========================================
        // PART 2: PHYSICS & ANIMATION
        // ==========================================

        const Q1_VAL = 3000; // Left
        const Q2_VAL = -1000; // Right

        function calculateField(pos) {
            const e = new THREE.Vector3(0, 0, 0);
            const q1CurrentPos = q1Group.position.clone();
            const q2CurrentPos = q2Group.position.clone();

            const r1 = new THREE.Vector3().subVectors(pos, q1CurrentPos);
            const d1 = r1.length();
            if (d1 > 1) { r1.normalize(); e.add(r1.multiplyScalar(Q1_VAL / (d1 * d1))); }

            const r2 = new THREE.Vector3().subVectors(pos, q2CurrentPos);
            const d2 = r2.length();
            if (d2 > 1) { r2.normalize(); e.add(r2.multiplyScalar(Q2_VAL / (d2 * d2))); }
            return e;
        }

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.015;

            q1Group.position.y = Math.sin(state.time) * 0.3;
            q2Group.position.y = Math.sin(state.time + 1) * 0.2;

            probeGroup.position.set(state.probeX, 0, 0);

            // --- Calculate Physics ---
            const E_net = calculateField(probeGroup.position);
            const E_mag = E_net.length();

            // FIX: Visual Gain. We multiply magnitude by 5 for visualization 
            // because the far field is naturally weak but we need to see it.
            const visualMag = E_mag * 5.0;

            // Strict Null Point detection (~29.85)
            // We ensure we only hide the arrow in the EXACT dead zone.
            const isNullPoint = (E_mag < 0.1 && state.probeX > 28 && state.probeX < 32);

            const nullPointEl = document.getElementById('null-point-alert');
            if (isNullPoint) {
                nullPointEl.style.display = 'block';
                arrowHelperGrp.visible = false;
            } else {
                nullPointEl.style.display = 'none';
                arrowHelperGrp.visible = true;
            }

            if (!isNullPoint && E_mag > 0.00001) {
                const dir = E_net.clone();
                dir.y = 0; // Force flat on XZ plane
                dir.normalize();
                const axisX = new THREE.Vector3(1, 0, 0);
                const quat = new THREE.Quaternion().setFromUnitVectors(axisX, dir);
                arrowHelperGrp.setRotationFromQuaternion(quat);

                // Scale Arrow: Logarithmic using the Boosted Visual Mag
                // This ensures it stays visible even when the field is weak (0.3 etc)
                let scale = Math.log(visualMag + 1);
                scale = Math.max(scale, 0.6); // Minimum size clamp increased
                scale = Math.min(scale, 6);
                arrowHelperGrp.scale.set(scale, 1, 1);
            }

            // --- Background Vectors ---
            if (state.fieldVisible) {
                fieldVectors.forEach(v => {
                    const E = calculateField(v.userData.origin);
                    const mag = E.length();
                    const vVisualMag = mag * 4.0; // Boost background grid too

                    const dir = E.clone();
                    dir.y = 0; // Force flat
                    dir.normalize();
                    const axisX = new THREE.Vector3(1, 0, 0);
                    v.setRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(axisX, dir));

                    // Color mapping
                    const intensity = Math.min(mag / 10, 1);

                    // Scale mapping
                    let vScale = Math.min(Math.log(vVisualMag + 1), 2.5);
                    v.scale.set(vScale, 1, 1);

                    // Opacity: Ensure distant arrows remain visible
                    const op = 0.4 + (Math.min(mag, 1) * 0.6);

                    v.children.forEach(c => {
                        c.material.color.setHSL(0.6, 0.8, 0.3 + 0.5 * intensity);
                        c.material.opacity = op;
                    });
                });
            }

            // Camera Logic
            // Camera Logic
            const targetView = 60;
            viewSize += (targetView - viewSize) * 0.05;
            const currentAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * currentAspect / 2;
            camera.right = viewSize * currentAspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;

            const targetCamX = 10;
            camera.position.x += (targetCamX - camera.position.x) * 0.05;

            camera.updateProjectionMatrix();
            renderer.render(scene, camera);
        }
        animate();

        // ==========================================
        // PART 3: LOGIC & NARRATIVE
        // ==========================================

        let currentChapter = 0;

        function toggleFieldVectors() {
            state.fieldVisible = !state.fieldVisible;
            vectorGroup.visible = state.fieldVisible;
            document.getElementById('btn-vis').innerText = state.fieldVisible ? "Hide Field" : "Show Field";
            checkAdvance();
        }

        document.getElementById('slider-dist').addEventListener('input', (e) => {
            state.probeX = parseFloat(e.target.value);
            document.getElementById('val-disp').innerText = `x: ${state.probeX.toFixed(1)}`;
            checkAdvance();
        });

        // Zoom function removed

        function resetSim() {
            state.fieldVisible = false;
            state.isZoomedOut = false;
            state.probeX = 0;
            vectorGroup.visible = false;
            const slider = document.getElementById('slider-dist');
            slider.value = 0;
            slider.min = -20;
            slider.max = 60;
            document.getElementById('val-disp').innerText = "x: 0.0";
            document.getElementById('btn-vis').innerText = "Toggle Vector Field";
            // Zoom reset removed
            loadLesson(0);
        }

        const lessons = [
            {
                title: "Unequal Charges",
                text: "We have two charges on the axis. Left: <strong style='color:#ff6b6b'>+3Q</strong> at x=-8. Right: <strong style='color:#54a0ff'>-1Q</strong> at x=+8. <br><br>The visual grid helps us track position. Because the charges are unequal, the field pattern is asymmetrical.<br><br><span class='instruction-inline'>Click 'TOGGLE VECTOR FIELD'</span> to visualize the net force.",
                setup: () => { lockAll(); unlock('ctrl-vis'); state.isZoomedOut = false; state.probeX = 0; },
                check: () => state.fieldVisible
            },
            {
                title: "Between the Charges",
                text: "Look at the origin (x=0). Both charges push/pull a positive probe to the right (+3Q pushes, -1Q pulls).<br><br>Use the <strong>PROBE</strong> to explore. Notice how the direction (arrow) never flips between the charges.<br><br>Move the probe anywhere between x=-5 and x=5.",
                setup: () => { unlock('ctrl-probe'); },
                check: () => Math.abs(state.probeX) > 1 && Math.abs(state.probeX) < 7
            },
            {
                title: "The Null Point",
                text: "Since the Positive charge is stronger (+3 vs -1), it pushes its influence far to the right, overpowering the negative charge for a long distance.<br><br>However, distance eventually wins. There is a specific point where the push of the distant +3Q exactly equals the pull of the nearby -1Q.<br><br><strong>Mission:</strong> Find the Null Point where <strong>E = 0</strong> (approx x > 25).",
                setup: () => { },
                check: () => (state.probeX > 28 && state.probeX < 32)
            },
            {
                title: "Crossing the Asymptote",
                text: "Excellent. You found the balance point (~x=30).<br><br>Now, look at what happens <strong>after</strong> the null point. The field reappears, but the arrow has <strong>flipped</strong>. It now points away from the system.<br><br>From far away, the separation (distance between charges) doesn't matter. The universe just sees a net charge of +2Q (+3Q - 1Q). Thus, at large distances, the field behaves exactly like a single +2Q charge. Now that we understand the math, let's look at a more powerful way to visualize these fields using Field Lines.",
                setup: () => { },
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML = `<div class="chapter-title">${l.title}</div><div class="story-text">${l.text}</div>`;
            const btn = document.getElementById('btn-next');
            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }
            l.setup();
        }
        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.parent.location.href = '/lesson/field_lines';
            }
        }
        function prevLesson() { if (currentChapter > 0) loadLesson(currentChapter - 1); }
        function checkAdvance() { if (currentChapter >= lessons.length - 1) return; if (lessons[currentChapter].check()) { document.getElementById('btn-next').disabled = false; } }
        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        loadLesson(0);

        window.addEventListener('resize', () => {
            aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * aspect / 2;
            camera.right = viewSize * aspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });
    </script>
</body>

</html>

===== END OF 3_asymptotic_behaviorr.html =====


===== START OF 4_field_lines.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>The Invisible Web: Field Lines</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
            --red: #ff6b6b;
            --blue: #54a0ff;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        .coord-display {
            float: right;
            color: var(--accent);
            font-family: monospace;
        }

        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        /* NEXT BUTTON STYLING FIX */
        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            border: none;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
            transform: none;
            animation: none;
        }

        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }

        /* UPDATED BADGE STYLE */
        .analogy-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            /* Pill shape */
            font-size: 11px;
            text-transform: uppercase;
            font-weight: 800;
            margin-left: 4px;
            color: #fff;
            /* White text */
            vertical-align: middle;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            letter-spacing: 0.5px;
        }

        .badge-source {
            background: var(--red);
        }

        .badge-sink {
            background: var(--blue);
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Sim: Field Line Topology</div>
        </header>

        <div id="story-container">
            <div id="chapter-content"><!-- Content injected by JS --></div>
        </div>

        <div id="controls-area">
            <div class="control-row" id="ctrl-vis">
                <label>Step 1: The Map</label>
                <button id="btn-vis" onclick="toggleLines()">Draw Field Lines</button>
            </div>
            <div class="control-row" id="ctrl-flow">
                <label>Step 2: The Flow</label>
                <button id="btn-flow" onclick="toggleParticles()">Activate "Test Charge" Flow</button>
            </div>
            <div class="control-row" id="ctrl-config">
                <label>Step 3: Configuration</label>
                <div style="display:flex; gap:10px;">
                    <button id="btn-attract" onclick="setConfig('dipole')"
                        style="background:var(--accent); color:#111;">Dipole (+/-)</button>
                    <button id="btn-repel" onclick="setConfig('repulse')">Repulsion (+/+)</button>
                </div>
            </div>
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Experiment Control</label>
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Electrostatic Topology</div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const state = {
            linesVisible: false,
            particlesActive: false,
            config: 'dipole',
            time: 0
        };

        const scene = new THREE.Scene();
        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        let viewSize = 50;

        const camera = new THREE.OrthographicCamera(-viewSize * aspect / 2, viewSize * aspect / 2, viewSize / 2, -viewSize / 2, 1, 1000);
        camera.position.set(20, 30, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('world').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Floor & Grid
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8, metalness: 0.2 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -10;
        floor.receiveShadow = true;
        scene.add(floor);
        scene.background = new THREE.Color(0x151515);
        const gridHelper = new THREE.GridHelper(300, 60, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -9.9;
        scene.add(gridHelper);

        // --- CHARGES ---
        const charges = [];
        const chargeGroup = new THREE.Group();
        scene.add(chargeGroup);

        function createCharge(val, x, color) {
            const geo = new THREE.IcosahedronGeometry(val > 0 ? 3 : 2, 1);
            const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.4 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, 0, 0);

            // Label
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 60px Arial';
            ctx.fillStyle = color;
            ctx.textAlign = "center";
            ctx.fillText(val > 0 ? "+" : "-", 64, 80);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
            sprite.position.set(0, 4, 0);
            sprite.scale.set(4, 4, 1);
            mesh.add(sprite);

            chargeGroup.add(mesh);
            return { val: val, mesh: mesh };
        }

        // --- FIELD LINE ENGINE ---
        const linesGroup = new THREE.Group();
        scene.add(linesGroup);

        // Particle System for Flow
        const particleCount = 600;
        const particleGeo = new THREE.BufferGeometry();
        const particlePos = new Float32Array(particleCount * 3);
        particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePos, 3));
        // Updated material for better visibility
        const particleMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.6, transparent: true, opacity: 0 });
        const particleSystem = new THREE.Points(particleGeo, particleMat);
        particleSystem.frustumCulled = false; // Prevent disappearing at edges
        scene.add(particleSystem);

        const particles = [];
        const paths = [];

        function getNetField(pos) {
            let E = new THREE.Vector3(0, 0, 0);
            charges.forEach(q => {
                const rVec = new THREE.Vector3().subVectors(pos, q.mesh.position);
                const dist = rVec.length();
                if (dist < 0.1) return;
                const mag = q.val / (dist * dist * dist);
                E.add(rVec.multiplyScalar(mag));
            });
            return E;
        }

        function generateLines() {
            // Clear old
            linesGroup.clear();
            paths.length = 0;
            particles.length = 0;

            const mat = new THREE.LineBasicMaterial({ color: 0x8892b0, transparent: true, opacity: 0.3 });

            // Find Positive Charges (Sources)
            const sources = charges.filter(c => c.val > 0);

            sources.forEach(src => {
                // Emit lines
                const numLines = Math.abs(src.val) * 12;
                const radius = 2.5;

                for (let i = 0; i < numLines; i++) {
                    const phi = Math.acos(1 - 2 * (i + 0.5) / numLines);
                    const theta = Math.PI * (1 + Math.sqrt(5)) * i;

                    const startPos = new THREE.Vector3(
                        radius * Math.sin(phi) * Math.cos(theta),
                        radius * Math.sin(phi) * Math.sin(theta),
                        radius * Math.cos(phi)
                    ).add(src.mesh.position);

                    const path = [startPos];
                    let curr = startPos.clone();
                    let alive = true;

                    for (let step = 0; step < 200; step++) {
                        const E = getNetField(curr);
                        const Emag = E.length();

                        if (Emag < 0.01) { alive = false; break; }

                        const dir = E.normalize();
                        const move = dir.multiplyScalar(0.8);
                        const next = curr.clone().add(move);

                        let hitSink = false;
                        charges.forEach(q => {
                            if (q.val < 0 && next.distanceTo(q.mesh.position) < 2.5) hitSink = true;
                        });

                        path.push(next);
                        curr = next;

                        if (hitSink) break;
                        if (Math.abs(curr.x) > 50 || Math.abs(curr.z) > 40) break;
                    }

                    if (path.length > 5) {
                        paths.push(path);
                        const geometry = new THREE.BufferGeometry().setFromPoints(path);
                        linesGroup.add(new THREE.Line(geometry, mat));
                    }
                }
            });

            // Initialize particles if paths exist
            if (paths.length > 0) {
                for (let i = 0; i < particleCount; i++) {
                    particles.push({
                        pathIdx: Math.floor(Math.random() * paths.length),
                        progress: Math.random(),
                        speed: 0.005 + Math.random() * 0.01
                    });
                }
            }
        }

        function updateConfig() {
            chargeGroup.clear();
            charges.length = 0;

            if (state.config === 'dipole') {
                const q1 = createCharge(4, -10, '#ff6b6b');
                const q2 = createCharge(-4, 10, '#54a0ff');
                charges.push(q1, q2);
            } else {
                const q1 = createCharge(4, -10, '#ff6b6b');
                const q2 = createCharge(4, 10, '#ff6b6b');
                charges.push(q1, q2);
            }

            // Always generate data, but visibility controls render
            generateLines();
            if (!state.linesVisible) linesGroup.clear();
        }


        // ==========================================
        // PART 2: ANIMATION LOOP
        // ==========================================

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.01;

            // Animate Charge Bobbing
            charges.forEach((c, i) => {
                c.mesh.position.y = Math.sin(state.time + i) * 0.5;
            });

            // Animate Particles
            if (state.particlesActive && paths.length > 0 && particles.length > 0) {
                particleMat.opacity = 1.0;
                const positions = particleSystem.geometry.attributes.position.array;

                particles.forEach((p, i) => {
                    const path = paths[p.pathIdx];

                    // Safety check
                    if (!path) return;

                    p.progress += p.speed;
                    if (p.progress >= 1) p.progress = 0;

                    const totalPoints = path.length - 1;
                    const floatIdx = p.progress * totalPoints;
                    const idx = Math.floor(floatIdx);
                    const t = floatIdx - idx;

                    if (idx < totalPoints) {
                        const p1 = path[idx];
                        const p2 = path[idx + 1];
                        const x = p1.x + (p2.x - p1.x) * t;
                        const y = p1.y + (p2.y - p1.y) * t;
                        const z = p1.z + (p2.z - p1.z) * t;

                        positions[i * 3] = x;
                        positions[i * 3 + 1] = y;
                        positions[i * 3 + 2] = z;
                    }
                });
                particleSystem.geometry.attributes.position.needsUpdate = true;
            } else {
                particleMat.opacity = 0;
            }

            renderer.render(scene, camera);
        }

        // Init
        updateConfig();
        animate();


        // ==========================================
        // PART 3: NARRATIVE LOGIC
        // ==========================================

        let currentChapter = 0;

        function toggleLines() {
            state.linesVisible = !state.linesVisible;
            if (state.linesVisible) {
                generateLines(); // Regenerate to ensure fresh paths
            } else {
                linesGroup.clear();
                // We keep paths in memory so particles can work if user clicks flow without lines (optional, but safer to clear)
                // But for this UI, clearing visuals is enough.
            }

            document.getElementById('btn-vis').innerText = state.linesVisible ? "Hide Lines" : "Draw Field Lines";
            checkAdvance();
        }

        function toggleParticles() {
            state.particlesActive = !state.particlesActive;

            // If lines aren't drawn yet, draw them invisibly so we have paths
            if (paths.length === 0) generateLines();
            if (!state.linesVisible) linesGroup.clear(); // Keep lines hidden if they were hidden

            document.getElementById('btn-flow').innerText = state.particlesActive ? "Stop Flow" : "Activate 'Test Charge' Flow";
            checkAdvance();
        }

        function setConfig(type) {
            state.config = type;
            const btnA = document.getElementById('btn-attract');
            const btnR = document.getElementById('btn-repel');

            if (type === 'dipole') {
                btnA.style.background = 'var(--accent)'; btnA.style.color = '#111';
                btnR.style.background = '#2c313a'; btnR.style.color = '#aaa';
            } else {
                btnR.style.background = 'var(--accent)'; btnR.style.color = '#111';
                btnA.style.background = '#2c313a'; btnA.style.color = '#aaa';
            }

            updateConfig();
            checkAdvance();
        }

        function resetSim() {
            state.linesVisible = false;
            state.particlesActive = false;
            linesGroup.clear();

            document.getElementById('btn-vis').innerText = "Draw Field Lines";
            document.getElementById('btn-flow').innerText = "Activate 'Test Charge' Flow";

            setConfig('dipole');
            loadLesson(0);
        }

        const lessons = [
            {
                title: "The Invisible Map",
                text: "Vector arrows are useful, but they get cluttered. Physicists often use <strong>Field Lines</strong> to create a cleaner map of the universe.<br><br>Think of these lines as rails. If we placed a tiny positive test charge on a rail, the electrostatic force would push it along that specific track.<br><br><span class='instruction-inline'>Click 'DRAW FIELD LINES'</span> to reveal the topology.",
                setup: () => { lockAll(); unlock('ctrl-vis'); },
                check: () => state.linesVisible
            },
            {
                title: "Sources and Sinks",
                text: "Notice the direction. Positive charges (Red) act as <strong>Sources</strong> <span class='analogy-badge badge-source'>HAIRDRYER</span>. They blow the field out.<br><br>Negative charges (Blue) act as <strong>Sinks</strong> <span class='analogy-badge badge-sink'>VACUUM</span>. They suck the field in.<br><br><span class='instruction-inline'>Click 'ACTIVATE FLOW'</span> to release test charges and visualize this movement.",
                setup: () => { unlock('ctrl-flow'); },
                check: () => state.particlesActive
            },
            {
                title: "Density is Strength",
                text: "Observe the spacing of the lines. <br><br>Near the charges, the lines are packed tight. This indicates <strong>High Field Strength</strong>.<br><br>In the spaces far from the axis, the lines spread out. This indicates a <strong>Weaker Field</strong>. The density of lines literally represents the magnitude of the force.",
                setup: () => { },
                check: () => true
            },
            {
                title: "Repulsion Topology",
                text: "What if both charges are sources? <br><br>If we switch the right charge to Positive, both act as \"hairdryers\" blowing against each other. The lines cannot cross, so they bend away, creating an asymptote (a wall) in the middle.<br><br><span class='instruction-inline'>Click 'Repulsion (+/+)'</span> to see the lines fight for space. However, field lines can be misleading if we aren't careful. In the next lesson, we will address common misconceptions.",
                setup: () => { unlock('ctrl-config'); },
                check: () => state.config === 'repulse'
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML = `<div class="chapter-title">${l.title}</div><div class="story-text">${l.text}</div>`;
            const btn = document.getElementById('btn-next');
            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            } l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.parent.location.href = '/lesson/misconception';
            }
        }
        function prevLesson() { if (currentChapter > 0) loadLesson(currentChapter - 1); }
        function checkAdvance() { if (currentChapter >= lessons.length - 1) return; if (lessons[currentChapter].check()) { document.getElementById('btn-next').disabled = false; } }
        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        loadLesson(0);

        window.addEventListener('resize', () => {
            aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * aspect / 2;
            camera.right = viewSize * aspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });
    </script>
</body>

</html>

===== END OF 4_field_lines.html =====


===== START OF 5_misconception.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>The Invisible Web: Inertia & Trajectories</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
            --red: #ff6b6b;
            --blue: #54a0ff;
            --green: #2ecc71;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        /* NEXT BUTTON STYLING FIX */
        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            border: none;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
            transform: none;
            animation: none;
        }

        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }

        /* SPECIFIC BADGES FOR THIS LESSON */
        .analogy-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            text-transform: uppercase;
            font-weight: 800;
            margin-left: 4px;
            color: #fff;
            vertical-align: middle;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            letter-spacing: 0.5px;
        }

        .badge-wrong {
            background: var(--red);
        }

        .badge-correct {
            background: var(--green);
        }

        .badge-mass {
            background: #9b59b6;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Sim: Field Lines vs. Trajectories</div>
        </header>

        <div id="story-container">
            <div id="chapter-content"><!-- Content injected by JS --></div>
        </div>

        <div id="controls-area">
            <div class="control-row" id="ctrl-vis">
                <label>Step 1: The Context</label>
                <button id="btn-vis" onclick="toggleLines()">Draw Field Lines</button>
            </div>

            <div class="control-row" id="ctrl-massless">
                <label>Step 2: The Idealization</label>
                <button id="btn-ideal" onclick="fireParticle('massless')">Launch "Massless" Charge</button>
            </div>

            <div class="control-row" id="ctrl-real">
                <label>Step 3: The Reality</label>
                <button id="btn-real" onclick="fireParticle('massive')">Launch Massive Charge</button>
            </div>

            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Experiment Control</label>
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Newtonian Physics Engine</div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const state = {
            linesVisible: false,
            simulating: false,
            mode: 'none', // 'massless' or 'massive'
            time: 0
        };

        const scene = new THREE.Scene();
        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        let viewSize = 60;

        // Orthographic for clear "Map" view
        const camera = new THREE.OrthographicCamera(-viewSize * aspect / 2, viewSize * aspect / 2, viewSize / 2, -viewSize / 2, 1, 1000);
        camera.position.set(0, 50, 0); // Top-down view for 2D trajectory clarity
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('world').appendChild(renderer.domElement);

        // Light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        scene.add(dirLight);

        // Grid
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8, metalness: 0.2 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -5;
        floor.receiveShadow = true;
        scene.add(floor);
        scene.background = new THREE.Color(0x151515);

        const gridHelper = new THREE.GridHelper(100, 20, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -4.9;
        scene.add(gridHelper);

        // --- CHARGES (Dipole) ---
        const charges = [];
        const chargeGroup = new THREE.Group();
        scene.add(chargeGroup);

        function createCharge(val, x, z, color) {
            const geo = new THREE.IcosahedronGeometry(2.5, 1);
            const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, 0, z);

            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 40px Arial';
            ctx.fillStyle = color;
            ctx.textAlign = "center";
            ctx.fillText(val > 0 ? "+" : "-", 32, 48);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
            sprite.position.set(0, 0, 0);
            sprite.scale.set(6, 6, 1);
            sprite.rotation.x = -Math.PI / 2; // Lay flat for top down
            mesh.add(sprite);

            chargeGroup.add(mesh);
            return { val: val, mesh: mesh };
        }

        // Setup Dipole
        const q1 = createCharge(50, -20, 0, '#ff6b6b'); // Source
        const q2 = createCharge(-50, 20, 0, '#54a0ff'); // Sink
        charges.push(q1, q2);

        // --- FIELD LINES (Static Background) ---
        const linesGroup = new THREE.Group();
        scene.add(linesGroup);

        function getNetField(pos) {
            let E = new THREE.Vector3(0, 0, 0);
            charges.forEach(q => {
                const rVec = new THREE.Vector3().subVectors(pos, q.mesh.position);
                const distSq = rVec.lengthSq();
                const dist = Math.sqrt(distSq);
                if (dist < 1) return; // Singularity guard
                // E = k * q / r^2 * rHat
                const mag = q.val / (distSq);
                E.add(rVec.normalize().multiplyScalar(mag));
            });
            return E;
        }

        function generateLines() {
            linesGroup.clear();
            const mat = new THREE.LineBasicMaterial({ color: 0x8892b0, transparent: true, opacity: 0.2 });

            const src = charges[0]; // Positive charge
            const numLines = 24;

            for (let i = 0; i < numLines; i++) {
                const angle = (i / numLines) * Math.PI * 2;
                const startPos = new THREE.Vector3(
                    Math.cos(angle) * 3, 0, Math.sin(angle) * 3
                ).add(src.mesh.position);

                const path = [startPos];
                let curr = startPos.clone();

                for (let step = 0; step < 400; step++) {
                    const E = getNetField(curr);
                    if (E.length() < 0.05) break;

                    curr.add(E.normalize().multiplyScalar(0.5)); // Move along field
                    path.push(curr.clone());

                    // Stop if hitting sink
                    if (curr.distanceTo(charges[1].mesh.position) < 3) break;
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(path);
                linesGroup.add(new THREE.Line(geometry, mat));
            }
        }

        // --- PHYSICS PARTICLE ---
        let physicsParticle = null;
        let particleTrail = [];
        const particleMesh = new THREE.Mesh(
            new THREE.SphereGeometry(1, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0xffffff })
        );
        scene.add(particleMesh);
        particleMesh.visible = false;

        // Trail Line
        const trailGeo = new THREE.BufferGeometry();
        const trailMat = new THREE.LineBasicMaterial({ color: 0x2ecc71, linewidth: 3 });
        const trailLine = new THREE.Line(trailGeo, trailMat);
        scene.add(trailLine);

        function resetPhysics() {
            state.simulating = false;
            particleMesh.visible = false;
            particleTrail = [];
            trailGeo.setFromPoints([]);
        }

        function fireParticle(mode) {
            resetPhysics();
            state.mode = mode;
            state.simulating = true;
            particleMesh.visible = true;

            // Release Point: Slightly offset from the straight line to force a curve
            // Positioned above the source to enter the field
            physicsParticle = {
                pos: new THREE.Vector3(-15, 0, 5),
                vel: new THREE.Vector3(0, 0, 0), // Start from rest
                mass: mode === 'massless' ? 0.05 : 10.0 // Huge mass difference
            };

            particleMesh.position.copy(physicsParticle.pos);

            // Color coding
            if (mode === 'massless') {
                particleMesh.material.color.setHex(0xffaa00); // Orange for 'Test Charge'
                trailMat.color.setHex(0xffaa00);
            } else {
                particleMesh.material.color.setHex(0x2ecc71); // Green for 'Real Physics'
                trailMat.color.setHex(0x2ecc71);
            }

            checkAdvance();
        }

        // ==========================================
        // PART 2: ANIMATION LOOP (PHYSICS ENGINE)
        // ==========================================

        function animate() {
            requestAnimationFrame(animate);

            if (state.simulating && physicsParticle) {
                const dt = 0.05; // Time step

                // 1. Get Electric Field at current position
                const E = getNetField(physicsParticle.pos);

                // 2. Calculate Force (F = qE). Let q = 1.
                const F = E.clone();

                if (state.mode === 'massless') {
                    // FAKE PHYSICS (Aristotelian/Massless)
                    // Velocity is directly proportional to Field (V ~ E)
                    // This forces it to follow the line exactly.
                    physicsParticle.vel = E.normalize().multiplyScalar(0.8);
                } else {
                    // REAL PHYSICS (Newtonian)
                    // F = ma  ->  a = F/m
                    const a = F.clone().divideScalar(physicsParticle.mass);

                    // v = v + a*dt
                    physicsParticle.vel.add(a.multiplyScalar(dt));
                }

                // 3. Update Position
                physicsParticle.pos.add(physicsParticle.vel.clone().multiplyScalar(state.mode === 'massless' ? 1 : dt * 5));

                // Update Mesh
                particleMesh.position.copy(physicsParticle.pos);

                // Update Trail
                if (state.time % 2 === 0 || true) { // Every frame
                    particleTrail.push(physicsParticle.pos.clone());
                    trailGeo.setFromPoints(particleTrail);
                }

                // Stop condition
                if (physicsParticle.pos.distanceTo(q2.mesh.position) < 3 || physicsParticle.pos.length() > 60) {
                    state.simulating = false;
                }
            }

            state.time++;
            renderer.render(scene, camera);
        }

        animate();


        // ==========================================
        // PART 3: NARRATIVE LOGIC
        // ==========================================

        let currentChapter = 0;

        function toggleLines() {
            state.linesVisible = !state.linesVisible;
            if (state.linesVisible) {
                generateLines();
            } else {
                linesGroup.clear();
            }
            document.getElementById('btn-vis').innerText = state.linesVisible ? "Hide Field Lines" : "Draw Field Lines";
            checkAdvance();
        }

        function resetSim() {
            resetPhysics();
            state.linesVisible = false;
            linesGroup.clear();
            document.getElementById('btn-vis').innerText = "Draw Field Lines";
            loadLesson(0);
        }

        const lessons = [
            {
                title: "The Misconception",
                text: "A common mistake is thinking that <strong>Field Lines</strong> represent the path a charged particle will take.<br><br>It looks like a train track, right? If you put a train on a track, it follows the rails. <br><br>Let's set up the map first. We have a Positive Source (Red) and Negative Sink (Blue).<br><br><span class='instruction-inline'>Click 'Draw Field Lines'</span> to see the curves.",
                setup: () => { lockAll(); unlock('ctrl-vis'); },
                check: () => state.linesVisible
            },
            {
                title: "The 'Massless' Ideal",
                text: "Charges <strong>only</strong> follow field lines exactly if they have zero mass (or move very slowly in a highly viscous medium).<br><br>In this case, the force vector points along the line, and without inertia, the particle turns instantly.<br><br><span class='instruction-inline'>Click 'Launch Massless Charge'</span>. Watch how it hugs the curve perfectly.",
                setup: () => { unlock('ctrl-massless'); },
                check: () => state.mode === 'massless'
            },
            {
                title: "The Reality: Inertia",
                text: "Real particles have mass. Mass means <strong>Inertia</strong>.<br><br>Inertia is the resistance to changing direction. When the field line curves, the particle <em>wants</em> to keep going straight.<br><br><span class='instruction-inline'>Click 'Launch Massive Charge'</span>. Watch it 'drift' off the track like a race car taking a corner too fast.",
                setup: () => { unlock('ctrl-real'); },
                check: () => state.mode === 'massive'
            },
            {
                title: "Vectors: Force vs. Velocity",
                text: "Why did that happen?<br><br>At every point, the <strong>Electric Field</strong> (the line) tells the particle which way to <em>accelerate</em> (Force).<br><br>But the particle's <strong>Velocity</strong> tells it where it is going <em>now</em>.<br><br>Unless the line is perfectly straight, the Velocity vector and Force vector point in different directions. The particle moves based on the sum of its history (velocity) and the current pull (force). Now that we've cleared up how charges move, let's look at one of the most important structures in nature: The Electric Dipole.",
                setup: () => { },
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML = `<div class="chapter-title">${l.title}</div><div class="story-text">${l.text}</div>`;
            const btn = document.getElementById('btn-next');
            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            } l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.parent.location.href = '/lesson/dipole';
            }
        }
        function prevLesson() { if (currentChapter > 0) loadLesson(currentChapter - 1); }
        function checkAdvance() { if (currentChapter >= lessons.length - 1) return; if (lessons[currentChapter].check()) { document.getElementById('btn-next').disabled = false; } }
        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        loadLesson(0);

        window.addEventListener('resize', () => {
            aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * aspect / 2;
            camera.right = viewSize * aspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });
    </script>
</body>

</html>

===== END OF 5_misconception.html =====


===== START OF 6_dipole.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>The Electric Dipole: Nature's Balance</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
            --pos-color: #ff6b6b;
            --neg-color: #54a0ff;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        .math-block {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #333;
            color: #fff;
            text-align: center;
        }

        /* CONTROLS AREA */
        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        /* NAVIGATION FOOTER */
        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        /* NEXT BUTTON STYLING FIX */
        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            border: none;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
            transform: none;
            animation: none;
        }

        /* MAIN CANVAS */
        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        /* TAGS IN SCENE */
        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Simulation: The Electric Dipole</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- 1. Add Negative Charge -->
            <div class="control-row" id="ctrl-add-neg">
                <label>Step 1: Create Balance</label>
                <button id="btn-add-neg" onclick="addNegativeCharge()">Add Opposite Charge (-Q)</button>
            </div>

            <!-- 2. Show Vector Grid -->
            <div class="control-row" id="ctrl-grid">
                <label>Step 2: Visualize The Web</label>
                <button id="btn-grid" onclick="showVectorField()">Reveal Field Lines</button>
            </div>

            <!-- Reset -->
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Experiment Control</label>
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Vacuum Space &epsilon;<sub>0</sub></div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const state = {
            hasNegative: false,
            fieldVisible: false,
            time: 0
        };

        const scene = new THREE.Scene();

        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 40;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );

        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('world').appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // Floor (Grid)
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({
            color: 0x222222,
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -5;
        floor.receiveShadow = true;
        scene.add(floor);
        scene.background = new THREE.Color(0x151515);

        const gridHelper = new THREE.GridHelper(100, 20, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -4.9;
        scene.add(gridHelper);

        // --- OBJECTS ---

        // 1. Positive Source Charge (+Q) - Red
        const posGroup = new THREE.Group();
        const chargeGeo = new THREE.IcosahedronGeometry(2, 1);
        const posMat = new THREE.MeshStandardMaterial({ color: 0xff6b6b, flatShading: true, emissive: 0x550000 });
        const posMesh = new THREE.Mesh(chargeGeo, posMat);
        posMesh.castShadow = true;
        posGroup.add(posMesh);
        posGroup.position.set(-6, 0, 0);
        scene.add(posGroup);

        // 2. Negative Source Charge (-Q) - Blue
        const negGroup = new THREE.Group();
        const negMat = new THREE.MeshStandardMaterial({ color: 0x54a0ff, flatShading: true, emissive: 0x002255 });
        const negMesh = new THREE.Mesh(chargeGeo, negMat);
        negMesh.castShadow = true;
        negGroup.add(negMesh);
        negGroup.position.set(6, 0, 0);
        scene.add(negGroup);
        negGroup.visible = false;

        // 3. Vector Field System
        const fieldArrows = [];
        const fieldGroup = new THREE.Group();
        scene.add(fieldGroup);

        function createArrow() {
            const grp = new THREE.Group();
            // Arrow Shaft (Cylinder)
            const sGeo = new THREE.CylinderGeometry(0.08, 0.08, 1, 8);
            sGeo.rotateX(Math.PI / 2);
            sGeo.translate(0, 0, 0.5);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 });
            const shaft = new THREE.Mesh(sGeo, mat);

            // Arrow Head (Cone)
            const hGeo = new THREE.ConeGeometry(0.25, 0.5, 8);
            hGeo.rotateX(Math.PI / 2);
            hGeo.translate(0, 0, 1);
            const head = new THREE.Mesh(hGeo, mat);

            grp.add(shaft, head);
            return { mesh: grp, mat: mat };
        }

        // Create a grid of arrows
        for (let x = -20; x <= 20; x += 3) {
            for (let z = -20; z <= 20; z += 3) {
                if (Math.abs(x) < 2 && Math.abs(z) < 2) continue; // Skip center clutter
                const arrowObj = createArrow();
                arrowObj.mesh.position.set(x, 0, z);
                fieldGroup.add(arrowObj.mesh);
                fieldArrows.push({
                    obj: arrowObj.mesh,
                    mat: arrowObj.mat,
                    basePos: new THREE.Vector3(x, 0, z)
                });
            }
        }
        fieldGroup.visible = false;

        // Labels
        function createTextSprite(text, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 40px Arial';
            ctx.fillStyle = color;
            ctx.textAlign = "center";
            ctx.fillText(text, 64, 50);
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, depthTest: false });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(4, 2, 1);
            return sprite;
        }
        const labelPos = createTextSprite("+Q", "#ff6b6b");
        labelPos.position.y = 3.5;
        posGroup.add(labelPos);

        const labelNeg = createTextSprite("-Q", "#54a0ff");
        labelNeg.position.y = 3.5;
        negGroup.add(labelNeg);


        // ==========================================
        // PART 2: PHYSICS & ANIMATION
        // ==========================================

        // Physics Constants
        const kQ = 200;

        function getFieldAt(pos) {
            // E_pos vector
            const r1Vec = new THREE.Vector3().subVectors(pos, posGroup.position);
            const r1Sq = r1Vec.lengthSq();
            const dist1 = Math.max(Math.sqrt(r1Sq), 1.5);
            const E1 = r1Vec.clone().normalize().multiplyScalar(kQ / (dist1 * dist1));

            if (!state.hasNegative) {
                return E1;
            }

            // E_neg vector (Pulls toward negative)
            const r2Vec = new THREE.Vector3().subVectors(pos, negGroup.position);
            const r2Sq = r2Vec.lengthSq();
            const dist2 = Math.max(Math.sqrt(r2Sq), 1.5);
            const E2 = r2Vec.clone().normalize().multiplyScalar(-kQ / (dist2 * dist2));

            return new THREE.Vector3().addVectors(E1, E2);
        }

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.02;

            // 1. Bobbing Animation for Charges
            posMesh.position.y = Math.sin(state.time) * 0.2;
            labelPos.position.y = 3.5 + Math.sin(state.time) * 0.2;

            if (state.hasNegative) {
                negMesh.position.y = Math.cos(state.time) * 0.2;
                labelNeg.position.y = 3.5 + Math.cos(state.time) * 0.2;
            } else {
                // If monopole, center the positive charge visually
                posGroup.position.lerp(new THREE.Vector3(0, 0, 0), 0.1);
            }

            // 2. If Dipole Mode, move charges to positions
            if (state.hasNegative) {
                posGroup.position.lerp(new THREE.Vector3(-6, 0, 0), 0.1);
            }

            // 3. Update Vector Field
            if (state.fieldVisible) {
                const up = new THREE.Vector3(0, 1, 0);

                fieldArrows.forEach(arrow => {
                    const E = getFieldAt(arrow.basePos);
                    const mag = E.length();

                    // Direction
                    const direction = E.clone().normalize();
                    const axisZ = new THREE.Vector3(0, 0, 1);
                    const quat = new THREE.Quaternion().setFromUnitVectors(axisZ, direction);
                    arrow.obj.quaternion.slerp(quat, 0.2);

                    // Scale
                    let s = Math.log(mag * 5 + 1);
                    s = Math.min(s, 2.5);
                    s = Math.max(s, 0.2);
                    arrow.obj.scale.setScalar(s);

                    // Color
                    const intensity = Math.min(mag / 3, 1);
                    arrow.mat.color.setHSL(0.6 - (intensity * 0.6), 0, 0.3 + intensity * 0.7);
                    arrow.mat.opacity = 0.3 + (intensity * 0.7);
                });
            }

            renderer.render(scene, camera);
        }
        animate();

        // ==========================================
        // PART 3: LOGIC & NARRATIVE
        // ==========================================

        let currentChapter = 0;

        function addNegativeCharge() {
            state.hasNegative = true;
            negGroup.visible = true;
            document.getElementById('btn-add-neg').disabled = true;
            document.getElementById('btn-add-neg').innerText = "System Balanced";
            checkAdvance();
        }

        function showVectorField() {
            state.fieldVisible = true;
            fieldGroup.visible = true;
            document.getElementById('btn-grid').disabled = true;
            checkAdvance();
        }

        function resetSim() {
            state.hasNegative = false;
            state.fieldVisible = false;

            negGroup.visible = false;
            fieldGroup.visible = false;

            // Reset buttons
            const btnNeg = document.getElementById('btn-add-neg');
            btnNeg.disabled = false;
            btnNeg.innerText = "Add Opposite Charge (-Q)";

            const btnGrid = document.getElementById('btn-grid');
            btnGrid.disabled = false;

            loadLesson(0);
        }

        // --- LESSON CONTENT ---

        const lessons = [
            {
                title: " The Monopole",
                text: "We begin with a single positive charge (+Q). Nature dislikes imbalance.<br><br>Imagine a 'test charge' placed anywhere in this space. It would be pushed straight away. The electric field is purely <strong>radial</strong>, extending to infinity like light from a bulb.<br><br>But what happens if we introduce a counter-balance? <span class='instruction-inline'>Click 'ADD OPPOSITE CHARGE'</span>.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-add-neg');
                    unlock('ctrl-grid'); // Allow viewing monopole field
                    state.hasNegative = false;
                    negGroup.visible = false;
                },
                check: () => state.hasNegative
            },
            {
                title: "The Dipole Formation",
                text: "You have added a negative charge (-Q) of equal magnitude. This systemâ€”two equal but opposite charges separated by a distanceâ€”is an <strong>Electric Dipole</strong>.<br><br>Notice the space between them. A test charge here is pushed by the Red (+Q) <em>and</em> pulled by the Blue (-Q). These forces work together in the same direction, creating a strong field between them.<br><br>But what about the rest of space? <span class='instruction-inline'>Click 'REVEAL FIELD LINES'</span>.",
                setup: () => {
                    unlock('ctrl-grid');
                },
                check: () => state.fieldVisible
            },
            {
                title: "Symmetry of the Field",
                text: "Look at the pattern. It is no longer radial.<br><br>The field lines arc out of the positive charge and curve around to dive into the negative charge. <br><br><strong>Key Concept:</strong> There is <strong>no point</strong> in space where the field is zero. The 'Push' from +Q and 'Pull' from -Q never perfectly cancel out because the charges are at different locations.",
                setup: () => { },
                check: () => true
            },
            {
                title: "Insight: The Far Field",
                text: "Here is a thought experiment: Imagine you walk a mile away from this dipole.<br><br>From that distance, the separation between the charges looks tiny. The Positive and Negative charges seem to occupy the same spot. Because they are opposites, they <em>almost</em> cancel each other out.<br><br>This means the field dies off much faster ($1/r^3$) than a single charge ($1/r^2$). Dipoles are 'short-range' influencers.",
                setup: () => { },
                check: () => true
            },
            {
                title: "Dipoles in Reality",
                text: "Where do we find this geometry in nature?<br><br>1. <strong>Water (Hâ‚‚O):</strong> Oxygen is negative, Hydrogen is positive. This dipole nature allows water to dissolve salts and exist as a liquid.<br>2. <strong>Antennas:</strong> Radio transmission works by oscillating charges up and down, creating a changing dipole that radiates waves.<br>3. <strong>The Heart:</strong> An ECG measures the changing electric dipole vector of your heart muscle as it beats. But how do we create these dipoles if we start with neutral objects? We use a trick called Induction.",
                setup: () => { },
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div>
             <div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');

            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }

            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.parent.location.href = '/lesson/dipole_induction';
            }
        }
        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }
        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        // Init
        loadLesson(0);

        // Resize Handle
        window.addEventListener('resize', () => {
            aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            const camSize = camera.top - camera.bottom;
            camera.left = -camSize * aspect / 2;
            camera.right = camSize * aspect / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

    </script>
</body>

</html>

===== END OF 6_dipole.html =====


===== START OF 7_creating_a_dipole(induction).html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Induction: The Trap</title>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        /* CONTROLS AREA */
        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        /* NAVIGATION FOOTER */
        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        /* NEXT BUTTON STYLING FIX */
        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            border: none;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
            transform: none;
            animation: none;
        }

        /* MAIN CANVAS */
        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Simulation: Induction & The Dipole</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- 1. Introduce Rod -->
            <div class="control-row" id="ctrl-rod">
                <label>Step 1: The Influence</label>
                <button id="btn-rod" onclick="introduceRod()">Bring Negative Rod</button>
            </div>

            <!-- 2. Separate Spheres -->
            <div class="control-row" id="ctrl-sep">
                <label>Step 2: The Trap</label>
                <button id="btn-sep" onclick="separateSpheres()">Separate Spheres</button>
            </div>

            <!-- 3. Remove Rod -->
            <div class="control-row" id="ctrl-remove">
                <label>Step 3: Isolation</label>
                <button id="btn-remove" onclick="removeRod()">Remove Rod</button>
            </div>

            <!-- Reset -->
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Experiment Control</label>
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Laboratory Frame</div>
    </main>

    <script type="module">
        import * as THREE from 'three';

        // ==========================================
        // GLOBALS
        // ==========================================
        let currentChapter = 0;

        const state = {
            rodNear: false,
            spheresSeparated: false,
            rodRemoved: false,
            time: 0
        };

        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================
        const scene = new THREE.Scene();
        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 35;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );

        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('world').appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Floor (Grid)
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({
            color: 0x222222,
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -6;
        floor.receiveShadow = true;
        scene.add(floor);
        scene.background = new THREE.Color(0x151515);

        const gridHelper = new THREE.GridHelper(100, 20, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -5.9;
        scene.add(gridHelper);

        // ==========================================
        // PART 2: LABORATORY EQUIPMENT
        // ==========================================

        // --- MATERIALS ---
        const metalMat = new THREE.MeshStandardMaterial({ color: 0xbdc3c7, roughness: 0.3, metalness: 0.8 });
        const standMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.9 });
        const rubberMat = new THREE.MeshStandardMaterial({ color: 0x2f3640, roughness: 0.9 });
        const electronMat = new THREE.MeshStandardMaterial({ color: 0x54a0ff, emissive: 0x2980b9, emissiveIntensity: 0.5 });
        const protonMat = new THREE.MeshStandardMaterial({ color: 0xff6b6b, emissive: 0xc0392b, emissiveIntensity: 0.5 });

        // --- SPHERES ---
        const sphereRadius = 3.5;

        function createSphereSetup(xPos) {
            const group = new THREE.Group();

            // The Metal Sphere
            const geo = new THREE.IcosahedronGeometry(sphereRadius, 2);
            const mesh = new THREE.Mesh(geo, metalMat);
            mesh.castShadow = true;
            group.add(mesh);

            // Insulating Stand
            const poleGeo = new THREE.CylinderGeometry(0.3, 0.3, 8, 8);
            const pole = new THREE.Mesh(poleGeo, standMat);
            pole.position.y = -4;
            pole.castShadow = true;

            const baseGeo = new THREE.CylinderGeometry(2, 2, 0.5, 16);
            const base = new THREE.Mesh(baseGeo, standMat);
            base.position.y = -8;
            base.receiveShadow = true;

            group.add(pole, base);
            group.position.set(xPos, 0, 0);
            return { group, mesh };
        }

        const sphereA = createSphereSetup(-3.6); // Left Sphere
        const sphereB = createSphereSetup(3.6);  // Right Sphere
        scene.add(sphereA.group, sphereB.group);

        // --- THE CHARGED ROD ---
        const rodGroup = new THREE.Group();
        const rodGeo = new THREE.CapsuleGeometry(1, 12, 4, 8);
        const rodMesh = new THREE.Mesh(rodGeo, rubberMat);
        rodMesh.rotation.z = Math.PI / 2;
        rodMesh.castShadow = true;
        rodGroup.add(rodMesh);

        // Rod charge indicators
        function createTextSprite(text, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 40px Arial';
            ctx.fillStyle = color;
            ctx.textAlign = "center";
            ctx.fillText(text, 32, 45);
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, depthTest: false });
            const sprite = new THREE.Sprite(mat);
            return sprite;
        }

        for (let i = -5; i <= 5; i += 2) {
            const sign = createTextSprite("-", "#54a0ff");
            sign.position.set(i, 1.2, 0);
            sign.scale.set(1.5, 1.5, 1);
            rodGroup.add(sign);
        }
        rodGroup.position.set(-25, 0, 0);
        scene.add(rodGroup);

        // --- CHARGE PARTICLES ---
        const electrons = [];
        const positiveHoles = [];
        const particleRadius = 0.4;

        // 1) <--- EDITED: CHANGE THIS VALUE TO EDIT RADIUS OF DISTRIBUTION
        // 3.5 = On Surface. 4.0 = Floating above.
        const particleSurfaceOffset = 3.5;

        function createParticle(isNeg) {
            const geo = new THREE.IcosahedronGeometry(particleRadius, 0);
            const mesh = new THREE.Mesh(geo, isNeg ? electronMat : protonMat);
            return mesh;
        }

        function randomPointOnSurface(radius) {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);

            // Fix r to be surface radius exactly
            const r = radius;
            const sinPhi = Math.sin(phi);

            return new THREE.Vector3(
                r * sinPhi * Math.cos(theta),
                r * sinPhi * Math.sin(theta),
                r * Math.cos(phi)
            );
        }

        // Initialize random positions
        for (let i = 0; i < 40; i++) {
            const e = createParticle(true);
            const targetSphere = Math.random() > 0.5 ? sphereA.group : sphereB.group;

            const pos = randomPointOnSurface(particleSurfaceOffset);

            e.position.copy(pos).add(targetSphere.position);
            e.userData = {
                homeSphere: targetSphere === sphereA.group ? 'A' : 'B',
                offset: pos
            };
            scene.add(e);
            electrons.push(e);
        }

        for (let i = 0; i < 20; i++) {
            const p = createParticle(false);
            const pos = randomPointOnSurface(particleSurfaceOffset);
            p.position.copy(pos).add(sphereA.group.position);
            p.visible = false;
            p.userData = { offset: pos };
            scene.add(p);
            positiveHoles.push(p);
        }

        // ==========================================
        // PART 3: ANIMATION LOOP
        // ==========================================

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.05;

            // 2) <--- EDITED: SHARED SPEED FOR SYNC
            // This ensures electrons move at the same speed as the sphere
            const motionSpeed = 0.08;

            // Rod Logic
            const rodTargetX = state.rodNear ? -12 : -35;
            const rodTargetY = state.rodRemoved ? 20 : 0;
            rodGroup.position.x += (rodTargetX - rodGroup.position.x) * motionSpeed;
            rodGroup.position.y += (rodTargetY - rodGroup.position.y) * motionSpeed;

            // Sphere Movement
            const sphereB_TargetX = state.spheresSeparated ? 10 : 3.6;
            // Use motionSpeed here
            sphereB.group.position.x += (sphereB_TargetX - sphereB.group.position.x) * motionSpeed;

            // Physics Logic
            electrons.forEach(e => {
                let targetPos = new THREE.Vector3();

                if (state.rodNear && !state.spheresSeparated) {
                    // Induction: Push to Sphere B
                    targetPos.copy(e.userData.offset).add(sphereB.group.position);
                    positiveHoles.forEach(p => p.visible = true);
                }
                else if (state.rodNear && state.spheresSeparated) {
                    // Trapped on B
                    targetPos.copy(e.userData.offset).add(sphereB.group.position);
                }
                else if (state.rodRemoved && state.spheresSeparated) {
                    // Isolation: B is negative
                    targetPos.copy(e.userData.offset).add(sphereB.group.position);

                    positiveHoles.forEach(p => {
                        p.visible = true;
                        const pTarget = new THREE.Vector3().copy(p.userData.offset).add(sphereA.group.position);
                        p.position.lerp(pTarget, motionSpeed);
                    });
                }
                else {
                    // Neutral (Reset)
                    if (e.userData.homeSphere === 'A')
                        targetPos.copy(e.userData.offset).add(sphereA.group.position);
                    else
                        targetPos.copy(e.userData.offset).add(sphereB.group.position);

                    positiveHoles.forEach(p => p.visible = false);
                }
                // Use motionSpeed here
                e.position.lerp(targetPos, motionSpeed);
            });

            if (state.rodNear) {
                positiveHoles.forEach(p => {
                    const pTarget = new THREE.Vector3().copy(p.userData.offset).add(sphereA.group.position);
                    p.position.lerp(pTarget, motionSpeed);
                });
            }

            renderer.render(scene, camera);
        }
        animate();

        // ==========================================
        // PART 4: INTERACTION & STORY
        // ==========================================

        const lessons = [
            {
                title: "Creating Dipoles",
                text: "Observe the two metal spheres. They are touching, effectively forming a single conductor.<br><br>In a metal, electrons (blue spheres) are free to roam on the surface. Currently, they are evenly distributed. The positive charges (red) are hidden underneath, neutralized by the electrons. <br><br>Let's disturb this equilibrium. <span class='instruction-inline'>Click 'BRING NEGATIVE ROD'</span>.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-rod');
                },
                check: () => state.rodNear
            },
            {
                title: "Electrostatic Repulsion",
                text: "The negatively charged rod approaches. <strong>Like charges repel.</strong><br><br>Watch the blue electrons slowly drift away from the rod. They flow from the left sphere to the right sphere.<br><br>This exposes the positive ions (red) on the left sphere. The system is polarized. <span class='instruction-inline'>Click 'SEPARATE SPHERES'</span>.",
                setup: () => {
                    unlock('ctrl-sep');
                },
                check: () => state.spheresSeparated
            },
            {
                title: "Setting the Trap",
                text: "You have separated the spheres while the rod was still pushing the electrons.<br><br>The bridge is broken! The blue electrons are now trapped on the right sphere. They cannot return to the left sphere.<br><br>We can now remove the influence. <span class='instruction-inline'>Click 'REMOVE ROD'</span>.",
                setup: () => {
                    unlock('ctrl-remove');
                },
                check: () => state.rodRemoved
            },
            {
                title: "Isolation Complete",
                text: "With the rod gone, look at the result.<br><br>The Left Sphere is positively charged (Red).<br>The Right Sphere is negatively charged (Blue).<br><br>We have successfully created static electricity from neutral objects using <strong>Induction</strong>. The charges are permanently separated. Now, let's see what happens when we bring a dipole near a massive source of charge: The Van de Graaff Generator.",
                setup: () => { },
                check: () => true
            }
        ];

        // --- EXPORT FUNCTIONS ---

        window.introduceRod = function () {
            state.rodNear = true;
            document.getElementById('btn-rod').disabled = true;
            document.getElementById('btn-rod').innerText = "Rod in Position";
            checkAdvance();
        };

        window.separateSpheres = function () {
            state.spheresSeparated = true;
            document.getElementById('btn-sep').disabled = true;
            document.getElementById('btn-sep').innerText = "Spheres Separated";
            checkAdvance();
        };

        window.removeRod = function () {
            state.rodRemoved = true;
            state.rodNear = false;
            document.getElementById('btn-remove').disabled = true;
            document.getElementById('btn-remove').innerText = "Rod Removed";
            checkAdvance();
        };

        window.resetSim = function () {
            state.rodNear = false;
            state.spheresSeparated = false;
            state.rodRemoved = false;

            resetBtn('btn-rod', "Bring Negative Rod");
            resetBtn('btn-sep', "Separate Spheres");
            resetBtn('btn-remove', "Remove Rod");

            loadLesson(0);
        };

        // Navigation Exports
        window.nextLesson = function () {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.parent.location.href = '/lesson/dipole_vandegraaff';
            }
        };
        window.prevLesson = function () {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        };

        function resetBtn(id, txt) {
            const b = document.getElementById(id);
            if (b) {
                b.disabled = false;
                b.innerText = txt;
                b.parentElement.classList.remove('active');
            }
        }

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div>
                 <div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');

            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }

            l.setup();
        }

        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) {
            const el = document.getElementById(id);
            if (el) el.classList.add('active');
        }

        // Init
        loadLesson(0);

        // Resize Handle
        window.addEventListener('resize', () => {
            aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            const camSize = camera.top - camera.bottom;
            camera.left = -camSize * aspect / 2;
            camera.right = camSize * aspect / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });
    </script>
</body>

</html>

===== END OF 7_creating_a_dipole(induction).html =====


===== START OF 8_dipole_on_vandeGraff.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Maxwell's Notebook: The Dipole Probe</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        .math-block {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #333;
            color: #fff;
            text-align: center;
        }

        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
            height: 6px;
            background: #333;
            border-radius: 3px;
        }

        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        /* NEXT BUTTON STYLING FIX */
        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            border: none;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
            transform: none;
            animation: none;
        }

        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }

        /* Tooltip for the Dipole */
        #dipole-readout {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-left: 2px solid var(--accent);
            color: #fff;
            font-family: monospace;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        #dipole-readout.visible {
            opacity: 1;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Experiment: Mapping the Generator</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- 1. Introduce Dipole -->
            <div class="control-row" id="ctrl-intro">
                <label>Step 1: The "Fishing Rod"</label>
                <button id="btn-intro" onclick="introduceDipole()">Equip Dipole Probe</button>
            </div>

            <!-- 2. Orbit Slider -->
            <div class="control-row" id="ctrl-orbit">
                <label>Step 2: Walk Around (Orbit)</label>
                <input type="range" id="slider-orbit" min="0" max="360" value="0" step="1">
            </div>

            <!-- 3. Polarity Switch -->
            <div class="control-row" id="ctrl-polarity">
                <label>Step 3: Analyze Polarity</label>
                <button id="btn-polarity" onclick="togglePolarity()">Swap Generator Polarity (+ / -)</button>
            </div>

            <!-- Reset -->
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Experiment Control</label>
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Lab Space (Vacuum)</div>
        <div id="dipole-readout">
            TORQUE: DETECTED<br>
            ALIGNMENT: RADIAL
        </div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const state = {
            dipoleVisible: false,
            angle: 0,         // Orbit angle around VdG
            distance: 12,     // Radius from VdG
            sourcePolarity: 1, // 1 for Positive, -1 for Negative
            time: 0
        };

        const scene = new THREE.Scene();

        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 35;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );

        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('world').appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // Floor
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -8;
        floor.receiveShadow = true;
        scene.add(floor);
        scene.background = new THREE.Color(0x151515);

        const gridHelper = new THREE.GridHelper(100, 20, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -7.9;
        scene.add(gridHelper);

        // --- OBJECTS ---

        // 1. The VandeGraaff Generator (Source)
        const vdgGroup = new THREE.Group();

        // Dome
        const domeGeo = new THREE.IcosahedronGeometry(4, 2);
        const domeMat = new THREE.MeshStandardMaterial({
            color: 0xcccccc,
            metalness: 0.6,
            roughness: 0.2,
            emissive: 0x222222
        });
        const dome = new THREE.Mesh(domeGeo, domeMat);
        dome.castShadow = true;

        // Column
        const colGeo = new THREE.CylinderGeometry(1.5, 1.5, 12, 16);
        const colMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const col = new THREE.Mesh(colGeo, colMat);
        col.position.y = -6;
        col.receiveShadow = true;

        vdgGroup.add(col);
        vdgGroup.add(dome);
        scene.add(vdgGroup);

        // Text Sprite Helper
        function createTextSprite(text, color = "#ffffff") {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 60px Arial';
            ctx.fillStyle = color;
            ctx.textAlign = "center";
            ctx.fillText(text, 128, 80);
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(6, 3, 1);
            return sprite;
        }

        const labelVDG = createTextSprite("VdG (+)", "#ff6b6b");
        labelVDG.position.y = 6;
        vdgGroup.add(labelVDG);

        // 2. The Dipole Probe (The "Fishing Rod")
        const dipoleGroup = new THREE.Group();

        // The Rod
        const rodGeo = new THREE.CylinderGeometry(0.1, 0.1, 4, 8);
        rodGeo.rotateZ(Math.PI / 2); // Lay flat on X
        const rodMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
        const rod = new THREE.Mesh(rodGeo, rodMat);
        rod.castShadow = true;
        dipoleGroup.add(rod);

        // Positive Ball (Red)
        const ballGeo = new THREE.IcosahedronGeometry(0.6, 1);
        const posMat = new THREE.MeshStandardMaterial({ color: 0xff4757, emissive: 0x330000 });
        const posBall = new THREE.Mesh(ballGeo, posMat);
        posBall.position.x = 2; // Right end
        dipoleGroup.add(posBall);

        // Negative Ball (Blue)
        const negMat = new THREE.MeshStandardMaterial({ color: 0x2e86de, emissive: 0x001133 });
        const negBall = new THREE.Mesh(ballGeo, negMat);
        negBall.position.x = -2; // Left end
        dipoleGroup.add(negBall);

        // Label Pointers on Dipole
        const labelPos = createTextSprite("+", "#ff4757");
        labelPos.scale.set(2, 1, 1);
        labelPos.position.set(2, 1.5, 0);
        dipoleGroup.add(labelPos);

        const labelNeg = createTextSprite("-", "#2e86de");
        labelNeg.scale.set(2, 1, 1);
        labelNeg.position.set(-2, 1.5, 0);
        dipoleGroup.add(labelNeg);

        scene.add(dipoleGroup);
        dipoleGroup.visible = false;

        // 3. Field Lines (Visual Aid)
        const linesGroup = new THREE.Group();
        const lineMat = new THREE.LineBasicMaterial({ color: 0x54a0ff, transparent: true, opacity: 0.15 });

        for (let i = 0; i < 16; i++) {
            const angle = (i / 16) * Math.PI * 2;
            const pts = [];
            pts.push(new THREE.Vector3(Math.cos(angle) * 4, 0, Math.sin(angle) * 4));
            pts.push(new THREE.Vector3(Math.cos(angle) * 20, 0, Math.sin(angle) * 20));
            const geo = new THREE.BufferGeometry().setFromPoints(pts);
            const line = new THREE.Line(geo, lineMat);
            linesGroup.add(line);
        }
        scene.add(linesGroup);
        linesGroup.visible = false;


        // ==========================================
        // PART 2: ANIMATION LOOP & PHYSICS
        // ==========================================

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.02;

            // VdG Pulse effect
            dome.scale.setScalar(1 + Math.sin(state.time * 2) * 0.01);

            if (state.dipoleVisible) {
                // 1. Position Dipole based on Orbit Slider
                const rad = state.angle * (Math.PI / 180);
                const x = Math.cos(rad) * state.distance;
                const z = Math.sin(rad) * state.distance;

                dipoleGroup.position.set(x, 0, z);

                // 2. CALCULATE TORQUE / ALIGNMENT
                // The field direction at position (x,0,z) is simply the vector (x,0,z) normalized.
                // Angle of field vector in XZ plane:
                let fieldAngle = Math.atan2(z, x);

                // If Source is NEGATIVE, field points INWARD.
                // A dipole aligns with field lines.
                // Positive end (Red, +x local) points along Field Vector.
                // If field is inward, Field Vector is (fieldAngle + PI).

                if (state.sourcePolarity === -1) {
                    // Field points IN. 
                    // We want the red ball (+ local x) to point IN.
                    // So dipole rotation should be fieldAngle + PI
                    dipoleGroup.rotation.y = -fieldAngle + Math.PI;
                } else {
                    // Field points OUT.
                    // Red ball (+ local x) points OUT.
                    dipoleGroup.rotation.y = -fieldAngle;
                }

                // Add a little oscillation to simulate "settling" physics
                dipoleGroup.rotation.y += Math.sin(state.time * 3) * 0.05;
            }

            renderer.render(scene, camera);
        }
        animate();

        // ==========================================
        // PART 3: LOGIC & NARRATIVE
        // ==========================================

        let currentChapter = 0;

        // --- Control Handlers ---

        function introduceDipole() {
            state.dipoleVisible = true;
            dipoleGroup.visible = true;
            document.getElementById('btn-intro').disabled = true;
            document.getElementById('dipole-readout').classList.add('visible');
            checkAdvance();
        }

        document.getElementById('slider-orbit').addEventListener('input', (e) => {
            state.angle = parseFloat(e.target.value);
            checkAdvance();
        });

        function togglePolarity() {
            state.sourcePolarity *= -1;

            // Update Visuals
            if (state.sourcePolarity === 1) {
                domeMat.emissive.setHex(0x222222); // Standard
                domeMat.color.setHex(0xcccccc);

                const ctx = labelVDG.material.map.image.getContext('2d');
                ctx.clearRect(0, 0, 256, 128);
                ctx.fillStyle = "#ff6b6b";
                ctx.fillText("VdG (+)", 128, 80);
                labelVDG.material.map.needsUpdate = true;
            } else {
                domeMat.emissive.setHex(0x001133); // Dark Blueish
                domeMat.color.setHex(0x54a0ff);

                const ctx = labelVDG.material.map.image.getContext('2d');
                ctx.clearRect(0, 0, 256, 128);
                ctx.fillStyle = "#54a0ff";
                ctx.fillText("VdG (-)", 128, 80);
                labelVDG.material.map.needsUpdate = true;
            }
            checkAdvance();
        }

        function resetSim() {
            state.dipoleVisible = false;
            state.sourcePolarity = 1; // reset to positive
            state.angle = 0;
            document.getElementById('slider-orbit').value = 0;

            dipoleGroup.visible = false;
            linesGroup.visible = false;

            document.getElementById('btn-intro').disabled = false;
            document.getElementById('dipole-readout').classList.remove('visible');

            // Reset label
            const ctx = labelVDG.material.map.image.getContext('2d');
            ctx.clearRect(0, 0, 256, 128);
            ctx.fillStyle = "#ff6b6b";
            ctx.fillText("VdG (+)", 128, 80);
            labelVDG.material.map.needsUpdate = true;
            domeMat.color.setHex(0xcccccc);

            loadLesson(0);
        }

        // --- LESSON CONTENT (First Principles) ---

        const lessons = [
            {
                title: "First Principles: The Setup",
                text: "We have a large conductor, the Van de Graaff Generator. It holds a massive net charge (Q).<br><br>First Principle: <strong>Charge alters the space around it.</strong><br><br>We cannot 'see' this alteration (the Electric Field) with our eyes. We need a tool that interacts with it. We will use a <strong>Dipole Probe</strong>â€”an insulating rod with opposite charges at the ends.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-intro');
                },
                check: () => state.dipoleVisible
            },
            {
                title: "Mechanism: Torque",
                text: "You have introduced the dipole. Observe its behavior.<br><br>The <strong style='color:#ff4757'>Red End (+)</strong> is repelled by the Positive VdG.<br>The <strong style='color:#2e86de'>Blue End (-)</strong> is attracted to it.<br><br>Because these forces act on opposite ends of a rigid rod, they create a <strong>Torque</strong>. The rod rotates until the forces align. This alignment reveals the direction of the invisible field lines.",
                setup: () => {
                    unlock('ctrl-orbit');
                    linesGroup.visible = true; // Reveal lines to show alignment
                },
                check: () => Math.abs(state.angle - 0) > 20 // User moved it
            },
            {
                title: "Mapping: Radial Geometry",
                text: "By moving the probe around the generator (<span class='instruction-inline'>Use the Slider</span>), we map the field geometry.<br><br>Notice that no matter where you stand, the dipole always points <strong>Radially</strong> (directly away from the center).<br><br>This confirms that the Electric Field of a sphere is spherically symmetric. The 'Fishing Rod' always points along the radius.",
                setup: () => {
                    // Just keep orbit unlocked
                },
                check: () => state.angle > 90 // User moved it significantly
            },
            {
                title: "Deducing Polarity",
                text: "This probe is useful for unknowns. What if we didn't know the VdG was positive?<br><br>If we swap the generator to <strong>Negative</strong>, the field vectors flip direction (pointing inward).<br><br>The Dipole obeys: The (+) end must point <em>with</em> the field (inward). Watch the probe flip 180Â° when you toggle the polarity. Now that we've mapped the field with a single probe, let's visualize the entire field at once using thousands of tiny probes: Grass Seeds.",
                setup: () => {
                    unlock('ctrl-polarity');
                },
                check: () => state.sourcePolarity === -1
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div>
             <div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');

            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }

            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.parent.location.href = '/lesson/dipole_grassfield';
            }
        }
        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }
        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        // Init
        loadLesson(0);

        // Resize Handle
        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * newAspect / 2;
            camera.right = viewSize * newAspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

    </script>
</body>

</html>

===== END OF 8_dipole_on_vandeGraff.html =====


===== START OF 9_dipole_on_grassfield.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>The Invisible Web: Grass Seed Experiment</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT (Identical to previous) --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        .math-block {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #333;
            color: #fff;
            text-align: center;
        }

        /* CONTROLS AREA */
        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        /* NAVIGATION FOOTER */
        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        /* NEXT BUTTON STYLING FIX */
        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            border: none;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
            transform: none;
            animation: none;
        }

        /* MAIN CANVAS */
        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }

        /* Specific tweaks for toggle buttons */
        .mode-toggle {
            display: flex;
            gap: 10px;
        }

        .mode-toggle button {
            flex: 1;
        }

        .mode-toggle button.selected {
            background: var(--accent);
            color: #111;
            border-color: var(--accent);
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Experiment: Dielectric Polarization</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- 1. Sprinkle Seeds -->
            <div class="control-row" id="ctrl-seeds">
                <label>Step 1: The Medium</label>
                <button id="btn-seeds" onclick="scatterSeeds()">Scatter Seeds</button>
            </div>

            <!-- 2. Apply Voltage -->
            <div class="control-row" id="ctrl-voltage">
                <label>Step 2: High Voltage Supply</label>
                <button id="btn-voltage" onclick="applyVoltage()">Engage Field</button>
            </div>

            <!-- 3. Configuration -->
            <div class="control-row" id="ctrl-config">
                <label>Step 3: Charge Configuration</label>
                <div class="mode-toggle">
                    <button id="btn-dipole" class="selected" onclick="setMode('dipole')">Dipole (+ / -)</button>
                    <button id="btn-repel" onclick="setMode('repel')">Repulsion (+ / +)</button>
                </div>
            </div>

            <!-- Reset -->
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Lab Safety</label>
                <button onclick="resetSim()">Clean Tray</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Insulating Oil Bath</div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const state = {
            seedsScattered: false,
            voltageOn: false,
            mode: 'dipole', // 'dipole' or 'repel'
            time: 0
        };

        const scene = new THREE.Scene();

        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 35;

        // Isometric-ish Orthographic Camera
        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );
        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('world').appendChild(renderer.domElement);

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // --- ENVIRONMENT ---

        // --- GROUND & FLOOR ---
        const tableGeo = new THREE.PlaneGeometry(100, 100);
        const tableMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
        const table = new THREE.Mesh(tableGeo, tableMat);
        table.rotation.x = -Math.PI / 2;
        table.position.y = -2;
        table.receiveShadow = true;
        scene.add(table);
        scene.background = new THREE.Color(0x151515);

        // The Petri Dish / Oil Tray
        const trayGroup = new THREE.Group();

        // Tray Bottom (Dark to make seeds pop)
        const trayGeo = new THREE.CylinderGeometry(14, 14, 0.5, 32);
        const trayMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.1, roughness: 0.2 });
        const tray = new THREE.Mesh(trayGeo, trayMat);
        tray.position.y = -0.25;
        tray.receiveShadow = true;
        trayGroup.add(tray);

        // The Oil (Glassy Surface)
        const oilGeo = new THREE.CylinderGeometry(13.8, 13.8, 0.1, 32);
        const oilMat = new THREE.MeshPhysicalMaterial({
            color: 0xffeeaa,
            transparent: true,
            opacity: 0.2,
            roughness: 0.1,
            metalness: 0,
            transmission: 0.5
        });
        const oil = new THREE.Mesh(oilGeo, oilMat);
        oil.position.y = 0.1;
        trayGroup.add(oil);

        // Rim
        const rimGeo = new THREE.TorusGeometry(14, 0.2, 8, 32);
        const rimMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
        const rim = new THREE.Mesh(rimGeo, rimMat);
        rim.rotation.x = Math.PI / 2;
        rim.position.y = 0.2;
        trayGroup.add(rim);

        scene.add(trayGroup);

        // --- ELECTRODES ---
        const electrodeGroup = new THREE.Group();

        function createElectrode(x, colorHex, labelText) {
            const grp = new THREE.Group();

            // Rod
            const rodGeo = new THREE.CylinderGeometry(0.2, 0.2, 4, 8);
            const rodMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.3 });
            const rod = new THREE.Mesh(rodGeo, rodMat);
            rod.position.y = 2;
            grp.add(rod);

            // Sphere (Charge)
            const sphereGeo = new THREE.SphereGeometry(1, 16, 16);
            const sphereMat = new THREE.MeshStandardMaterial({ color: colorHex, emissive: colorHex, emissiveIntensity: 0.2 });
            const sphere = new THREE.Mesh(sphereGeo, sphereMat);
            sphere.castShadow = true;
            sphere.position.y = 0; // In the oil
            grp.add(sphere);

            // Label
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 80px Arial';
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.fillText(labelText, 64, 90);
            const tex = new THREE.CanvasTexture(canvas);
            const sprMat = new THREE.SpriteMaterial({ map: tex });
            const sprite = new THREE.Sprite(sprMat);
            sprite.position.set(0, 3.5, 0);
            sprite.scale.set(2, 2, 1);
            grp.add(sprite);

            grp.position.set(x, 0.5, 0);
            return grp;
        }

        const leftElectrode = createElectrode(-7, 0xff5555, "+"); // Always positive
        const rightElectrode = createElectrode(7, 0x5555ff, "-"); // Swaps based on mode
        electrodeGroup.add(leftElectrode);
        electrodeGroup.add(rightElectrode);
        scene.add(electrodeGroup);

        // --- GRASS SEEDS ---
        // We will use standard Meshes stored in an array for simplicity of logic updates
        // (InstancedMesh is faster but logic is slightly more complex for tutorial code)
        const seeds = [];
        const seedGroup = new THREE.Group();
        scene.add(seedGroup);

        function createSeed() {
            // Geometry: Elongated "rice" shape
            const geo = new THREE.BoxGeometry(0.6, 0.1, 0.1);
            const mat = new THREE.MeshStandardMaterial({ color: 0xeebb44, flatShading: true });
            const mesh = new THREE.Mesh(geo, mat);

            // Random Position in Circle
            let r = 13 * Math.sqrt(Math.random());
            let theta = Math.random() * 2 * Math.PI;

            mesh.position.x = r * Math.cos(theta);
            mesh.position.z = r * Math.sin(theta);
            mesh.position.y = 0.2; // Float on oil

            // Check collision with electrodes
            const distL = new THREE.Vector3(-7, 0, 0).distanceTo(mesh.position);
            const distR = new THREE.Vector3(7, 0, 0).distanceTo(mesh.position);

            if (distL < 1.5 || distR < 1.5) return null; // Dont place inside electrode

            // Random initial rotation
            mesh.rotation.y = Math.random() * Math.PI * 2;

            // Store velocity for Brownian motion simulation
            mesh.userData = {
                rotVel: (Math.random() - 0.5) * 0.05
            };

            return mesh;
        }

        function scatterSeeds() {
            // Clear old
            while (seedGroup.children.length > 0) {
                seedGroup.remove(seedGroup.children[0]);
            }
            seeds.length = 0;

            // Create new
            for (let i = 0; i < 600; i++) {
                const seed = createSeed();
                if (seed) {
                    seedGroup.add(seed);
                    seeds.push(seed);
                }
            }
            state.seedsScattered = true;
            checkAdvance();
        }


        // ==========================================
        // PART 2: PHYSICS LOOP
        // ==========================================

        function getFieldVector(pos) {
            // We add a tiny offset to denominators to prevent division by zero/infinity
            const k = 100; // Constant multiplier
            const minDist = 0.5; // Prevent singularity

            // 1. Left Charge (+Q)
            const q1 = 50;
            const p1 = new THREE.Vector3(-7, 0, 0);
            const r1_vec = new THREE.Vector3().subVectors(pos, p1);
            const r1_len = r1_vec.length();
            // E = kQ/r^2
            // Scale down intensity slightly for visual clarity
            const mag1 = k * q1 / (Math.max(r1_len, minDist) ** 2);
            const E1 = r1_vec.normalize().multiplyScalar(mag1);

            // 2. Right Charge (+Q or -Q)
            const q2 = (state.mode === 'dipole') ? -50 : 50;
            const p2 = new THREE.Vector3(7, 0, 0);
            const r2_vec = new THREE.Vector3().subVectors(pos, p2);
            const r2_len = r2_vec.length();
            const mag2 = k * Math.abs(q2) / (Math.max(r2_len, minDist) ** 2);
            // Note: Multiply by sign of q2 manually to keep direction logic clear
            const dir2 = r2_vec.normalize();
            if (q2 < 0) dir2.negate(); // If negative, vector points TOWARDS charge

            const E2 = dir2.multiplyScalar(mag2);

            // Superposition
            return new THREE.Vector3().addVectors(E1, E2);
        }

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.01;

            if (state.seedsScattered) {
                seeds.forEach(seed => {
                    if (state.voltageOn) {
                        // FIELD ON: Align with field

                        const E = getFieldVector(seed.position);
                        const fieldStrength = E.length(); // Get Magnitude

                        // --- PHYSICS FIX ---
                        // Only apply alignment if field is strong enough to overcome "friction"
                        // In the dead zone of Repulsion, fieldStrength approaches 0.

                        if (fieldStrength > 0.1) {
                            const targetAngle = Math.atan2(E.z, E.x);

                            let current = seed.rotation.y;

                            // Angle normalization
                            let diff = targetAngle - current;
                            while (diff > Math.PI) diff -= Math.PI * 2;
                            while (diff < -Math.PI) diff += Math.PI * 2;

                            // Symmetric alignment (Head or Tail)
                            if (Math.abs(diff) > Math.PI / 2) {
                                if (diff > 0) diff -= Math.PI;
                                else diff += Math.PI;
                            }

                            // Apply torque based on Field Strength
                            // Stronger field = faster/tighter alignment
                            // We clamp the speed so they don't spin uncontrollably near poles
                            const torque = Math.min(fieldStrength * 0.05, 0.2);

                            seed.rotation.y += diff * torque;
                        }
                        // If fieldStrength is < 0.1 (The Dead Zone), the seed 
                        // stays at its random rotation (Chaos/Entropy).

                    } else {
                        // FIELD OFF: Brownian Motion
                        seed.rotation.y += seed.userData.rotVel;
                        seed.userData.rotVel *= 0.99;
                        if (Math.random() > 0.95) seed.userData.rotVel += (Math.random() - 0.5) * 0.01;
                    }
                });
            }

            // Pulse Effect
            if (state.voltageOn) {
                const scale = 1 + Math.sin(state.time * 10) * 0.05;
                leftElectrode.children[1].scale.set(scale, scale, scale);
                rightElectrode.children[1].scale.set(scale, scale, scale);
            } else {
                leftElectrode.children[1].scale.set(1, 1, 1);
                rightElectrode.children[1].scale.set(1, 1, 1);
            }

            renderer.render(scene, camera);
        }
        animate();

        // ==========================================
        // PART 3: LOGIC & NARRATIVE
        // ==========================================

        let currentChapter = 0;

        function applyVoltage() {
            if (!state.seedsScattered) return;
            state.voltageOn = !state.voltageOn; // Toggle

            const btn = document.getElementById('btn-voltage');
            if (state.voltageOn) {
                btn.innerText = "Cut Power";
                btn.style.borderColor = "#ff5555";
                btn.style.color = "#ff5555";
            } else {
                btn.innerText = "Engage Field";
                btn.style.borderColor = "#3d4450";
                btn.style.color = "#aaa";
            }
            checkAdvance();
        }

        function setMode(mode) {
            state.mode = mode;

            // Update Buttons
            document.getElementById('btn-dipole').classList.toggle('selected', mode === 'dipole');
            document.getElementById('btn-repel').classList.toggle('selected', mode === 'repel');

            // Update Visuals (Right Electrode Color)
            const rightSphere = rightElectrode.children[1];
            const rightLabel = rightElectrode.children[2]; // Sprite

            if (mode === 'dipole') {
                // Blue (-)
                rightSphere.material.color.setHex(0x5555ff);
                rightSphere.material.emissive.setHex(0x5555ff);

                // Update Label text
                const ctx = rightLabel.material.map.image.getContext('2d');
                ctx.clearRect(0, 0, 128, 128);
                ctx.fillStyle = "white"; ctx.textAlign = "center"; ctx.fillText("-", 64, 90);
                rightLabel.material.map.needsUpdate = true;

            } else {
                // Red (+)
                rightSphere.material.color.setHex(0xff5555);
                rightSphere.material.emissive.setHex(0xff5555);

                // Update Label text
                const ctx = rightLabel.material.map.image.getContext('2d');
                ctx.clearRect(0, 0, 128, 128);
                ctx.fillStyle = "white"; ctx.textAlign = "center"; ctx.fillText("+", 64, 90);
                rightLabel.material.map.needsUpdate = true;
            }
            checkAdvance();
        }

        function resetSim() {
            state.seedsScattered = false;
            state.voltageOn = false;
            state.mode = 'dipole';

            // Reset Visuals
            while (seedGroup.children.length > 0) seedGroup.remove(seedGroup.children[0]);
            seeds.length = 0;

            document.getElementById('btn-voltage').innerText = "Engage Field";
            document.getElementById('btn-voltage').style.color = "#aaa";
            document.getElementById('btn-voltage').style.borderColor = "#3d4450";

            setMode('dipole');
            loadLesson(0);
        }

        // --- LESSON CONTENT ---

        const lessons = [
            {
                title: "The Chaos of Entropy",
                text: "To visualize the invisible electric field, we need a medium. We have filled a tray with insulating oil and will scatter <strong>grass seeds</strong> on top.<br><br>Grass seeds are insulators, not conductors. They are currently uncharged and oriented randomly due to entropy.<br><br><span class='instruction-inline'>Click 'SCATTER SEEDS'</span> to prepare the tray.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-seeds');
                },
                check: () => state.seedsScattered
            },
            {
                title: "First Principles: Polarization",
                text: "When we apply high voltage, we create an <strong>Electric Field (E)</strong>.<br><br>Even though the seeds are neutral, the field pulls positive charges within the seed one way, and negative charges the other. This creates a <strong>Induced Dipole</strong>.<br><br>The field then exerts <strong>Torque</strong> on these poles, twisting the seed until it aligns with the field lines.<br><br><span class='instruction-inline'>Click 'ENGAGE FIELD'</span> to observe.",
                setup: () => {
                    unlock('ctrl-voltage');
                },
                check: () => state.voltageOn
            },
            {
                title: "Dipole Configuration",
                text: "You are looking at the field of a <strong>Dipole</strong> (One positive, one negative).<br><br>Notice the arches? The field lines leave the positive charge and terminate on the negative charge. The seeds trace this path because it is the path of least energy.<br><br>The lines are densest near the charges, indicating the field is strongest there.",
                setup: () => {
                    unlock('ctrl-config');
                },
                check: () => true // Just needs to read
            },
            {
                title: "Repulsion",
                text: "Now, let's see what happens when forces collide.<br><br><span class='instruction-inline'>Click 'REPULSION (+ / +)'</span>.<br><br>Both charges are now positive. Field lines cannot cross. Instead, they push against each other, creating a 'dead zone' in the center where the net field is zero. The seeds here have no direction to point. We've seen how fields affect solids. Now, let's see how they affect liquids. Get ready to bend water.",
                setup: () => {
                    unlock('ctrl-config');
                },
                check: () => state.mode === 'repel'
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Observation ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div>
             <div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');

            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }

            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.parent.location.href = '/lesson/dipole_water';
            }
        }
        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }
        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        // Init
        loadLesson(0);

        window.addEventListener('resize', () => {
            aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * aspect / 2;
            camera.right = viewSize * aspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

    </script>
</body>

</html>

===== END OF 9_dipole_on_grassfield.html =====


===== START OF galaxy_landing.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Apple Falls | Cosmic Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #050505;
            --glass-bg: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.05);
            --accent: #a29bfe;
            --accent-glow: #6c5ce7;
            --text: #ffffff;
            --text-dim: #a0a0a0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Outfit', sans-serif;
            overflow-x: hidden;
        }

        a {
            text-decoration: none;
            color: inherit;
        }

        /* NAVIGATION */
        nav {
            position: fixed;
            top: 0;
            width: 100%;
            padding: 25px 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            background: rgba(5, 5, 5, 0.2);
            backdrop-filter: blur(15px);
            border-bottom: 1px solid var(--glass-border);
        }

        .logo {
            font-weight: 800;
            font-size: 24px;
            letter-spacing: -0.5px;
            background: linear-gradient(to right, #fff, #a29bfe);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .nav-links {
            display: flex;
            gap: 40px;
        }

        .nav-links a {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-dim);
            transition: color 0.3s, text-shadow 0.3s;
        }

        .nav-links a:hover {
            color: #fff;
            text-shadow: 0 0 10px var(--accent-glow);
        }

        /* HERO SECTION */
        #hero {
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            position: relative;
            z-index: 10;
            pointer-events: none;
            /* Let clicks pass through to canvas if needed, but buttons need pointer-events: auto */
        }

        #hero>* {
            pointer-events: auto;
        }

        #hero h1 {
            font-size: 90px;
            font-weight: 800;
            line-height: 1.1;
            margin-bottom: 20px;
            background: linear-gradient(to bottom, #fff, #a29bfe);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            opacity: 0;
            transform: translateY(30px);
            text-shadow: 0 0 30px rgba(162, 155, 254, 0.3);
        }

        #hero p {
            font-size: 22px;
            color: var(--text-dim);
            max-width: 700px;
            margin-bottom: 50px;
            opacity: 0;
            transform: translateY(30px);
            font-weight: 300;
        }

        .cta-button {
            padding: 18px 50px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-weight: 600;
            border-radius: 50px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.3s;
            opacity: 0;
            transform: translateY(30px);
            backdrop-filter: blur(10px);
            font-size: 16px;
            letter-spacing: 0.5px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .cta-button:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
            box-shadow: 0 0 40px var(--accent-glow);
            transform: scale(1.05);
        }

        /* BACKGROUND CANVAS */
        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* SECTIONS */
        section {
            position: relative;
            z-index: 10;
            padding: 120px 40px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .section-header {
            margin-bottom: 80px;
            text-align: center;
        }

        .section-header h2 {
            font-size: 48px;
            margin-bottom: 15px;
            background: linear-gradient(to right, #fff, #a29bfe);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .section-header p {
            color: var(--text-dim);
            font-size: 18px;
        }

        /* CARDS */
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 40px;
        }

        .card {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            padding: 40px;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: pointer;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(20px);
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.03), transparent);
            transform: translateX(-100%);
            transition: 0.5s;
        }

        .card:hover::before {
            transform: translateX(100%);
        }

        .card:hover {
            transform: translateY(-10px);
            border-color: var(--accent);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .card-number {
            font-family: 'Outfit', sans-serif;
            font-weight: 800;
            font-size: 14px;
            color: var(--accent);
            margin-bottom: 20px;
            display: inline-block;
            padding: 5px 12px;
            background: rgba(162, 155, 254, 0.1);
            border-radius: 20px;
            border: 1px solid rgba(162, 155, 254, 0.2);
        }

        .card h3 {
            font-size: 28px;
            margin-bottom: 15px;
            color: #fff;
        }

        .card p {
            color: var(--text-dim);
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 30px;
        }

        .card-link {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0.8;
            transition: opacity 0.3s;
        }

        .card:hover .card-link {
            opacity: 1;
        }

        .card-link::after {
            content: 'â†’';
            transition: transform 0.3s;
        }

        .card:hover .card-link::after {
            transform: translateX(5px);
        }

        /* FOOTER */
        footer {
            position: relative;
            z-index: 10;
            padding: 80px 40px;
            text-align: center;
            border-top: 1px solid var(--glass-border);
            color: var(--text-dim);
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }

        /* RESPONSIVE */
        @media (max-width: 768px) {
            #hero h1 {
                font-size: 50px;
            }

            nav {
                padding: 20px;
            }

            .nav-links {
                display: none;
            }
        }
    </style>
</head>

<body>

    <canvas id="bg-canvas"></canvas>

    <nav>
        <div class="logo">The Apple Falls</div>
        <div class="nav-links">
            <a href="#hero">Cosmos</a>
            <a href="#modules">Simulations</a>
            <a href="#">Journal</a>
        </div>
    </nav>

    <header id="hero">
        <h1>Physics from<br>Stardust.</h1>
        <p>Explore the fundamental forces that bind the galaxy together. <br>Interactive simulations powered by first
            principles.</p>
        <button class="cta-button"
            onclick="document.getElementById('modules').scrollIntoView({behavior: 'smooth'})">Begin Journey</button>
    </header>

    <section id="modules">
        <div class="section-header">
            <h2>Exploration Modules</h2>
            <p>Choose your destination in the electromagnetic spectrum.</p>
        </div>

        <div class="grid">
            <!-- Card 1 -->
            <div class="card" onclick="window.location.href='intro_to_electricfeld.html'">
                <span class="card-number">01</span>
                <h3>Electric Fields</h3>
                <p>Visualize the invisible web of forces. Interactive Coulomb's Law and superposition experiments.</p>
                <div class="card-link">Launch Simulation</div>
            </div>

            <!-- Card 2 -->
            <div class="card" onclick="window.location.href='vec_addition.html'">
                <span class="card-number">02</span>
                <h3>Vector Math</h3>
                <p>Master the language of space. 3D vector addition and manipulation tools.</p>
                <div class="card-link">Launch Simulation</div>
            </div>

            <!-- Card 3 -->
            <div class="card" onclick="window.location.href='4_field_lines.html'">
                <span class="card-number">03</span>
                <h3>Field Lines</h3>
                <p>Trace the flow of power. Complex charge distributions and field mapping.</p>
                <div class="card-link">Launch Simulation</div>
            </div>

            <!-- Card 4 -->
            <div class="card" onclick="window.location.href='6_dipole.html'">
                <span class="card-number">04</span>
                <h3>The Dipole</h3>
                <p>The duality of nature. Explore the fundamental building block of matter.</p>
                <div class="card-link">Launch Simulation</div>
            </div>

            <!-- Card 5 -->
            <div class="card" onclick="window.location.href='7_creating_a_dipole(induction).html'">
                <span class="card-number">05</span>
                <h3>Induction</h3>
                <p>Action at a distance. How conductors respond to external fields.</p>
                <div class="card-link">Launch Simulation</div>
            </div>

            <!-- Card 6 -->
            <div class="card" onclick="window.location.href='8_dipole_on_vandeGraff.html'">
                <span class="card-number">06</span>
                <h3>Van de Graaff</h3>
                <p>High voltage phenomena. Breakdown, discharge, and electrostatic limits.</p>
                <div class="card-link">Launch Simulation</div>
            </div>
        </div>
    </section>

    <footer>
        &copy; 2025 The Apple Falls. <br>Designed for the curious mind.
    </footer>

    <script>
        // ==========================================
        // GALAXY BACKGROUND (Three.js)
        // ==========================================
        const canvas = document.getElementById('bg-canvas');
        const scene = new THREE.Scene();

        // Fog for depth
        scene.fog = new THREE.FogExp2(0x050505, 0.05);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // GALAXY PARAMETERS
        const parameters = {
            count: 15000,
            size: 0.01,
            radius: 5,
            branches: 3,
            spin: 1,
            randomness: 0.2,
            randomnessPower: 3,
            insideColor: '#ff6030',
            outsideColor: '#1b3984'
        };

        let geometry = null;
        let material = null;
        let points = null;

        const generateGalaxy = () => {
            if (points !== null) {
                geometry.dispose();
                material.dispose();
                scene.remove(points);
            }

            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(parameters.count * 3);
            const colors = new Float32Array(parameters.count * 3);

            const colorInside = new THREE.Color(parameters.insideColor);
            const colorOutside = new THREE.Color(parameters.outsideColor);

            for (let i = 0; i < parameters.count; i++) {
                const i3 = i * 3;

                // Position
                const radius = Math.random() * parameters.radius;
                const spinAngle = radius * parameters.spin;
                const branchAngle = (i % parameters.branches) / parameters.branches * Math.PI * 2;

                const randomX = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * parameters.randomness * radius;
                const randomY = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * parameters.randomness * radius;
                const randomZ = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * parameters.randomness * radius;

                positions[i3] = Math.cos(branchAngle + spinAngle) * radius + randomX;
                positions[i3 + 1] = randomY; // Flattened galaxy
                positions[i3 + 2] = Math.sin(branchAngle + spinAngle) * radius + randomZ;

                // Color
                const mixedColor = colorInside.clone();
                mixedColor.lerp(colorOutside, radius / parameters.radius);

                colors[i3] = mixedColor.r;
                colors[i3 + 1] = mixedColor.g;
                colors[i3 + 2] = mixedColor.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            material = new THREE.PointsMaterial({
                size: parameters.size,
                sizeAttenuation: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                vertexColors: true
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);
        };

        generateGalaxy();

        // Stars Background
        const starsGeometry = new THREE.BufferGeometry();
        const starsCount = 2000;
        const starsPos = new Float32Array(starsCount * 3);

        for (let i = 0; i < starsCount * 3; i++) {
            starsPos[i] = (Math.random() - 0.5) * 30;
        }

        starsGeometry.setAttribute('position', new THREE.BufferAttribute(starsPos, 3));
        const starsMaterial = new THREE.PointsMaterial({
            size: 0.02,
            color: 0xffffff,
            transparent: true,
            opacity: 0.4
        });
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);


        camera.position.x = 0;
        camera.position.y = 3;
        camera.position.z = 4;
        camera.lookAt(0, 0, 0);

        // Mouse Interaction
        let mouseX = 0;
        let mouseY = 0;
        let targetX = 0;
        let targetY = 0;

        const windowHalfX = window.innerWidth / 2;
        const windowHalfY = window.innerHeight / 2;

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX - windowHalfX);
            mouseY = (event.clientY - windowHalfY);
        });

        // Animation
        const clock = new THREE.Clock();

        function animate() {
            const elapsedTime = clock.getElapsedTime();

            // Rotate Galaxy
            points.rotation.y = elapsedTime * 0.05;
            stars.rotation.y = elapsedTime * 0.01;

            // Mouse Parallax
            targetX = mouseX * 0.001;
            targetY = mouseY * 0.001;

            points.rotation.x += 0.05 * (targetY - points.rotation.x);
            points.rotation.y += 0.05 * (targetX - points.rotation.y);

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });


        // ==========================================
        // GSAP ANIMATIONS
        // ==========================================
        gsap.registerPlugin(ScrollTrigger);

        // Hero Animations
        const tl = gsap.timeline();
        tl.to("#hero h1", { opacity: 1, y: 0, duration: 1.2, ease: "power3.out" })
            .to("#hero p", { opacity: 1, y: 0, duration: 1, ease: "power3.out" }, "-=0.8")
            .to(".cta-button", { opacity: 1, y: 0, duration: 1, ease: "back.out(1.7)" }, "-=0.6");

        // Scroll Animations
        gsap.utils.toArray('.card').forEach((card, i) => {
            gsap.from(card, {
                scrollTrigger: {
                    trigger: card,
                    start: "top 95%",
                },
                opacity: 0,
                y: 50,
                duration: 0.8,
                delay: i * 0.1,
                ease: "power2.out"
            });
        });

    </script>
</body>

</html>

===== END OF galaxy_landing.html =====


===== START OF intro_to_electricfeld.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>The Invisible Web: Electric Fields</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        .math-block {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #333;
            color: #fff;
            text-align: center;
        }

        /* CONTROLS AREA */
        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
            height: 6px;
            background: #333;
            border-radius: 3px;
        }

        /* NAVIGATION FOOTER */
        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        /* NEXT BUTTON STYLING FIX */
        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            border: none;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
            transform: none;
            animation: none;
        }

        /* MAIN CANVAS */
        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        /* TAGS IN SCENE */
        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Simulation: Defining The Field</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- 1. Introduce Test Charge -->
            <div class="control-row" id="ctrl-intro">
                <label>Step 1: The Probe</label>
                <button id="btn-intro" onclick="introduceTestCharge()">Place Test Charge (q)</button>
            </div>

            <!-- 2. Slider -->
            <div class="control-row" id="ctrl-move">
                <label>Step 2: Distance (r)</label>
                <input type="range" id="slider-dist" min="5" max="30" value="15" step="0.1">
            </div>

            <!-- 3. Divide by q -->
            <div class="control-row" id="ctrl-field">
                <label>Step 3: The Definition</label>
                <button id="btn-field" onclick="toggleFieldMode()">Divide by 'q' (Show E)</button>
            </div>

            <!-- Reset -->
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Experiment Control</label>
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Vacuum Space</div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const state = {
            testChargeVisible: false,
            fieldMode: false,
            distance: 15,
            time: 0
        };

        const scene = new THREE.Scene();

        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 40;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );

        camera.position.set(20, 25, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('world').appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // Floor
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({
            color: 0x222222,
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -10;
        floor.receiveShadow = true;
        scene.background = new THREE.Color(0x151515);

        // Grid Helper
        const gridHelper = new THREE.GridHelper(100, 20, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -9.9;
        scene.add(floor);
        scene.add(gridHelper);

        // --- OBJECTS ---

        // 1. Source Charge (Q) - Big Red
        const sourceGroup = new THREE.Group();
        const sourceGeo = new THREE.IcosahedronGeometry(3, 1);
        const sourceMat = new THREE.MeshStandardMaterial({ color: 0xff6b6b, flatShading: true, emissive: 0x550000 });
        const sourceMesh = new THREE.Mesh(sourceGeo, sourceMat);
        sourceMesh.castShadow = true;
        sourceGroup.add(sourceMesh);

        // Label Q
        function createTextSprite(text, scale) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128; // Higher res
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 50px Arial';
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.fillText(text, 128, 80);
            const tex = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: tex, depthTest: false }); // depthTest false to see through objects if needed
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(scale * 2, scale, 1);
            sprite.renderOrder = 100;
            return sprite;
        }
        const labelQ = createTextSprite("Q (+)", 4);
        labelQ.position.y = 5;
        sourceGroup.add(labelQ);
        scene.add(sourceGroup);

        // 2. Test Charge (q) - Small Yellow
        const testGroup = new THREE.Group();
        const testGeo = new THREE.IcosahedronGeometry(0.8, 0);
        const testMat = new THREE.MeshStandardMaterial({ color: 0xfeca57, flatShading: true, emissive: 0x554400 });
        const testMesh = new THREE.Mesh(testGeo, testMat);
        testMesh.castShadow = true;
        testGroup.add(testMesh);

        const labelq = createTextSprite("q (+)", 3);
        labelq.position.y = 2;
        testGroup.add(labelq);
        scene.add(testGroup);
        testGroup.visible = false;

        // 3. Vector Arrow (The Force/Field)
        // Structure: arrowGroup (Pos/Rot) -> arrowVisuals (Scale) -> Mesh
        const arrowGroup = new THREE.Group();
        const arrowVisuals = new THREE.Group();
        arrowGroup.add(arrowVisuals);

        // Build Arrow Geometry facing +X
        const shaftGeo = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
        shaftGeo.translate(0, 0.5, 0); // Pivot at bottom
        shaftGeo.rotateZ(-Math.PI / 2);  // Point +X
        const shaftMat = new THREE.MeshStandardMaterial({ color: 0x54a0ff });
        const shaft = new THREE.Mesh(shaftGeo, shaftMat);

        const headGeo = new THREE.ConeGeometry(0.5, 1, 8);
        headGeo.rotateZ(-Math.PI / 2);   // Point +X
        headGeo.translate(1, 0, 0);    // Place at end of shaft length 1
        const headMat = new THREE.MeshStandardMaterial({ color: 0x54a0ff });
        const head = new THREE.Mesh(headGeo, headMat);

        arrowVisuals.add(shaft);
        arrowVisuals.add(head);

        // Label F (Not inside arrowVisuals, so it doesn't squash)
        const labelF = createTextSprite("F", 3);
        labelF.position.set(0, 2, 0);
        arrowGroup.add(labelF);

        scene.add(arrowGroup);
        arrowGroup.visible = false;

        // 4. Field Array (Visualizing E)
        const fieldVectors = [];
        const fieldGroup = new THREE.Group();
        scene.add(fieldGroup);

        function createFieldVector(pos) {
            const grp = new THREE.Group();
            // Simplified arrow
            const sGeo = new THREE.CylinderGeometry(0.1, 0.1, 1, 4);
            sGeo.translate(0, 0.5, 0);
            sGeo.rotateZ(-Math.PI / 2);
            const sMat = new THREE.MeshBasicMaterial({ color: 0x54a0ff, transparent: true, opacity: 0.5 });
            const s = new THREE.Mesh(sGeo, sMat);

            const hGeo = new THREE.ConeGeometry(0.3, 0.6, 4);
            hGeo.rotateZ(-Math.PI / 2);
            hGeo.translate(1, 0, 0);
            const hMat = new THREE.MeshBasicMaterial({ color: 0x54a0ff, transparent: true, opacity: 0.5 });
            const h = new THREE.Mesh(hGeo, hMat);

            const subGrp = new THREE.Group(); // Scale this subgrp
            subGrp.add(s, h);
            grp.add(subGrp);
            grp.userData = { visuals: subGrp }; // Reference for scaling

            grp.position.copy(pos);

            // Align +X to radial direction
            const dir = pos.clone().normalize();
            const axisX = new THREE.Vector3(1, 0, 0);
            const quat = new THREE.Quaternion().setFromUnitVectors(axisX, dir);
            grp.rotation.setFromQuaternion(quat);

            return grp;
        }

        // Generate circular field pattern
        for (let r = 6; r < 25; r += 6) {
            const count = r * 1.5;
            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2;
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                const v = createFieldVector(new THREE.Vector3(x, 0, z));
                v.userData.r = r;
                fieldGroup.add(v);
                fieldVectors.push(v);
            }
        }
        fieldGroup.visible = false;


        // ==========================================
        // PART 2: ANIMATION LOOP
        // ==========================================

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.02;

            // Bobbing effect
            sourceMesh.position.y = Math.sin(state.time) * 0.2;
            labelQ.position.y = 5 + Math.sin(state.time) * 0.2;

            // Update Test Charge Position
            const dist = state.distance;
            testGroup.position.set(dist, 0, 0);

            // Calculate Magnitude (Simulated Coulomb 1/r^2)
            const strength = 1500 / (dist * dist);

            // Update Arrow (Force or Field)
            if (state.testChargeVisible || state.fieldMode) {
                arrowGroup.visible = true;
                arrowGroup.position.copy(testGroup.position);

                // 1. Correct Orientation (Align +X Arrow with Radial Vector)
                // Vector from Source -> Test
                const direction = new THREE.Vector3().subVectors(testGroup.position, sourceGroup.position).normalize();
                // Create Quaternion to rotate (1,0,0) to 'direction'
                const axisX = new THREE.Vector3(1, 0, 0);
                const quat = new THREE.Quaternion().setFromUnitVectors(axisX, direction);
                arrowGroup.quaternion.copy(quat);

                // 2. Scale Visuals (Not the Group)
                let scale = Math.min(strength, 10);
                scale = Math.max(scale, 1.5);

                // Scale the mesh only, so label doesn't distort
                arrowVisuals.scale.set(scale, 1, 1);

                // 3. Move Label to midpoint of arrow
                // Since arrow is +X, midpoint is scale/2
                labelF.position.set(scale / 2, 2, 0);

            } else {
                arrowGroup.visible = false;
            }

            // Field Vectors Update
            if (state.fieldMode) {
                fieldVectors.forEach(v => {
                    const r = v.userData.r;
                    const fieldStr = 500 / (r * r);
                    let s = Math.min(fieldStr, 4);
                    s = Math.max(s, 0.5);
                    v.userData.visuals.scale.set(s, 1, 1);
                });
                sourceMesh.rotation.y += 0.005;
                sourceMesh.rotation.z += 0.005;
            }

            renderer.render(scene, camera);
        }
        animate();

        // ==========================================
        // PART 3: LOGIC & NARRATIVE
        // ==========================================

        let currentChapter = 0;

        function introduceTestCharge() {
            state.testChargeVisible = true;
            testGroup.visible = true;
            document.getElementById('btn-intro').disabled = true;
            document.getElementById('btn-intro').innerText = "Probe Active";
            checkAdvance();
        }

        document.getElementById('slider-dist').addEventListener('input', (e) => {
            state.distance = parseFloat(e.target.value);
            checkAdvance();
        });

        function toggleFieldMode() {
            state.fieldMode = true;

            // Hide test charge
            testGroup.visible = false;

            // Show Field Lines
            fieldGroup.visible = true;

            // Change Arrow Label
            const canvas = labelF.material.map.image;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 256, 128);
            ctx.fillStyle = "#54a0ff";
            ctx.textAlign = "center";
            ctx.fillText("E", 128, 80);
            labelF.material.map.needsUpdate = true;

            document.getElementById('btn-field').disabled = true;
            checkAdvance();
        }

        function resetSim() {
            state.testChargeVisible = false;
            state.fieldMode = false;
            state.distance = 15;

            testGroup.visible = false;
            fieldGroup.visible = false;

            document.getElementById('slider-dist').value = 15;

            // Reset buttons
            const btnI = document.getElementById('btn-intro');
            btnI.disabled = false;
            btnI.innerText = "Place Test Charge (q)";

            const btnF = document.getElementById('btn-field');
            btnF.disabled = false;

            // Reset Label F
            const canvas = labelF.material.map.image;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 256, 128);
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.fillText("F", 128, 80);
            labelF.material.map.needsUpdate = true;

            loadLesson(0);
        }

        // --- LESSON CONTENT ---

        const lessons = [
            {
                title: "Introduction: The Source",
                title: "Introduction: The Source",
                text: "In the previous module, we discovered Coulomb's Law: charges exert force on each other across space. But *how*? How does one particle 'know' the other is there? We now introduce the concept of the **Electric Field**.<br><br>We begin with a single Source Charge (<strong style='color:#ff6b6b'>Q</strong>). It sits in empty space. Does it affect the space around it? Right now, it's hard to tell because there is nothing else here to react to it.<br><br>To map the influence of Q, we need a probe. <span class='instruction-inline'>Click 'PLACE TEST CHARGE'</span>.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-intro');
                },
                check: () => state.testChargeVisible
            },
            {
                title: "Coulomb's Law",
                text: "We have placed a small positive <strong>Test Charge (q)</strong> nearby. According to Coulomb's Law, they repel. The <strong style='color:#54a0ff'>Blue Arrow (F)</strong> represents this Force vector.<br><br><div class='math-block'>F = k * (Q * q) / rÂ²</div><br><span style='font-size:0.9em; color:#aab; border-left: 2px solid #555; padding-left:10px; display:block; margin-bottom:10px;'><strong>Note:</strong> Newton's 3rd Law applies! The Source (Q) experiences this exact same force in the opposite direction. However, since Q is fixed in place for this simulation, we focus on the effect on q.</span><span class='instruction-inline'>Move the slider</span> to change distance (r).",
                setup: () => {
                    unlock('ctrl-move');
                },
                check: () => Math.abs(state.distance - 15) > 2
            },
            {
                title: "Defining the Field",
                text: "Notice that the Force depends on two things: the Source (Q) and the Test Charge (q).<br><br>But we want to define a property that belongs <em>only</em> to the Source. We want to know how strong the 'push' is at this location, regardless of what we put there.<br><br>To do this, we divide out the test charge:<br><div class='math-block'>E = F / q</div><br><span class='instruction-inline'>Click 'DIVIDE BY q'</span> to perform this mathematical abstraction.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-field');
                },
                check: () => state.fieldMode
            },
            {
                title: "The Electric Field (E)",
                text: "The test charge is gone, but the vector remains. This is no longer Force (F); it is the <strong>Electric Field (E)</strong>.<br><br><strong>Key Properties:</strong><br>1. <strong>Vector Quantity:</strong> It has magnitude and direction.<br>2. <strong>Convention:</strong> The direction is defined as the force <em>on a positive test charge</em> (away from positive, toward negative).<br><br>The grid shows us that this field exists everywhere in space, surrounding Q like an invisible web. But how do we represent this mathematically and visually? In the next lesson, we will explore the language of vectors.",
                setup: () => {
                    unlock('ctrl-move');
                },
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div>
             <div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');

            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }

            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.parent.location.href = '/lesson/vector';
            }
        }
        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }
        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        // Init
        loadLesson(0);

        // Resize Handle
        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * newAspect / 2;
            camera.right = viewSize * newAspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

    </script>
</body>

</html>

===== END OF intro_to_electricfeld.html =====


===== START OF vec_addition.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Maxwell's Notebook: Superposition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        /* Highlighted instructions in text */
        .instruction-highlight {
            display: block;
            margin-top: 15px;
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 8px 12px;
            border-radius: 4px;
            border-left: 2px solid var(--accent);
            font-size: 13px;
        }

        .math-block {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #333;
            color: #fff;
            text-align: center;
        }

        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
            height: 6px;
            background: #333;
            border-radius: 3px;
        }

        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        /* NEXT BUTTON STYLING FIX */
        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            border: none;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
            transform: none;
            animation: none;
        }

        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }

        #legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
            color: #ccc;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Simulation: Vector Addition</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- 1. Add Q2 -->
            <div class="control-row" id="ctrl-add-q2">
                <label>Step 1: The Second Source</label>
                <button id="btn-add-q2" onclick="introduceQ2()">Introduce Negative Charge (Qâ‚‚)</button>
            </div>

            <!-- 2. Show Sum -->
            <div class="control-row" id="ctrl-sum">
                <label>Step 2: Vector Addition</label>
                <button id="btn-sum" onclick="showSum()">Compute E_net</button>
            </div>

            <!-- 3. Move Q2 -->
            <div class="control-row" id="ctrl-move">
                <label>Step 3: Move Qâ‚‚ (Angle & Dist)</label>
                <input type="range" id="slider-angle" min="0" max="6.28" value="0" step="0.05">
                <div style="font-size:10px; color:#666; margin-top:5px; text-align:right;">Orbit Position</div>
            </div>

            <!-- Reset -->
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Experiment Control</label>
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Vector Space</div>
        <div id="legend">
            <div class="legend-item">
                <div class="dot" style="background:#ff6b6b"></div>Eâ‚ (from Qâ‚)
            </div>
            <div class="legend-item">
                <div class="dot" style="background:#54a0ff"></div>Eâ‚‚ (from Qâ‚‚)
            </div>
            <div class="legend-item">
                <div class="dot" style="background:#ff9f43"></div>E_net (Resultant)
            </div>
            <div class="legend-item" style="color:#888">
                <div class="dot" style="border:1px dashed #888; background:transparent"></div>Parallel Projection
            </div>
        </div>
    </main>

    <script>
        // ==========================================
        // GLOBALS
        // ==========================================
        let currentChapter = 0;

        const state = {
            q2Visible: false,
            netVisible: false,
            angle: 0,
            time: 0
        };

        // Constants for visuals
        const K = 600; // Increased magnitude for longer arrows
        const Q1_CHARGE = 1;
        const Q2_CHARGE = -1;

        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const scene = new THREE.Scene();

        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 50;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );

        camera.position.set(30, 40, 30);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('world').appendChild(renderer.domElement);

        // Lights
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Grid
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({
            color: 0x222222,
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -10;
        floor.receiveShadow = true;
        scene.add(floor);
        scene.background = new THREE.Color(0x151515);

        const gridHelper = new THREE.GridHelper(100, 20, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -9.9;
        scene.add(gridHelper);

        // --- UTILS ---
        function createTextSprite(text, scale, color = "white") {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 50px Arial';
            ctx.fillStyle = color;
            ctx.textAlign = "center";
            ctx.fillText(text, 128, 80);
            const tex = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, depthTest: false }));
            sprite.scale.set(scale * 2, scale, 1);
            sprite.renderOrder = 100;
            return sprite;
        }

        function createArrow(color) {
            const group = new THREE.Group();
            const visuals = new THREE.Group();

            // --- GEOMETRY FIX ---
            // We create an arrow with a total length of exactly 1.0 along the X-axis.
            // This ensures that when we scale it by 'len', the tip is exactly at distance 'len'.

            const totalLen = 1.0;
            const headLen = 0.25; // Head is 25% of the total length
            const shaftLen = totalLen - headLen;

            // 1. Shaft (Cylinder)
            // Radius increased slightly to maintain chunky look
            const shaftGeo = new THREE.CylinderGeometry(0.25, 0.25, shaftLen, 12);
            shaftGeo.rotateZ(-Math.PI / 2); // Point along X-axis
            // Move center so it starts at 0 and ends at 0.75
            shaftGeo.translate(shaftLen / 2, 0, 0);

            const shaftMat = new THREE.MeshStandardMaterial({ color: color });
            const shaft = new THREE.Mesh(shaftGeo, shaftMat);

            // 2. Head (Cone)
            const headGeo = new THREE.ConeGeometry(0.5, headLen, 12);
            headGeo.rotateZ(-Math.PI / 2); // Point along X-axis
            // Move center so it starts at 0.75 and tip ends exactly at 1.0
            headGeo.translate(shaftLen + (headLen / 2), 0, 0);

            const headMat = new THREE.MeshStandardMaterial({ color: color });
            const head = new THREE.Mesh(headGeo, headMat);

            visuals.add(shaft, head);
            group.add(visuals);
            group.userData = { visuals: visuals };
            return group;
        }

        // --- SCENE OBJECTS ---

        // Point P
        const pGroup = new THREE.Group();
        const pGeo = new THREE.SphereGeometry(0.5, 16, 16);
        const pMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const pMesh = new THREE.Mesh(pGeo, pMat);
        const labelP = createTextSprite("P", 3, "#ccc");
        labelP.position.y = 2;
        pGroup.add(pMesh, labelP);
        scene.add(pGroup);

        // Q1
        const q1Group = new THREE.Group();
        const qGeo = new THREE.IcosahedronGeometry(2.5, 1);
        const q1Mat = new THREE.MeshStandardMaterial({ color: 0xff6b6b, emissive: 0x550000 });
        const q1Mesh = new THREE.Mesh(qGeo, q1Mat);
        q1Mesh.castShadow = true;
        const labelQ1 = createTextSprite("Qâ‚ (+)", 3, "#ff6b6b");
        labelQ1.position.y = 4;
        q1Group.add(q1Mesh, labelQ1);
        q1Group.position.set(-15, 0, 0);
        scene.add(q1Group);

        // Q2
        const q2Group = new THREE.Group();
        const q2Mat = new THREE.MeshStandardMaterial({ color: 0x54a0ff, emissive: 0x002255 });
        const q2Mesh = new THREE.Mesh(qGeo, q2Mat);
        q2Mesh.castShadow = true;
        const labelQ2 = createTextSprite("Qâ‚‚ (-)", 3, "#54a0ff");
        labelQ2.position.y = 4;
        q2Group.add(q2Mesh, labelQ2);
        q2Group.position.set(15, 0, 0);
        scene.add(q2Group);
        q2Group.visible = false;

        // Vectors
        const arrowE1 = createArrow(0xff6b6b);
        const arrowE2 = createArrow(0x54a0ff);
        const arrowNet = createArrow(0xff9f43);

        scene.add(arrowE1);
        scene.add(arrowE2);
        scene.add(arrowNet);

        // Dashed Lines (for Parallelogram)
        const dashedMat = new THREE.LineDashedMaterial({
            color: 0xaaaaaa,
            dashSize: 1,
            gapSize: 0.5,
            opacity: 0.5,
            transparent: true,
            depthTest: false
        });

        const lineGeo1 = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]);
        const lineGeo2 = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]);

        const line1 = new THREE.Line(lineGeo1, dashedMat);
        const line2 = new THREE.Line(lineGeo2, dashedMat);

        // Compute distances for dashes to appear
        line1.computeLineDistances();
        line2.computeLineDistances();

        scene.add(line1);
        scene.add(line2);

        line1.visible = false;
        line2.visible = false;


        // ==========================================
        // PART 2: ANIMATION LOOP
        // ==========================================

        function getFieldVector(sourcePos, charge) {
            const rVec = new THREE.Vector3(0, 0, 0).sub(sourcePos);
            const r = rVec.length();
            if (r < 0.1) return new THREE.Vector3(0, 0, 0);

            const mag = K * Math.abs(charge) / (r * r);
            rVec.normalize();

            if (charge < 0) rVec.negate();

            return rVec.multiplyScalar(mag);
        }

        function updateArrow(arrowObj, vec, yOffset) {
            if (vec.length() < 0.1) {
                arrowObj.visible = false;
                return;
            }
            arrowObj.visible = true;

            // Apply vertical offset to prevent overlapping
            arrowObj.position.set(0, yOffset, 0);

            const dir = vec.clone().normalize();
            const axisX = new THREE.Vector3(1, 0, 0);
            const quat = new THREE.Quaternion().setFromUnitVectors(axisX, dir);
            arrowObj.quaternion.copy(quat);

            let len = vec.length();
            // Allow longer arrows for better visibility
            len = Math.min(len, 25);
            len = Math.max(len, 0.5);

            arrowObj.userData.visuals.scale.set(len, 1, 1);

            return len; // Return visual length
        }

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.02;

            // Bobbing animations
            q1Mesh.position.y = Math.sin(state.time) * 0.2;
            q2Mesh.position.y = Math.sin(state.time + 1) * 0.2;

            // Q2 Orbit logic
            const dist = 15;
            const x = Math.cos(state.angle) * dist;
            const z = Math.sin(state.angle) * dist;
            q2Group.position.set(x, 0, z);

            // 1. Calculate Vectors
            const E1 = getFieldVector(q1Group.position, Q1_CHARGE);
            const E2 = state.q2Visible ? getFieldVector(q2Group.position, Q2_CHARGE) : new THREE.Vector3(0, 0, 0);

            // 2. Update Source Arrows (Offset E1 down, E2 up)
            const len1 = updateArrow(arrowE1, E1, -0.2);
            let len2 = 0;

            if (state.q2Visible) {
                len2 = updateArrow(arrowE2, E2, 0.2);
                arrowE2.visible = true;
            } else {
                arrowE2.visible = false;
            }

            // 3. Update Resultant & Dashed Lines
            if (state.netVisible && state.q2Visible) {

                // Reconstruct visual vectors based on clamped lengths
                const dir1 = E1.clone().normalize();
                const visualVec1 = dir1.multiplyScalar(len1);

                const dir2 = E2.clone().normalize();
                const visualVec2 = dir2.multiplyScalar(len2);

                const visualNet = new THREE.Vector3().addVectors(visualVec1, visualVec2);

                // Net arrow sits at 0 elevation
                updateArrow(arrowNet, visualNet, 0);
                arrowNet.visible = true;

                // Draw Parallelogram Lines
                // Line 1: Tip of E1 -> Tip of Net
                const tip1Pos = visualVec1.clone();
                tip1Pos.y = -0.2; // Match Red Arrow height
                const netPos = visualNet.clone();

                line1.geometry.setFromPoints([tip1Pos, netPos]);
                line1.computeLineDistances();
                line1.visible = true;

                // Line 2: Tip of E2 -> Tip of Net
                const tip2Pos = visualVec2.clone();
                tip2Pos.y = 0.2; // Match Blue Arrow height

                line2.geometry.setFromPoints([tip2Pos, netPos]);
                line2.computeLineDistances();
                line2.visible = true;

            } else {
                arrowNet.visible = false;
                line1.visible = false;
                line2.visible = false;
            }

            renderer.render(scene, camera);
        }
        animate();

        // ==========================================
        // PART 3: LOGIC & NARRATIVE
        // ==========================================

        function introduceQ2() {
            state.q2Visible = true;
            q2Group.visible = true;
            document.getElementById('btn-add-q2').disabled = true;
            checkAdvance();
        }

        function showSum() {
            state.netVisible = true;
            document.getElementById('btn-sum').disabled = true;
            checkAdvance();
        }

        document.getElementById('slider-angle').addEventListener('input', (e) => {
            state.angle = parseFloat(e.target.value);
            checkAdvance();
        });

        function resetSim() {
            state.q2Visible = false;
            state.netVisible = false;
            state.angle = 0;

            q2Group.visible = false;

            document.getElementById('slider-angle').value = 0;
            document.getElementById('btn-add-q2').disabled = false;
            document.getElementById('btn-sum').disabled = false;

            loadLesson(0);
        }

        const lessons = [
            {
                title: "The First Source",
                text: "Observe the red vector <strong>Eâ‚</strong>. It represents the electric field generated by the positive source <strong>Qâ‚</strong>. It points away from the source, extending out into space.<br><br>To see how complexity arises, we need to introduce a second source to the system.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-add-q2');
                },
                instruction: "Click 'Introduce Negative Charge (Qâ‚‚)' below.",
                check: () => state.q2Visible
            },
            {
                title: "Superposition of Fields",
                text: "A negative source <strong>Qâ‚‚</strong> has entered the system, creating a blue field vector <strong>Eâ‚‚</strong>. Because Qâ‚‚ is negative, this field points inwards.<br><br>Notice that <strong>Eâ‚</strong> (Red) remains exactly as it was. The two fields occupy the same point in space simultaneously without destroying each other. To understand the true effect on a particle at P, we must combine them.",
                setup: () => {
                    unlock('ctrl-sum');
                },
                instruction: "Click 'Compute E_net' to visualize the result.",
                check: () => state.netVisible
            },
            {
                title: "The Parallelogram Rule",
                text: "The actual electric field at point P is the <strong>Vector Sum</strong> of the individual fields. This is the Superposition Principle.<br><br>We visualize this using the <strong>Parallelogram Method</strong>. The dashed lines project from the tips of the red and blue vectors. The <strong style='color:#ff9f43'>Orange Resultant</strong> connects the origin to where these lines meet.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-move');
                },
                instruction: "Drag the 'Orbit Position' slider to move Qâ‚‚.",
                check: () => state.angle > 0.5
            },
            {
                title: "Simulation Complete",
                text: "You have successfully visualized how electric fields combine.<br><br>By finding the geometric sum of individual vectors, we can determine the net force on any charge placed at point P, regardless of how many sources are present.<br><br>The orange vector represents the single, unified reality of the field at this point. But what happens if we look at this system from very far away? Does the detail matter, or do we see something simpler?",
                setup: () => { },
                instruction: "Experiment finished. Press Back to review or Reset.",
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Module 2.${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div>
             <div class="story-text">
                ${l.text}
                <span class="instruction-highlight">Action: ${l.instruction}</span>
             </div>`;

            const btn = document.getElementById('btn-next');

            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }

            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.parent.location.href = '/lesson/asymptotic';
            }
        }
        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }
        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        // Init
        loadLesson(0);

        // Resize
        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * newAspect / 2;
            camera.right = viewSize * newAspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

    </script>
</body>

</html>

===== END OF vec_addition.html =====
