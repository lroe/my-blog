<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>The Electric Dipole: Nature's Balance</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
            --pos-color: #ff6b6b;
            --neg-color: #54a0ff;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        .math-block {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #333;
            color: #fff;
            text-align: center;
        }

        /* CONTROLS AREA */
        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        /* NAVIGATION FOOTER */
        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        /* NEXT BUTTON STYLING FIX */
        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            border: none;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
            transform: none;
            animation: none;
        }

        /* MAIN CANVAS */
        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        /* TAGS IN SCENE */
        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Simulation: The Electric Dipole</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- 1. Add Negative Charge -->
            <div class="control-row" id="ctrl-add-neg">
                <label>Step 1: Create Balance</label>
                <button id="btn-add-neg" onclick="addNegativeCharge()">Add Opposite Charge (-Q)</button>
            </div>

            <!-- 2. Show Vector Grid -->
            <div class="control-row" id="ctrl-grid">
                <label>Step 2: Visualize The Web</label>
                <button id="btn-grid" onclick="showVectorField()">Reveal Field Lines</button>
            </div>

            <!-- Reset -->
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Experiment Control</label>
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Vacuum Space &epsilon;<sub>0</sub></div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const state = {
            hasNegative: false,
            fieldVisible: false,
            time: 0
        };

        const scene = new THREE.Scene();

        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 40;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );

        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('world').appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // Floor (Grid)
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({
            color: 0x222222,
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -5;
        floor.receiveShadow = true;
        scene.add(floor);
        scene.background = new THREE.Color(0x151515);

        const gridHelper = new THREE.GridHelper(100, 20, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -4.9;
        scene.add(gridHelper);

        // --- OBJECTS ---

        // 1. Positive Source Charge (+Q) - Red
        const posGroup = new THREE.Group();
        const chargeGeo = new THREE.IcosahedronGeometry(2, 1);
        const posMat = new THREE.MeshStandardMaterial({ color: 0xff6b6b, flatShading: true, emissive: 0x550000 });
        const posMesh = new THREE.Mesh(chargeGeo, posMat);
        posMesh.castShadow = true;
        posGroup.add(posMesh);
        posGroup.position.set(-6, 0, 0);
        scene.add(posGroup);

        // 2. Negative Source Charge (-Q) - Blue
        const negGroup = new THREE.Group();
        const negMat = new THREE.MeshStandardMaterial({ color: 0x54a0ff, flatShading: true, emissive: 0x002255 });
        const negMesh = new THREE.Mesh(chargeGeo, negMat);
        negMesh.castShadow = true;
        negGroup.add(negMesh);
        negGroup.position.set(6, 0, 0);
        scene.add(negGroup);
        negGroup.visible = false;

        // 3. Vector Field System
        const fieldArrows = [];
        const fieldGroup = new THREE.Group();
        scene.add(fieldGroup);

        function createArrow() {
            const grp = new THREE.Group();
            // Arrow Shaft (Cylinder)
            const sGeo = new THREE.CylinderGeometry(0.08, 0.08, 1, 8);
            sGeo.rotateX(Math.PI / 2);
            sGeo.translate(0, 0, 0.5);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 });
            const shaft = new THREE.Mesh(sGeo, mat);

            // Arrow Head (Cone)
            const hGeo = new THREE.ConeGeometry(0.25, 0.5, 8);
            hGeo.rotateX(Math.PI / 2);
            hGeo.translate(0, 0, 1);
            const head = new THREE.Mesh(hGeo, mat);

            grp.add(shaft, head);
            return { mesh: grp, mat: mat };
        }

        // Create a grid of arrows
        for (let x = -20; x <= 20; x += 3) {
            for (let z = -20; z <= 20; z += 3) {
                if (Math.abs(x) < 2 && Math.abs(z) < 2) continue; // Skip center clutter
                const arrowObj = createArrow();
                arrowObj.mesh.position.set(x, 0, z);
                fieldGroup.add(arrowObj.mesh);
                fieldArrows.push({
                    obj: arrowObj.mesh,
                    mat: arrowObj.mat,
                    basePos: new THREE.Vector3(x, 0, z)
                });
            }
        }
        fieldGroup.visible = false;

        // Labels
        function createTextSprite(text, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 40px Arial';
            ctx.fillStyle = color;
            ctx.textAlign = "center";
            ctx.fillText(text, 64, 50);
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, depthTest: false });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(4, 2, 1);
            return sprite;
        }
        const labelPos = createTextSprite("+Q", "#ff6b6b");
        labelPos.position.y = 3.5;
        posGroup.add(labelPos);

        const labelNeg = createTextSprite("-Q", "#54a0ff");
        labelNeg.position.y = 3.5;
        negGroup.add(labelNeg);


        // ==========================================
        // PART 2: PHYSICS & ANIMATION
        // ==========================================

        // Physics Constants
        const kQ = 200;

        function getFieldAt(pos) {
            // E_pos vector
            const r1Vec = new THREE.Vector3().subVectors(pos, posGroup.position);
            const r1Sq = r1Vec.lengthSq();
            const dist1 = Math.max(Math.sqrt(r1Sq), 1.5);
            const E1 = r1Vec.clone().normalize().multiplyScalar(kQ / (dist1 * dist1));

            if (!state.hasNegative) {
                return E1;
            }

            // E_neg vector (Pulls toward negative)
            const r2Vec = new THREE.Vector3().subVectors(pos, negGroup.position);
            const r2Sq = r2Vec.lengthSq();
            const dist2 = Math.max(Math.sqrt(r2Sq), 1.5);
            const E2 = r2Vec.clone().normalize().multiplyScalar(-kQ / (dist2 * dist2));

            return new THREE.Vector3().addVectors(E1, E2);
        }

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.02;

            // 1. Bobbing Animation for Charges
            posMesh.position.y = Math.sin(state.time) * 0.2;
            labelPos.position.y = 3.5 + Math.sin(state.time) * 0.2;

            if (state.hasNegative) {
                negMesh.position.y = Math.cos(state.time) * 0.2;
                labelNeg.position.y = 3.5 + Math.cos(state.time) * 0.2;
            } else {
                // If monopole, center the positive charge visually
                posGroup.position.lerp(new THREE.Vector3(0, 0, 0), 0.1);
            }

            // 2. If Dipole Mode, move charges to positions
            if (state.hasNegative) {
                posGroup.position.lerp(new THREE.Vector3(-6, 0, 0), 0.1);
            }

            // 3. Update Vector Field
            if (state.fieldVisible) {
                const up = new THREE.Vector3(0, 1, 0);

                fieldArrows.forEach(arrow => {
                    const E = getFieldAt(arrow.basePos);
                    const mag = E.length();

                    // Direction
                    const direction = E.clone().normalize();
                    const axisZ = new THREE.Vector3(0, 0, 1);
                    const quat = new THREE.Quaternion().setFromUnitVectors(axisZ, direction);
                    arrow.obj.quaternion.slerp(quat, 0.2);

                    // Scale
                    let s = Math.log(mag * 5 + 1);
                    s = Math.min(s, 2.5);
                    s = Math.max(s, 0.2);
                    arrow.obj.scale.setScalar(s);

                    // Color
                    const intensity = Math.min(mag / 3, 1);
                    arrow.mat.color.setHSL(0.6 - (intensity * 0.6), 0, 0.3 + intensity * 0.7);
                    arrow.mat.opacity = 0.3 + (intensity * 0.7);
                });
            }

            renderer.render(scene, camera);
        }
        animate();

        // ==========================================
        // PART 3: LOGIC & NARRATIVE
        // ==========================================

        let currentChapter = 0;

        function addNegativeCharge() {
            state.hasNegative = true;
            negGroup.visible = true;
            document.getElementById('btn-add-neg').disabled = true;
            document.getElementById('btn-add-neg').innerText = "System Balanced";
            checkAdvance();
        }

        function showVectorField() {
            state.fieldVisible = true;
            fieldGroup.visible = true;
            document.getElementById('btn-grid').disabled = true;
            checkAdvance();
        }

        function resetSim() {
            state.hasNegative = false;
            state.fieldVisible = false;

            negGroup.visible = false;
            fieldGroup.visible = false;

            // Reset buttons
            const btnNeg = document.getElementById('btn-add-neg');
            btnNeg.disabled = false;
            btnNeg.innerText = "Add Opposite Charge (-Q)";

            const btnGrid = document.getElementById('btn-grid');
            btnGrid.disabled = false;

            loadLesson(0);
        }

        // --- LESSON CONTENT ---

        const lessons = [
            {
                title: " The Monopole",
                text: "We begin with a single positive charge (+Q). Nature dislikes imbalance.<br><br>Imagine a 'test charge' placed anywhere in this space. It would be pushed straight away. The electric field is purely <strong>radial</strong>, extending to infinity like light from a bulb.<br><br>But what happens if we introduce a counter-balance? <span class='instruction-inline'>Click 'ADD OPPOSITE CHARGE'</span>.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-add-neg');
                    unlock('ctrl-grid'); // Allow viewing monopole field
                    state.hasNegative = false;
                    negGroup.visible = false;
                },
                check: () => state.hasNegative
            },
            {
                title: "The Dipole Formation",
                text: "You have added a negative charge (-Q) of equal magnitude. This system—two equal but opposite charges separated by a distance—is an <strong>Electric Dipole</strong>.<br><br>Notice the space between them. A test charge here is pushed by the Red (+Q) <em>and</em> pulled by the Blue (-Q). These forces work together in the same direction, creating a strong field between them.<br><br>But what about the rest of space? <span class='instruction-inline'>Click 'REVEAL FIELD LINES'</span>.",
                setup: () => {
                    unlock('ctrl-grid');
                },
                check: () => state.fieldVisible
            },
            {
                title: "Symmetry of the Field",
                text: "Look at the pattern. It is no longer radial.<br><br>The field lines arc out of the positive charge and curve around to dive into the negative charge. <br><br><strong>Key Concept:</strong> There is <strong>no point</strong> in space where the field is zero. The 'Push' from +Q and 'Pull' from -Q never perfectly cancel out because the charges are at different locations.",
                setup: () => { },
                check: () => true
            },
            {
                title: "Insight: The Far Field",
                text: "Here is a thought experiment: Imagine you walk a mile away from this dipole.<br><br>From that distance, the separation between the charges looks tiny. The Positive and Negative charges seem to occupy the same spot. Because they are opposites, they <em>almost</em> cancel each other out.<br><br>This means the field dies off much faster ($1/r^3$) than a single charge ($1/r^2$). Dipoles are 'short-range' influencers.",
                setup: () => { },
                check: () => true
            },
            {
                title: "Conclusion",
                text: "Where do we find this geometry in nature?<br><br>1. <strong>Water (H₂O):</strong> Oxygen is negative, Hydrogen is positive. This dipole nature allows water to dissolve salts and exist as a liquid.<br>2. <strong>Antennas:</strong> Radio transmission works by oscillating charges up and down, creating a changing dipole that radiates waves.<br>3. <strong>The Heart:</strong> An ECG measures the changing electric dipole vector of your heart muscle as it beats. But how do we create these dipoles if we start with neutral objects? We use a trick called Induction.",
                setup: () => { },
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div>
             <div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');

            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }

            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.top.location.href = '/theapplefalls/lesson/7_creating_a_dipole(induction)';
            }
        }
        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }
        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        // Init
        loadLesson(0);

        // Resize Handle
        window.addEventListener('resize', () => {
            aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            const camSize = camera.top - camera.bottom;
            camera.left = -camSize * aspect / 2;
            camera.right = camSize * aspect / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

    </script>
</body>

</html>