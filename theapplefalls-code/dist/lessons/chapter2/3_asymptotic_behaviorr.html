<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>The Invisible Web: Asymptotes (Revised)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
            height: 6px;
            background: #333;
            border-radius: 3px;
        }

        .coord-display {
            float: right;
            color: var(--accent);
            font-family: monospace;
        }

        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        /* NEXT BUTTON STYLING FIX */
        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            border: none;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
            transform: none;
            animation: none;
        }

        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Sim: Asymptotic Behavior</div>
        </header>

        <div id="story-container">
            <div id="chapter-content"><!-- Content injected by JS --></div>
        </div>

        <div id="controls-area">
            <div class="control-row" id="ctrl-vis">
                <label>Step 1: Visualization</label>
                <button id="btn-vis" onclick="toggleFieldVectors()">Toggle Vector Field</button>
            </div>
            <div class="control-row" id="ctrl-probe">
                <label>Step 2: Probe Position <span id="val-disp" class="coord-display">x: 0.0</span></label>
                <!-- Extended range to ensure we hit the null point -->
                <input type="range" id="slider-dist" min="-20" max="60" value="0" step="0.1">
                <div style="display:flex; justify-content:space-between; font-size:10px; color:#555; margin-top:5px;">
                    <span>Left Field</span>
                    <span>Far Field &rarr;</span>
                </div>
            </div>
            <!-- Zoom Control Removed -->
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Experiment Control</label>
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Vacuum Space</div>
        <div id="null-point-alert"
            style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:#2ecc71; font-weight:bold; font-size:24px; text-shadow:0 0 10px #000; display:none; pointer-events:none;">
            E = 0 (NULL POINT)</div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const state = { fieldVisible: false, isZoomedOut: false, probeX: 0, time: 0 };
        const scene = new THREE.Scene();
        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        let viewSize = 60;

        const camera = new THREE.OrthographicCamera(-viewSize * aspect / 2, viewSize * aspect / 2, viewSize / 2, -viewSize / 2, 1, 1000);
        camera.position.set(20, 25, 20);
        camera.lookAt(10, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('world').appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Floor & Grid
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8, metalness: 0.2 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -10;
        floor.receiveShadow = true;
        scene.background = new THREE.Color(0x151515);
        const gridHelper = new THREE.GridHelper(300, 60, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -9.9;
        scene.add(floor);
        scene.add(gridHelper);

        // --- COORDINATE SYSTEM VISUALS ---
        function createCoordSystem() {
            const group = new THREE.Group();
            const material = new THREE.LineBasicMaterial({ color: 0x666666, transparent: true, opacity: 0.5 });
            const points = [new THREE.Vector3(-100, 0, 0), new THREE.Vector3(100, 0, 0)];
            const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), material);
            group.add(line);

            for (let x = -80; x <= 80; x += 10) {
                const tick = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(x, 0, -1), new THREE.Vector3(x, 0, 1)]), material);
                group.add(tick);
            }

            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#888'; ctx.font = 'bold 30px monospace';
            ctx.textAlign = 'center'; ctx.fillText('x=0', 64, 40);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true, opacity: 0.7 }));
            sprite.position.set(0, -3, 2);
            sprite.scale.set(4, 2, 1);
            group.add(sprite);
            return group;
        }
        scene.add(createCoordSystem());

        // Charge 1: +3 (Left)
        const q1Group = new THREE.Group();
        q1Group.add(new THREE.Mesh(new THREE.IcosahedronGeometry(3.5, 1), new THREE.MeshStandardMaterial({ color: 0xff6b6b, emissive: 0x550000 })));
        q1Group.position.set(-8, 0, 0);
        scene.add(q1Group);

        // Charge 2: -1 (Right)
        const q2Group = new THREE.Group();
        q2Group.add(new THREE.Mesh(new THREE.IcosahedronGeometry(2, 1), new THREE.MeshStandardMaterial({ color: 0x54a0ff, emissive: 0x002255 })));
        q2Group.position.set(8, 0, 0);
        scene.add(q2Group);

        function createTextSprite(text, color, scale) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 50px Arial';
            ctx.fillStyle = color;
            ctx.textAlign = "center";
            ctx.fillText(text, 128, 80);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
            sprite.scale.set(scale * 2, scale, 1);
            return sprite;
        }
        const labelQ1 = createTextSprite("+3Q", "#ff6b6b", 4); labelQ1.position.y = 5.5; q1Group.add(labelQ1);
        const labelQ2 = createTextSprite("-1Q", "#54a0ff", 3); labelQ2.position.y = 4; q2Group.add(labelQ2);

        // Probe
        const probeGroup = new THREE.Group();
        const probeMesh = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), new THREE.MeshBasicMaterial({ color: 0xfeca57 }));
        probeGroup.add(probeMesh);

        // Arrow Helper
        const arrowHelperGrp = new THREE.Group();
        const arrowShaft = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1, 8).translate(0, 0.5, 0).rotateZ(-Math.PI / 2), new THREE.MeshBasicMaterial({ color: 0xffffff }));
        const arrowHead = new THREE.Mesh(new THREE.ConeGeometry(0.25, 0.6, 8).rotateZ(-Math.PI / 2).translate(1, 0, 0), new THREE.MeshBasicMaterial({ color: 0xffffff }));
        arrowHelperGrp.add(arrowShaft, arrowHead);
        probeGroup.add(arrowHelperGrp);
        scene.add(probeGroup);

        // Field Vectors
        const fieldVectors = [];
        const vectorGroup = new THREE.Group();
        scene.add(vectorGroup);
        vectorGroup.visible = false;

        // Grid Generation
        for (let x = -60; x <= 100; x += 5) { // Extended to 100
            for (let z = -20; z <= 20; z += 5) {
                if (Math.abs(x + 8) < 3 && Math.abs(z) < 3) continue;
                if (Math.abs(x - 8) < 3 && Math.abs(z) < 3) continue;

                const vGroup = new THREE.Group();
                vGroup.position.set(x, 0, z);
                const s = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 1, 4).translate(0, 0.5, 0).rotateZ(-Math.PI / 2), new THREE.MeshBasicMaterial({ color: 0x666666, transparent: true }));
                const h = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.35, 4).rotateZ(-Math.PI / 2).translate(1, 0, 0), new THREE.MeshBasicMaterial({ color: 0x666666, transparent: true }));
                vGroup.add(s, h);
                vGroup.userData = { origin: new THREE.Vector3(x, 0, z) };
                vectorGroup.add(vGroup);
                fieldVectors.push(vGroup);
            }
        }

        // ==========================================
        // PART 2: PHYSICS & ANIMATION
        // ==========================================

        const Q1_VAL = 3000; // Left
        const Q2_VAL = -1000; // Right

        function calculateField(pos) {
            const e = new THREE.Vector3(0, 0, 0);
            const q1CurrentPos = q1Group.position.clone();
            const q2CurrentPos = q2Group.position.clone();

            const r1 = new THREE.Vector3().subVectors(pos, q1CurrentPos);
            const d1 = r1.length();
            if (d1 > 1) { r1.normalize(); e.add(r1.multiplyScalar(Q1_VAL / (d1 * d1))); }

            const r2 = new THREE.Vector3().subVectors(pos, q2CurrentPos);
            const d2 = r2.length();
            if (d2 > 1) { r2.normalize(); e.add(r2.multiplyScalar(Q2_VAL / (d2 * d2))); }
            return e;
        }

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.015;

            q1Group.position.y = Math.sin(state.time) * 0.3;
            q2Group.position.y = Math.sin(state.time + 1) * 0.2;

            probeGroup.position.set(state.probeX, 0, 0);

            // --- Calculate Physics ---
            const E_net = calculateField(probeGroup.position);
            const E_mag = E_net.length();

            // FIX: Visual Gain. We multiply magnitude by 5 for visualization 
            // because the far field is naturally weak but we need to see it.
            const visualMag = E_mag * 5.0;

            // Strict Null Point detection (~29.85)
            // We ensure we only hide the arrow in the EXACT dead zone.
            const isNullPoint = (E_mag < 0.1 && state.probeX > 28 && state.probeX < 32);

            const nullPointEl = document.getElementById('null-point-alert');
            if (isNullPoint) {
                nullPointEl.style.display = 'block';
                arrowHelperGrp.visible = false;
            } else {
                nullPointEl.style.display = 'none';
                arrowHelperGrp.visible = true;
            }

            if (!isNullPoint && E_mag > 0.00001) {
                const dir = E_net.clone();
                dir.y = 0; // Force flat on XZ plane
                dir.normalize();
                const axisX = new THREE.Vector3(1, 0, 0);
                const quat = new THREE.Quaternion().setFromUnitVectors(axisX, dir);
                arrowHelperGrp.setRotationFromQuaternion(quat);

                // Scale Arrow: Logarithmic using the Boosted Visual Mag
                // This ensures it stays visible even when the field is weak (0.3 etc)
                let scale = Math.log(visualMag + 1);
                scale = Math.max(scale, 0.6); // Minimum size clamp increased
                scale = Math.min(scale, 6);
                arrowHelperGrp.scale.set(scale, 1, 1);
            }

            // --- Background Vectors ---
            if (state.fieldVisible) {
                fieldVectors.forEach(v => {
                    const E = calculateField(v.userData.origin);
                    const mag = E.length();
                    const vVisualMag = mag * 4.0; // Boost background grid too

                    const dir = E.clone();
                    dir.y = 0; // Force flat
                    dir.normalize();
                    const axisX = new THREE.Vector3(1, 0, 0);
                    v.setRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(axisX, dir));

                    // Color mapping
                    const intensity = Math.min(mag / 10, 1);

                    // Scale mapping
                    let vScale = Math.min(Math.log(vVisualMag + 1), 2.5);
                    v.scale.set(vScale, 1, 1);

                    // Opacity: Ensure distant arrows remain visible
                    const op = 0.4 + (Math.min(mag, 1) * 0.6);

                    v.children.forEach(c => {
                        c.material.color.setHSL(0.6, 0.8, 0.3 + 0.5 * intensity);
                        c.material.opacity = op;
                    });
                });
            }

            // Camera Logic
            // Camera Logic
            const targetView = 60;
            viewSize += (targetView - viewSize) * 0.05;
            const currentAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * currentAspect / 2;
            camera.right = viewSize * currentAspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;

            const targetCamX = 10;
            camera.position.x += (targetCamX - camera.position.x) * 0.05;

            camera.updateProjectionMatrix();
            renderer.render(scene, camera);
        }
        animate();

        // ==========================================
        // PART 3: LOGIC & NARRATIVE
        // ==========================================

        let currentChapter = 0;

        function toggleFieldVectors() {
            state.fieldVisible = !state.fieldVisible;
            vectorGroup.visible = state.fieldVisible;
            document.getElementById('btn-vis').innerText = state.fieldVisible ? "Hide Field" : "Show Field";
            checkAdvance();
        }

        document.getElementById('slider-dist').addEventListener('input', (e) => {
            state.probeX = parseFloat(e.target.value);
            document.getElementById('val-disp').innerText = `x: ${state.probeX.toFixed(1)}`;
            checkAdvance();
        });

        // Zoom function removed

        function resetSim() {
            state.fieldVisible = false;
            state.isZoomedOut = false;
            state.probeX = 0;
            vectorGroup.visible = false;
            const slider = document.getElementById('slider-dist');
            slider.value = 0;
            slider.min = -20;
            slider.max = 60;
            document.getElementById('val-disp').innerText = "x: 0.0";
            document.getElementById('btn-vis').innerText = "Toggle Vector Field";
            // Zoom reset removed
            loadLesson(0);
        }

        const lessons = [
            {
                title: "Unequal Charges",
                text: "We have two charges on the axis. Left: <strong style='color:#ff6b6b'>+3Q</strong> at x=-8. Right: <strong style='color:#54a0ff'>-1Q</strong> at x=+8. <br><br>The visual grid helps us track position. Because the charges are unequal, the field pattern is asymmetrical.<br><br><span class='instruction-inline'>Click 'TOGGLE VECTOR FIELD'</span> to visualize the net force.",
                setup: () => { lockAll(); unlock('ctrl-vis'); state.isZoomedOut = false; state.probeX = 0; },
                check: () => state.fieldVisible
            },
            {
                title: "Between the Charges",
                text: "Look at the origin (x=0). Both charges push/pull a positive probe to the right (+3Q pushes, -1Q pulls).<br><br>Use the <strong>PROBE</strong> to explore. Notice how the direction (arrow) never flips between the charges.<br><br>Move the probe anywhere between x=-5 and x=5.",
                setup: () => { unlock('ctrl-probe'); },
                check: () => Math.abs(state.probeX) > 1 && Math.abs(state.probeX) < 7
            },
            {
                title: "The Null Point",
                text: "Since the Positive charge is stronger (+3 vs -1), it pushes its influence far to the right, overpowering the negative charge for a long distance.<br><br>However, distance eventually wins. There is a specific point where the push of the distant +3Q exactly equals the pull of the nearby -1Q.<br><br><strong>Mission:</strong> Find the Null Point where <strong>E = 0</strong> (approx x > 25).",
                setup: () => { },
                check: () => (state.probeX > 28 && state.probeX < 32)
            },
            {
                title: "Conclusion",
                text: "Excellent. You found the balance point (~x=30).<br><br>Now, look at what happens <strong>after</strong> the null point. The field reappears, but the arrow has <strong>flipped</strong>. It now points away from the system.<br><br>From far away, the separation (distance between charges) doesn't matter. The universe just sees a net charge of +2Q (+3Q - 1Q). Thus, at large distances, the field behaves exactly like a single +2Q charge. Now that we understand the math, let's look at a more powerful way to visualize these fields using Field Lines.",
                setup: () => { },
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML = `<div class="chapter-title">${l.title}</div><div class="story-text">${l.text}</div>`;
            const btn = document.getElementById('btn-next');
            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }
            l.setup();
        }
        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.parent.location.href = '/lesson/field_lines';
            }
        }
        function prevLesson() { if (currentChapter > 0) loadLesson(currentChapter - 1); }
        function checkAdvance() { if (currentChapter >= lessons.length - 1) return; if (lessons[currentChapter].check()) { document.getElementById('btn-next').disabled = false; } }
        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        loadLesson(0);

        window.addEventListener('resize', () => {
            aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * aspect / 2;
            camera.right = viewSize * aspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });
    </script>
</body>

</html>