<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>The Invisible Web: The Closed Integral</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #e0e6ed;
            --accent: #ff9f43;
            --accent-hover: #ffb773;
            --border: #2c313a;
            --positive: #ff6b6b;
            /* Red - Out */
            --negative: #54a0ff;
            /* Blue - In */
            --normal: #2ed573;
            /* Green */
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', Roboto, Helvetica, sans-serif;
            overflow: hidden;
        }

        /* LEFT PANEL */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.6);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.1);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 700;
        }

        .subtitle {
            font-size: 13px;
            color: #8892b0;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 20px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 15px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #bdc3c7;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        .math-block {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #333;
            color: #fff;
            text-align: center;
        }

        /* CONTROLS AREA */
        #controls-area {
            background: #131519;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 20px;
            opacity: 0.4;
            pointer-events: none;
            transition: 0.4s;
            filter: grayscale(1);
            position: relative;
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            font-weight: 700;
        }

        button {
            background: #2c313a;
            color: #aaa;
            border: 1px solid #3d4450;
            padding: 12px 15px;
            cursor: pointer;
            border-radius: 6px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 0.5px;
        }

        button:hover {
            background: #3d4450;
            color: #fff;
            border-color: #555;
        }

        button:active {
            transform: translateY(1px);
        }

        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px 25px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #111;
        }

        .nav-btn {
            width: 48%;
            background: #222;
            color: #fff;
            border: none;
        }

        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            font-weight: 800;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
            box-shadow: 0 0 15px rgba(255, 159, 67, 0.4);
        }

        .nav-btn.next:disabled {
            background: #222;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
        }

        /* MAIN CANVAS */
        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        /* TAGS IN SCENE */
        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }

        .legend {
            position: absolute;
            bottom: 30px;
            left: 450px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #333;
            pointer-events: none;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
            color: #ccc;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Simulation: The Closed Integral</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- 1. Normals -->
            <div class="control-row" id="ctrl-normal">
                <label>Step 1: Define Orientation</label>
                <button id="btn-normal" onclick="toggleNormals()">Show Normal Vectors (n)</button>
            </div>

            <!-- 2. External Field -->
            <div class="control-row" id="ctrl-ext">
                <label>Step 2: Apply Field</label>
                <button id="btn-ext" onclick="activateExternalField()">Start Electric Field (E)</button>
            </div>

            <!-- Reset -->
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Experiment Control</label>
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Vacuum Space</div>
        <div class="legend">
            <div class="legend-item">
                <div class="dot" style="background: #2ed573;"></div>Normal Vector (n)
            </div>
            <div class="legend-item">
                <div class="dot" style="background: #54a0ff;"></div>Electric Field (E)
            </div>
            <div class="legend-item">
                <div class="dot" style="background: #ff6b6b;"></div>Positive Flux (Out)
            </div>
            <div class="legend-item">
                <div class="dot" style="background: #54a0ff;"></div>Negative Flux (In)
            </div>
        </div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const state = {
            normalsVisible: false,
            fieldMode: 'none', // 'none', 'external'
            time: 0
        };

        const scene = new THREE.Scene();

        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 35;

        // Isometric/Orthographic view
        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );

        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('world').appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 30, 15);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Floor
        const floorGeo = new THREE.PlaneGeometry(120, 120);
        const floorMat = new THREE.MeshStandardMaterial({
            color: 0x181a1f,
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -10;
        floor.receiveShadow = true;

        const gridHelper = new THREE.GridHelper(100, 20, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -9.9;
        scene.add(floor);
        scene.add(gridHelper);

        // --- OBJECTS ---

        // 1. The Surface (Transparent Cube)
        const boxSize = 8;
        const boxGeo = new THREE.BoxGeometry(boxSize, boxSize, boxSize);

        // Create distinct materials for each face to color them later
        // Order: +x, -x, +y, -y, +z, -z
        const faceMaterials = [];
        for (let i = 0; i < 6; i++) {
            faceMaterials.push(new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide,
                depthWrite: false
            }));
        }

        const gaussianBox = new THREE.Mesh(boxGeo, faceMaterials);
        gaussianBox.position.y = 0;
        scene.add(gaussianBox);

        // Wireframe for the box edges
        const edges = new THREE.EdgesGeometry(boxGeo);
        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x555555 }));
        gaussianBox.add(line);

        // 2. Normal Vectors (n)
        const normalGroup = new THREE.Group();
        scene.add(normalGroup);

        function createArrow(color, length) {
            const g = new THREE.Group();
            const shaft = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.1, length, 8),
                new THREE.MeshBasicMaterial({ color: color })
            );
            shaft.position.y = length / 2;
            const head = new THREE.Mesh(
                new THREE.ConeGeometry(0.3, 0.6, 8),
                new THREE.MeshBasicMaterial({ color: color })
            );
            head.position.y = length;
            g.add(shaft);
            g.add(head);
            return g;
        }

        // Positions and rotations for normals on a cube
        // +x, -x, +y, -y, +z, -z
        const offset = boxSize / 2;
        const normalData = [
            { pos: [offset, 0, 0], rot: [0, 0, -Math.PI / 2] }, // Right (+x)
            { pos: [-offset, 0, 0], rot: [0, 0, Math.PI / 2] }, // Left (-x)
            { pos: [0, offset, 0], rot: [0, 0, 0] },          // Top (+y)
            { pos: [0, -offset, 0], rot: [Math.PI, 0, 0] },   // Bottom (-y)
            { pos: [0, 0, offset], rot: [Math.PI / 2, 0, 0] },  // Front (+z)
            { pos: [0, 0, -offset], rot: [-Math.PI / 2, 0, 0] } // Back (-z)
        ];

        normalData.forEach(d => {
            const arrow = createArrow(0x2ed573, 3); // Green for Normals
            arrow.position.set(...d.pos);
            arrow.rotation.set(...d.rot);
            normalGroup.add(arrow);
        });
        normalGroup.visible = false;

        // 3. External Electric Field (Uniform +X)
        const externalFieldGroup = new THREE.Group();
        // Grid of arrows passing through
        for (let y = -4; y <= 4; y += 4) {
            for (let z = -4; z <= 4; z += 4) {
                // Arrow entering left
                const arrowIn = createArrow(0x54a0ff, 15);
                arrowIn.rotation.z = -Math.PI / 2;
                arrowIn.position.set(-15, y, z);
                externalFieldGroup.add(arrowIn);

                // Arrow leaving right
                const arrowOut = createArrow(0x54a0ff, 15);
                arrowOut.rotation.z = -Math.PI / 2;
                arrowOut.position.set(0, y, z); // Starts at center goes to +15
                externalFieldGroup.add(arrowOut);
            }
        }
        scene.add(externalFieldGroup);
        externalFieldGroup.visible = false;


        // ==========================================
        // PART 2: ANIMATION & UPDATE LOGIC
        // ==========================================

        function updateBoxColors() {
            // Reset all to glass
            faceMaterials.forEach(m => {
                m.color.setHex(0xffffff);
                m.opacity = 0.1;
            });

            if (state.fieldMode === 'external') {
                // External Field is along +X
                // Left Face (-X normal): Angle 180. E dot n = negative (IN)
                // Right Face (+X normal): Angle 0. E dot n = positive (OUT)
                // Others: Angle 90. E dot n = 0.

                faceMaterials[0].color.setHex(0xff6b6b); // +x face (Right) -> OUT -> Red
                faceMaterials[0].opacity = 0.3;

                faceMaterials[1].color.setHex(0x54a0ff); // -x face (Left) -> IN -> Blue
                faceMaterials[1].opacity = 0.3;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.01;

            // Animate arrows slightly to imply flow
            if (state.fieldMode === 'external') {
                externalFieldGroup.children.forEach((c, i) => {
                    c.position.x += Math.cos(state.time + i) * 0.02;
                });
            }

            renderer.render(scene, camera);
        }
        animate();

        // ==========================================
        // PART 3: NARRATIVE LOGIC
        // ==========================================

        let currentChapter = 0;

        function toggleNormals() {
            state.normalsVisible = !state.normalsVisible;
            normalGroup.visible = state.normalsVisible;

            const btn = document.getElementById('btn-normal');
            if (state.normalsVisible) {
                btn.innerHTML = "Hide Normals";
                btn.style.color = "#2ed573";
                btn.style.borderColor = "#2ed573";
            } else {
                btn.innerHTML = "Show Normal Vectors (n)";
                btn.style.color = "";
                btn.style.borderColor = "";
            }
            checkAdvance();
        }

        function activateExternalField() {
            state.fieldMode = 'external';
            externalFieldGroup.visible = true;

            document.getElementById('btn-ext').disabled = true;

            updateBoxColors();
            checkAdvance();
        }


        function resetSim() {
            state.normalsVisible = false;
            state.fieldMode = 'none';

            normalGroup.visible = false;
            externalFieldGroup.visible = false;

            // Reset Materials
            updateBoxColors();

            // Reset Buttons
            const btnN = document.getElementById('btn-normal');
            btnN.innerHTML = "Show Normal Vectors (n)";
            btnN.style.color = "";
            btnN.style.borderColor = "";

            document.getElementById('btn-ext').disabled = false;

            loadLesson(0);
        }

        // --- LESSON CONTENT ---

        const lessons = [
            {
                title: "First Principles: Orientation",
                text: "To calculate flow, we first need to agree on direction. This is a <strong>Closed Surface</strong> (a simple box). It separates the universe into 'Inside' and 'Outside'.<br><br>By convention, the <strong>Normal Vector (<span style='color:#2ed573'>n</span>)</strong> always points from the inside to the outside.<br><br>Toggle the Normals to see this definition.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-normal');
                },
                check: () => state.normalsVisible
            },
            {
                title: "Flux: Flow vs Direction",
                text: "<strong>Flux (Φ)</strong> is the measurement of how much field passes through a surface area. It depends on the angle between the field and the normal.<br><div class='math-block'>Φ = E · dA = |E||dA|cos(θ)</div><br>If the Field flows <strong>with</strong> the Normal (Out), flux is <strong style='color:#ff6b6b'>Positive</strong>.<br>If the Field flows <strong>against</strong> the Normal (In), flux is <strong style='color:#54a0ff'>Negative</strong>.<br><br>Apply the External Field to visualize this.",
                setup: () => {
                    unlock('ctrl-ext');
                },
                check: () => state.fieldMode === 'external'
            },
            {
                title: "Conclusion",
                text: "In physics, you will see this symbol to describe what we are doing:<br><div class='math-block' style='font-size: 24px;'>∮</div><br>1. The elongated <strong>'S'</strong> stands for 'Sum' (integration). We are adding up the flux.<br><br>2. The <strong>Circle</strong> is the crucial part. It tells us the surface is <strong>Closed</strong>. Unlike a flat sheet of paper, a closed surface (like this box) has no edges; it completely wraps around a volume, strictly separating 'Inside' from 'Outside'.<br><br>When we write <strong>∮ E · dA</strong>, we are calculating the total flow across this entire boundary. But what happens when we place a charge inside this surface? Let's find out.",
                setup: () => {
                    // Just reading step
                },
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Concept ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div>
             <div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');

            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }

            if (l.setup) l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.parent.location.href = '/lesson/flux_sphere';
            }
        }
        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }
        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        // Init
        loadLesson(0);

        // Resize Handle
        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * newAspect / 2;
            camera.right = viewSize * newAspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

    </script>
</body>

</html>