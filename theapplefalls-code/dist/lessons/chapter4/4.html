<!-- START OF FILE chapter4.html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Chapter 4: Equipotential Surfaces</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange for Energy */
            --potential: #a55eea;
            /* Purple for Potential */
            --surface: #00d2d3;
            /* Cyan for equipotential surfaces */
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* LEFT PANEL */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        button.active-btn {
            background: var(--accent);
            color: #151515;
            border-color: var(--accent);
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
        }

        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
            padding: 10px;
            cursor: pointer;
            border-radius: 4px;
            text-transform: uppercase;
            font-weight: bold;
        }

        .nav-btn.next {
            background: var(--accent);
            color: #151515;
        }

        .nav-btn.next:hover {
            background: #e58e3c;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
        }

        /* MAIN CANVAS */
        main {
            flex: 1;
            position: relative;
            background: #151515;
            overflow: hidden;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #333;
            padding: 20px;
            border-radius: 5px;
            pointer-events: none;
            font-family: 'Courier New', monospace;
            width: 280px;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .hud-val {
            font-weight: bold;
            color: #fff;
        }

        .hud-divider {
            height: 1px;
            background: #444;
            margin: 10px 0;
        }

        .pulse {
            animation: pulse-cyan 2s infinite;
        }

        @keyframes pulse-cyan {
            0% {
                box-shadow: 0 0 0 0 rgba(0, 210, 211, 0.7);
            }

            70% {
                box-shadow: 0 0 0 8px rgba(0, 210, 211, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(0, 210, 211, 0);
            }
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Chapter 4: Work and Energy</h1>
            <div class="subtitle">Lesson 4: Equipotential Surfaces</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">

            <!-- Toggle Surfaces -->
            <div class="control-row" id="ctrl-toggle">
                <label>Visualization</label>
                <button id="btn-toggle" onclick="toggleSurfaces()">Show Surfaces</button>
            </div>

            <!-- Movement Mode -->
            <div class="control-row" id="ctrl-mode">
                <label>Movement Mode</label>
                <div style="display:flex; gap:10px;">
                    <button id="btn-tangent" onclick="setMode('tangent')">Along Surface</button>
                    <button id="btn-radial" onclick="setMode('radial')">Radial</button>
                </div>
            </div>

            <!-- Angle Slider (for tangential) -->
            <div class="control-row" id="ctrl-angle">
                <label>Move Along Surface (θ)</label>
                <input type="range" id="slider-angle" min="0" max="360" value="0" step="1">
            </div>

            <!-- Distance Slider (for radial) -->
            <div class="control-row" id="ctrl-dist">
                <label>Move Radially (r)</label>
                <input type="range" id="slider-dist" min="5" max="20" value="10" step="0.1">
            </div>

        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div id="hud">
            <!-- Potential V -->
            <div class="hud-row" style="color: var(--potential);">
                <span>Potential (V):</span>
                <span id="val-v" class="hud-val">50 V</span>
            </div>

            <div class="hud-divider"></div>

            <!-- Work Done -->
            <div class="hud-row" style="color: var(--accent);">
                <span>Work Done (ΔU):</span>
                <span id="val-work" class="hud-val">0 J</span>
            </div>

            <div class="hud-divider"></div>

            <!-- Mode -->
            <div class="hud-row" style="color: var(--surface);">
                <span>Mode:</span>
                <span id="val-mode" class="hud-val">Tangential</span>
            </div>
        </div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const state = {
            r: 10,
            angle: 0, // Angle in degrees
            surfacesVisible: false,
            mode: 'tangent', // 'tangent' or 'radial'
            initialV: 50,
            work: 0
        };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x151515);

        // Camera
        const sidebarWidth = 420;
        const aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const d = 25;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(0, 0, 50);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        document.getElementById('world').appendChild(renderer.domElement);

        // --- SPHERE A (Source +Q) ---
        const sphereA = new THREE.Mesh(
            new THREE.SphereGeometry(1.5, 32, 32),
            new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xff5500, emissiveIntensity: 0.8 })
        );
        scene.add(sphereA);

        // --- EQUIPOTENTIAL SURFACES (Concentric Spheres) ---
        const surfaces = [];
        const radii = [5, 8, 11, 14, 17, 20];
        for (let r of radii) {
            const surfaceGeo = new THREE.SphereGeometry(r, 32, 32);
            const surfaceMat = new THREE.MeshBasicMaterial({
                color: 0x00d2d3,
                wireframe: true,
                transparent: true,
                opacity: 0
            });
            const surfaceMesh = new THREE.Mesh(surfaceGeo, surfaceMat);
            scene.add(surfaceMesh);
            surfaces.push(surfaceMesh);
        }

        // --- SPHERE B (Test Probe) ---
        const sphereB = new THREE.Mesh(
            new THREE.SphereGeometry(0.6, 32, 32),
            new THREE.MeshStandardMaterial({ color: 0x54a0ff, emissive: 0x0055ff, emissiveIntensity: 0.5 })
        );
        scene.add(sphereB);

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffaa00, 1, 100);
        pointLight.position.set(0, 10, 0);
        scene.add(pointLight);

        // --- LOGIC ---

        function updatePhysics() {
            const angleRad = (state.angle * Math.PI) / 180;
            const x = state.r * Math.cos(angleRad);
            const y = state.r * Math.sin(angleRad);
            sphereB.position.set(x, y, 0);

            // Calculate V and Work
            const kQ = 500;
            const V = kQ / state.r;

            // Work done is change in U (and U = qV, but we'll just track V change for simplicity)
            const deltaV = V - state.initialV;
            state.work = deltaV; // Simplified: actual work would be q * deltaV

            updateHUD(V);
        }

        function updateHUD(V) {
            document.getElementById('val-v').innerText = Math.round(V) + " V";
            document.getElementById('val-work').innerText = Math.round(state.work) + " J";
            document.getElementById('val-mode').innerText = state.mode === 'tangent' ? 'Tangential (0 Work)' : 'Radial';

            // Highlight surface closest to probe
            if (state.surfacesVisible) {
                surfaces.forEach((s, i) => {
                    const surfaceR = radii[i];
                    const diff = Math.abs(state.r - surfaceR);
                    s.material.opacity = diff < 1 ? 0.6 : 0.2;
                });
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }
        animate();

        // ==========================================
        // PART 2: UI & NARRATIVE
        // ==========================================

        const sliderAngle = document.getElementById('slider-angle');
        const sliderDist = document.getElementById('slider-dist');

        sliderAngle.addEventListener('input', (e) => {
            state.angle = parseFloat(e.target.value);
            checkAdvance();
        });

        sliderDist.addEventListener('input', (e) => {
            state.r = parseFloat(e.target.value);
            checkAdvance();
        });

        function toggleSurfaces() {
            state.surfacesVisible = !state.surfacesVisible;
            surfaces.forEach(s => {
                s.material.opacity = state.surfacesVisible ? 0.3 : 0;
            });
            document.getElementById('btn-toggle').innerText = state.surfacesVisible ? "Hide Surfaces" : "Show Surfaces";
            document.getElementById('btn-toggle').classList.toggle('active-btn', state.surfacesVisible);
            checkAdvance();
        }

        function setMode(mode) {
            state.mode = mode;

            if (mode === 'tangent') {
                lock('ctrl-dist');
                unlock('ctrl-angle');
                document.getElementById('btn-tangent').classList.add('active-btn');
                document.getElementById('btn-radial').classList.remove('active-btn');

                // Lock current r and reset work
                const kQ = 500;
                state.initialV = kQ / state.r;
                state.work = 0;
            } else {
                lock('ctrl-angle');
                unlock('ctrl-dist');
                document.getElementById('btn-radial').classList.add('active-btn');
                document.getElementById('btn-tangent').classList.remove('active-btn');

                // Set initial V for work calculation
                const kQ = 500;
                state.initialV = kQ / state.r;
            }
            checkAdvance();
        }

        // --- LESSONS ---

        const lessons = [
            {
                title: "From Chapter 3: V = U / q",
                text: "In Chapter 3, we discovered that Electric Potential is defined as:<br><br>$$V = \\frac{U}{q}$$<br><br>This gives us the 'Potential Energy per unit charge' at any point.<br><br>For a point charge, we found: $$V = \\frac{kQ}{r}$$<br><br>Notice something important: $V$ depends only on distance $r$.",
                setup: () => {
                    state.r = 10; state.angle = 0; state.surfacesVisible = false;
                    sliderDist.value = 10; sliderAngle.value = 0;
                    lock('ctrl-toggle');
                    lock('ctrl-mode'); lock('ctrl-angle'); lock('ctrl-dist');
                    if (window.MathJax && window.MathJax.typesetPromise) window.MathJax.typesetPromise();
                },
                check: () => true
            },
            {
                title: "Testing the Formula",
                text: "Let's verify this. At $r=10$, the potential is $V = \\frac{kQ}{r} = \\frac{500}{10} = 50V$.<br><br>This is what you see in the HUD on the right.<br><br>But here's the key question: if $V$ only depends on distance $r$, what about all the other points that are also at distance $r=10$?<br><br>They should all have the same $V = 50V$ too, right?",
                setup: () => {
                    unlock('ctrl-toggle');
                    if (window.MathJax && window.MathJax.typesetPromise) window.MathJax.typesetPromise();
                },
                check: () => true
            },
            {
                title: "Revealing the Shape",
                text: "All points at distance $r=10$ form a <strong>sphere</strong> around the source.<br><br>And since $V$ is the same everywhere on that sphere, we call it an <strong>equipotential surface</strong>.<br><br><strong>Task:</strong> Toggle 'Show Surfaces' to see multiple equipotential surfaces.",
                setup: () => {
                    if (window.MathJax && window.MathJax.typesetPromise) window.MathJax.typesetPromise();
                },
                check: () => state.surfacesVisible === true
            },
            {
                title: "Equipotential Surfaces",
                text: "These concentric spheres are called <strong>Equipotential Surfaces</strong>.<br><br>Every point on a given sphere has the exact same Potential.<br><br>For a point charge, they are spheres. For other charge distributions, they take different shapes.<br><br><strong>Definition:</strong> An equipotential surface is a region in space where $V$ is constant.",
                setup: () => {
                    // Narrative beat
                },
                check: () => true
            },
            {
                title: "Memory: Chapter 2",
                text: "Do you remember Chapter 2?<br><br>We discovered that moving <em>perpendicular</em> to the electric force does <strong>zero work</strong>.<br><br>$$W = \\vec{F} \\cdot d\\vec{r} = F \\cdot dr \\cdot \\cos(90^\\circ) = 0$$<br><br>What if we move along an equipotential surface? Let's find out.",
                setup: () => {
                    unlock('ctrl-mode');
                    if (window.MathJax && window.MathJax.typesetPromise) window.MathJax.typesetPromise();
                },
                check: () => true
            },
            {
                title: "Moving Along the Surface",
                text: "Select <strong>'Along Surface'</strong> mode. This locks your distance ($r$) and lets you walk around the sphere.<br><br>Watch the <strong>Work Done</strong> in the HUD as you drag the slider.<br><br><strong>Task:</strong> Move the charge along the surface (change θ).",
                setup: () => {
                    setMode('tangent');
                    const kQ = 500;
                    state.initialV = kQ / state.r;
                    state.work = 0;
                },
                check: () => Math.abs(state.angle) > 90
            },
            {
                title: "Zero Work!",
                text: "The work stayed at <strong>0 Joules</strong> the entire time!<br><br>This confirms it: Moving along an equipotential surface is <em>perpendicular</em> to the electric field.<br><br>The electric field lines point <strong>radially outward</strong>, while the equipotential surfaces are <strong>concentric spheres</strong>.<br><br>They are always perpendicular to each other.",
                setup: () => {
                    unlock('ctrl-mode');
                },
                check: () => true
            },
            {
                title: "Moving Radially",
                text: "Now switch to <strong>'Radial'</strong> mode and move inward or outward.<br><br>This time, you are moving <em>perpendicular</em> to the equipotential surface (along the field lines).<br><br><strong>Task:</strong> Change the distance and observe the Work Done.",
                setup: () => {
                    setMode('radial');
                },
                check: () => state.r < 8 || state.r > 15
            },
            {
                title: "Conclusion",
                text: "By moving radially, you did work! The Potential Changed, and so did the Energy.<br><br><strong>Summary:</strong><br>• Equipotential surfaces are regions where $V$ is constant.<br>• Moving along them does <strong>zero work</strong>.<br>• Electric field lines are <strong>perpendicular</strong> to equipotential surfaces.<br><br>This is the geometric picture of Conservative Forces!",
                setup: () => {
                    unlock('ctrl-mode');
                    unlock('ctrl-angle');
                    unlock('ctrl-dist');
                    document.getElementById('btn-next').innerText = "Next Chapter";
                    document.getElementById('btn-next').disabled = false;
                },
                check: () => true
            }
        ];

        let currentChapter = 0;

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.getElementById('chapter-content').innerHTML = `
                <div class="chapter-title">${l.title}</div>
                <div class="story-text">${l.text}</div>
            `;
            if (window.MathJax && window.MathJax.typesetPromise) window.MathJax.typesetPromise();

            const btn = document.getElementById('btn-next');
            btn.disabled = !l.check();

            if (l.setup) l.setup();
            checkAdvance();
        }

        function checkAdvance() {
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.parent.location.href = '/lesson/chapter5/conservative_forces';
            }
        }
        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }

        function lock(id) {
            const el = document.getElementById(id);
            if (el) {
                el.classList.remove('active');
                const input = el.querySelector('input, button');
                if (input) input.disabled = true;
            }
        }
        function unlock(id) {
            const el = document.getElementById(id);
            if (el) {
                el.classList.add('active');
                const inputs = el.querySelectorAll('input, button');
                inputs.forEach(input => input.disabled = false);
            }
        }

        loadLesson(0);

        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -d * newAspect; camera.right = d * newAspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

    </script>
</body>

</html>
<!-- END OF FILE -->