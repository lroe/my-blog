<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>The Invisible Web: Electric Flux</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT (Preserved) --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #e0e6ed;
            --accent: #ff9f43;
            --accent-hover: #ffb773;
            --border: #2c313a;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', Roboto, Helvetica, sans-serif;
            overflow: hidden;
        }

        /* LEFT PANEL */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.6);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.1);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 700;
        }

        .subtitle {
            font-size: 13px;
            color: #8892b0;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 20px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 15px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #bdc3c7;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        .math-block {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #333;
            color: #fff;
            text-align: center;
        }

        /* CONTROLS AREA */
        #controls-area {
            background: #131519;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 20px;
            opacity: 0.4;
            pointer-events: none;
            transition: 0.4s;
            filter: grayscale(1);
            position: relative;
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            font-weight: 700;
        }

        button {
            background: #2c313a;
            color: #aaa;
            border: 1px solid #3d4450;
            padding: 12px 15px;
            cursor: pointer;
            border-radius: 6px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 0.5px;
        }

        button:hover {
            background: #3d4450;
            color: #fff;
            border-color: #555;
        }

        button:active {
            transform: translateY(1px);
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
            height: 6px;
            background: #333;
            border-radius: 3px;
        }

        /* FLUX METER */
        #flux-meter-container {
            margin-top: 15px;
            background: #000;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            text-align: center;
        }

        #flux-value {
            font-family: 'Courier New', monospace;
            font-size: 24px;
            color: var(--accent);
            font-weight: bold;
        }

        #flux-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            margin-top: 5px;
        }

        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px 25px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #111;
        }

        .nav-btn {
            width: 48%;
            background: #222;
            color: #fff;
            border: none;
        }

        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            font-weight: 800;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
            box-shadow: 0 0 15px rgba(255, 159, 67, 0.4);
        }

        .nav-btn.next:disabled {
            background: #222;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
        }

        /* MAIN CANVAS */
        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Simulation: Electric Flux</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">

            <!-- 1. Introduce Surface -->
            <div class="control-row" id="ctrl-intro">
                <label>Step 1: The Surface</label>
                <button id="btn-intro" onclick="introduceSurface()">Place Sensing Surface</button>
            </div>

            <!-- 2. Rotate Surface -->
            <div class="control-row" id="ctrl-angle">
                <label>Step 2: Orientation (Angle &theta;)</label>
                <input type="range" id="slider-angle" min="0" max="180" value="90" step="1">
                <div style="font-size: 10px; color:#555; margin-top:5px; display:flex; justify-content:space-between;">
                    <span>Parallel (0&deg;)</span>
                    <span>Perpendicular (90&deg;)</span>
                </div>
            </div>

            <!-- 3. Scale Area -->
            <div class="control-row" id="ctrl-area">
                <label>Step 3: Surface Area (A)</label>
                <input type="range" id="slider-area" min="1" max="5" value="3" step="0.1">
            </div>

            <div class="control-row active" style="margin-top:0px; border-top:1px solid #2c313a; padding-top:10px;">
                <div id="flux-meter-container">
                    <div id="flux-value">0.00</div>
                    <div id="flux-label">Total Flux (&Phi;<sub>E</sub>)</div>
                </div>
            </div>

            <!-- Reset -->
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; padding-top:5px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <button style="background:transparent; border:1px solid #333; font-size:11px;"
                    onclick="resetSim()">Reset Experiment</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Uniform Electric Field (E)</div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const state = {
            surfaceVisible: false,
            angle: 90, // Degrees
            area: 3,
            fieldStrength: 10,
            time: 0
        };

        const scene = new THREE.Scene();

        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 35;

        // Isometric-ish view
        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );

        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('world').appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);

        // --- OBJECTS ---

        // 1. Uniform Field Lines (Background)
        const fieldGroup = new THREE.Group();
        const lineCount = 60;
        const lineSpacing = 3;

        // Create arrows representing E field flowing +X
        for (let z = -15; z < 15; z += lineSpacing) {
            for (let y = -15; y < 15; y += lineSpacing) {
                if (y * y + z * z < 180) { // Circle crop for aesthetics
                    const length = 40;

                    // Shaft
                    const geometry = new THREE.CylinderGeometry(0.05, 0.05, length, 4);
                    geometry.rotateZ(-Math.PI / 2);
                    const material = new THREE.MeshBasicMaterial({ color: 0x54a0ff, transparent: true, opacity: 0.2 });
                    const line = new THREE.Mesh(geometry, material);

                    // Small dashes/particles to show flow direction
                    const dashGeo = new THREE.BoxGeometry(1, 0.2, 0.2);
                    const dashMat = new THREE.MeshBasicMaterial({ color: 0xaaddff });
                    const dash = new THREE.Mesh(dashGeo, dashMat);

                    // Randomize start pos for flow
                    dash.position.x = (Math.random() - 0.5) * length;
                    dash.userData = { speed: 0.1 + Math.random() * 0.1, limit: length / 2 };

                    line.add(dash);
                    line.position.set(0, y, z);
                    fieldGroup.add(line);
                }
            }
        }
        scene.add(fieldGroup);

        // 2. The Surface (The Net)
        const surfaceGroup = new THREE.Group();

        // The Plane
        const planeGeo = new THREE.PlaneGeometry(1, 1); // Unit size, scaled later
        // Double sided, transparent
        const planeMat = new THREE.MeshStandardMaterial({
            color: 0xff9f43,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.0,
            metalness: 0.1,
            roughness: 0.2,
            emissive: 0xff9f43,
            emissiveIntensity: 0
        });
        const planeMesh = new THREE.Mesh(planeGeo, planeMat);
        surfaceGroup.add(planeMesh);

        // The Frame (Border)
        const edges = new THREE.EdgesGeometry(planeGeo);
        const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
        const wireframe = new THREE.LineSegments(edges, lineMat);
        planeMesh.add(wireframe);

        // The Normal Vector (Arrow pointing perpendicular)
        const normalGroup = new THREE.Group();
        const nShaftGeo = new THREE.CylinderGeometry(0.08, 0.08, 3, 8);
        nShaftGeo.translate(0, 1.5, 0); // Pivot at base
        nShaftGeo.rotateX(Math.PI / 2); // Point Z (which is normal for PlaneGeometry)
        const nMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const nShaft = new THREE.Mesh(nShaftGeo, nMat);

        const nHeadGeo = new THREE.ConeGeometry(0.25, 0.6, 8);
        nHeadGeo.rotateX(Math.PI / 2);
        nHeadGeo.translate(0, 0, 3);
        const nHead = new THREE.Mesh(nHeadGeo, nMat);

        normalGroup.add(nShaft, nHead);

        // Label for Normal
        function createTextSprite(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 40px Arial';
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.fillText(text, 64, 45);
            const tex = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: tex });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(2, 1, 1);
            return sprite;
        }
        const labelN = createTextSprite("n (Normal)");
        labelN.position.set(0, 0, 4);
        normalGroup.add(labelN);

        surfaceGroup.add(normalGroup);
        scene.add(surfaceGroup);

        // Initial State
        surfaceGroup.visible = false;
        // Default rotation: Facing the camera, which is confusing relative to flow
        // Let's set rotation so Normal points UP initially (90deg to flow)
        surfaceGroup.rotation.y = Math.PI / 2;

        // ==========================================
        // PART 2: ANIMATION LOOP
        // ==========================================

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.02;

            // Animate Field Flow
            fieldGroup.children.forEach(line => {
                const dash = line.children[0];
                dash.position.x += dash.userData.speed * 2;
                if (dash.position.x > dash.userData.limit) {
                    dash.position.x = -dash.userData.limit;
                }
            });

            if (state.surfaceVisible) {
                // Apply Area Scale
                planeMesh.scale.set(state.area, state.area, 1);
                wireframe.scale.set(1, 1, 1); // inherit from parent

                // Calculate Flux Logic
                // Field is Vector3(1, 0, 0)
                // Normal Vector in World Space
                const normalVector = new THREE.Vector3(0, 0, 1);
                normalVector.applyQuaternion(surfaceGroup.quaternion);

                // Dot Product: |E| * |A| * cos(theta)
                // E is along X (1,0,0)
                const dotProduct = normalVector.x; // because field is (1,0,0)

                // Flux Calculation
                const magnitude = Math.abs(dotProduct);
                const flux = state.fieldStrength * (state.area * state.area) * magnitude;

                // Update UI Number
                document.getElementById('flux-value').innerText = flux.toFixed(1);

                // Visual Feedback
                // Opacity based on flux (more flux = more solid/glowing)
                const visualIntensity = 0.1 + (magnitude * 0.6);
                planeMat.opacity = visualIntensity;
                planeMat.emissiveIntensity = magnitude * 0.8;

                // Color shift: If dot product is negative (flux entering back), maybe slightly different?
                // For now, let's keep it orange/gold.
            }

            renderer.render(scene, camera);
        }
        animate();

        // ==========================================
        // PART 3: LOGIC & NARRATIVE
        // ==========================================

        let currentChapter = 0;

        function introduceSurface() {
            state.surfaceVisible = true;
            surfaceGroup.visible = true;

            // Start angle at 90 (perpendicular to flow, meaning normal aligns with flow)
            // Wait, if normal aligns with flow, dot product is 1.
            // Let's set slider to correspond to visual logic.
            // Slider 90deg -> Surface is Perpendicular to flow -> Max Flux.
            updateSurfaceRotation(90);
            document.getElementById('slider-angle').value = 90;

            document.getElementById('btn-intro').disabled = true;
            checkAdvance();
        }

        // Handle Rotation Slider
        document.getElementById('slider-angle').addEventListener('input', (e) => {
            updateSurfaceRotation(parseFloat(e.target.value));
            checkAdvance();
        });

        function updateSurfaceRotation(deg) {
            // We want 90deg on slider to mean Normal is parallel to Field (Max Flux)
            // We want 0deg on slider to mean Normal is perpendicular to Field (Zero Flux)

            // Field is X axis.
            // Plane creates in XY plane, Normal is Z.
            // If we rotate Plane Y by 90deg, Normal points X.

            const radians = (deg) * (Math.PI / 180);
            // Mapping: 
            // Slider 0 -> Plane Parallel to flow -> Normal points Z -> Rot Y = 0
            // Slider 90 -> Plane Perp to flow -> Normal points X -> Rot Y = 90

            surfaceGroup.rotation.y = radians;
            state.angle = deg;
        }

        // Handle Area Slider
        document.getElementById('slider-area').addEventListener('input', (e) => {
            state.area = parseFloat(e.target.value);
            checkAdvance();
        });

        function resetSim() {
            state.surfaceVisible = false;
            surfaceGroup.visible = false;
            state.area = 3;
            state.angle = 90;

            document.getElementById('slider-area').value = 3;
            document.getElementById('slider-angle').value = 90;
            document.getElementById('btn-intro').disabled = false;
            document.getElementById('flux-value').innerText = "0.00";

            loadLesson(0);
        }

        // --- LESSON CONTENT ---

        const lessons = [
            {
                title: "Concept: The Flow",
                text: "Imagine the Electric Field (<strong style='color:#54a0ff'>Blue Lines</strong>) as rain falling, or water flowing in a river.<br><br><strong>Electric Flux</strong> is a measure of how much of this field passes through a specific surface area.<br><br>Currently, we have the field, but no surface. <span class='instruction-inline'>Click 'PLACE SENSING SURFACE'</span> to insert a test area.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-intro');
                },
                check: () => state.surfaceVisible
            },
            {
                title: "Orientation matters",
                text: "Notice the white arrow. This is the <strong>Normal Vector (n)</strong>. It always points perpendicular (90Â°) sticking out of the surface.<br><br>Flux depends heavily on angle. <br>1. If the surface faces the flow directly, we catch the most 'rain'.<br>2. If the surface is edge-on, nothing passes through.<br><br><span class='instruction-inline'>Drag the Angle Slider</span> to 0&deg; (Parallel) and observe the Flux Meter drop to zero.",
                setup: () => {
                    unlock('ctrl-angle');
                },
                check: () => state.angle < 10 // User must rotate to near 0
            },
            {
                title: "Area & Magnitude",
                text: "Flux is also determined by the size of the net. A larger bucket catches more rain.<br><br>Mathematically, Flux ($\Phi_E$) is the product of the Field Strength ($E$) and the Area ($A$).<br><br><span class='instruction-inline'>Increase the Area</span> using the slider and watch the calculated value rise.",
                setup: () => {
                    unlock('ctrl-area');
                    unlock('ctrl-angle'); // Keep angle unlocked
                },
                check: () => state.area > 4.5
            },
            {
                title: "Conclusion",
                text: "We combine these factors into the definition of Electric Flux:<br><br><div class='math-block'>&Phi;<sub>E</sub> = E &middot; A = |E||A|cos(&theta;)</div><br>Where <strong>&theta;</strong> is the angle between the Field and the Normal Vector.<br><br>When the Normal is parallel to the Field (slider at 90&deg; here), cos(0&deg;) = 1, giving maximum flux. When they are perpendicular (slider at 0&deg;), cos(90&deg;) = 0.<br><br>Now that we understand how flux passes through a flat surface, what happens when we use a curved surface? Let's explore.",
                setup: () => {
                    // All unlocked
                },
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div>
             <div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');


            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }

            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.top.location.href = '/theapplefalls/lesson/2_flux';
            }
        }
        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }
        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        // Init
        loadLesson(0);

        // Resize Handle
        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * newAspect / 2;
            camera.right = viewSize * newAspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

    </script>
</body>

</html>