<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Gauss's Notebook: The Law</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #e0e6ed;
            --accent: #ff9f43;
            --accent-hover: #ffb773;
            --border: #2c313a;
            --math-color: #54a0ff;
            --danger: #ff6b6b;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', Roboto, Helvetica, sans-serif;
            overflow: hidden;
        }

        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.6);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.1);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 700;
        }

        .subtitle {
            font-size: 13px;
            color: #8892b0;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 20px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 15px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #bdc3c7;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        .math-block {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #333;
            color: var(--math-color);
            text-align: center;
        }

        #controls-area {
            background: #131519;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 20px;
            opacity: 0.4;
            pointer-events: none;
            transition: 0.4s;
            filter: grayscale(1);
            position: relative;
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            font-weight: 700;
        }

        button {
            background: #2c313a;
            color: #aaa;
            border: 1px solid #3d4450;
            padding: 12px 15px;
            cursor: pointer;
            border-radius: 6px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 0.5px;
        }

        button:hover {
            background: #3d4450;
            color: #fff;
            border-color: #555;
        }

        button:active {
            transform: translateY(1px);
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
            height: 6px;
            background: #333;
            border-radius: 3px;
        }

        #nav-footer {
            padding: 20px 25px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #111;
        }

        .nav-btn {
            width: 48%;
            background: #222;
            color: #fff;
            border: none;
        }

        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            font-weight: 800;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
            box-shadow: 0 0 15px rgba(255, 159, 67, 0.4);
        }

        .nav-btn.next:disabled {
            background: #222;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
        }

        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }

        /* --- FLUX METER --- */
        #flux-meter {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(20, 20, 20, 0.8);
            border: 1px solid var(--border);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
            min-width: 200px;
        }

        .meter-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .meter-value {
            font-size: 24px;
            color: var(--accent);
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        .meter-bar-bg {
            height: 6px;
            background: #333;
            width: 100%;
            margin-top: 8px;
            border-radius: 3px;
            overflow: hidden;
        }

        .meter-bar-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Gauss's Notebook</h1>
            <div class="subtitle">Simulation: Maxwell's 1st Eq</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- 1. Shape -->
            <div class="control-row" id="ctrl-shape">
                <label>Step 1: Surface Geometry</label>
                <div style="display:flex; gap:10px;">
                    <button id="btn-sphere" onclick="setShape('sphere')">Sphere</button>
                    <button id="btn-cube" onclick="setShape('cube')">Cube</button>
                    <!-- UPDATED LABEL -->
                    <button id="btn-blob" onclick="setShape('blob')">Knot</button>
                </div>
            </div>

            <!-- 2. Show Lines -->
            <div class="control-row" id="ctrl-lines">
                <label>Step 2: Electric Field Lines</label>
                <button id="btn-lines" onclick="toggleLines()">Toggle Field Lines</button>
            </div>

            <!-- 3. Move Charge -->
            <div class="control-row" id="ctrl-charge">
                <label>Step 3: External Charge (-Q)</label>
                <input type="range" id="slider-charge" min="0" max="100" value="100" oninput="moveCharge(this.value)">
                <div style="display:flex; justify-content:space-between; font-size:10px; color:#555; margin-top:5px;">
                    <span>INSIDE</span>
                    <span>SURFACE BOUNDARY</span>
                    <span>OUTSIDE</span>
                </div>
            </div>

            <!-- Reset -->
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Experiment Control</label>
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Vacuum Space (ε₀)</div>

        <div id="flux-meter">
            <div class="meter-label">Total Flux (Φ)</div>
            <div class="meter-value" id="flux-display">1 Q/ε₀</div>
            <div class="meter-bar-bg">
                <div class="meter-bar-fill" id="flux-bar" style="width: 50%;"></div>
            </div>
        </div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const state = {
            currentShape: 'sphere',
            linesVisible: false,
            extChargePos: 100, // 0 to 100 slider value
            isInside: false
        };

        const scene = new THREE.Scene();
        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 40;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );
        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('world').appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);

        // Grid
        const gridHelper = new THREE.GridHelper(100, 20, 0x2c313a, 0x181a1f);
        gridHelper.position.y = -10;
        scene.add(gridHelper);

        // --- OBJECTS ---

        // 1. Central Charge (+Q)
        const q1Geo = new THREE.IcosahedronGeometry(1.5, 2);
        const q1Mat = new THREE.MeshStandardMaterial({ color: 0xff6b6b, emissive: 0x550000 });
        const q1Mesh = new THREE.Mesh(q1Geo, q1Mat);
        scene.add(q1Mesh);

        // 2. External Charge (-Q)
        const q2Geo = new THREE.IcosahedronGeometry(1, 2);
        const q2Mat = new THREE.MeshStandardMaterial({ color: 0x4ecdc4, emissive: 0x004444 }); // Cyan
        const q2Mesh = new THREE.Mesh(q2Geo, q2Mat);
        scene.add(q2Mesh);

        // Labels
        function createTextSprite(text, color, scale = 1) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 60px Arial';
            ctx.fillStyle = color;
            ctx.textAlign = "center";
            ctx.fillText(text, 128, 80);
            const tex = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, depthTest: false }));
            sprite.scale.set(scale * 2, scale, 1);
            sprite.renderOrder = 100;
            return sprite;
        }
        const labelQ1 = createTextSprite("+Q", "#ff6b6b", 2.5);
        labelQ1.position.set(0, 2.5, 0);
        scene.add(labelQ1);

        const labelQ2 = createTextSprite("-Q", "#4ecdc4", 2);
        q2Mesh.add(labelQ2);
        labelQ2.position.set(0, 2, 0);

        // 3. Gaussian Surfaces
        const surfGroup = new THREE.Group();
        scene.add(surfGroup);

        const matSurf = new THREE.MeshBasicMaterial({ color: 0xff9f43, wireframe: true, transparent: true, opacity: 0.3 });

        // --- FIX 1: Material Update ---
        // Added depthWrite: false to stop transparency sorting issues (the "filled" look)
        const matSurfSolid = new THREE.MeshPhongMaterial({
            color: 0xff9f43,
            transparent: true,
            opacity: 0.15,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        // Sphere
        const sphereGeo = new THREE.IcosahedronGeometry(8, 2);
        const sphereMesh = new THREE.Mesh(sphereGeo, matSurf);
        const sphereFill = new THREE.Mesh(sphereGeo, matSurfSolid);
        sphereMesh.add(sphereFill);
        surfGroup.add(sphereMesh);

        // Cube
        const boxGeo = new THREE.BoxGeometry(13, 13, 13);
        const boxMesh = new THREE.Mesh(boxGeo, matSurf);
        const boxFill = new THREE.Mesh(boxGeo, matSurfSolid);
        boxMesh.add(boxFill);
        boxMesh.visible = false;
        surfGroup.add(boxMesh);

        // --- FIX 2: Replaced Random Blob with Torus Knot ---
        // Monkey geometry requires external loader. TorusKnot is the standard complex built-in.
        // 6 = Radius, 2 = Tube diameter
        const blobGeo = new THREE.TorusKnotGeometry(6, 2, 100, 16);
        const blobMesh = new THREE.Mesh(blobGeo, matSurf);
        const blobFill = new THREE.Mesh(blobGeo, matSurfSolid);
        blobMesh.add(blobFill);
        blobMesh.visible = false;
        surfGroup.add(blobMesh);

        // 4. Field Lines (Rays)
        const linesGroup = new THREE.Group();
        scene.add(linesGroup);
        linesGroup.visible = false;

        const lineCount = 60;
        for (let i = 0; i < lineCount; i++) {
            // Random spherical direction
            const phi = Math.acos(-1 + (2 * i) / lineCount);
            const theta = Math.sqrt(lineCount * Math.PI) * phi;
            const dir = new THREE.Vector3(
                Math.cos(theta) * Math.sin(phi),
                Math.sin(theta) * Math.sin(phi),
                Math.cos(phi)
            );

            const lg = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), dir.multiplyScalar(20)]);
            const lm = new THREE.Line(lg, new THREE.LineBasicMaterial({ color: 0x54a0ff, transparent: true, opacity: 0.6 }));
            linesGroup.add(lm);
        }

        // ==========================================
        // PART 2: LOGIC & ANIMATION
        // ==========================================

        let time = 0;

        function updatePhysics() {
            // Handle Shape Switching
            sphereMesh.visible = (state.currentShape === 'sphere');
            boxMesh.visible = (state.currentShape === 'cube');
            blobMesh.visible = (state.currentShape === 'blob');

            // Handle Lines
            linesGroup.visible = state.linesVisible;

            // Handle External Charge Position
            // Map slider 0-100 to X position 20 to 5
            // Boundary is roughly at slider=30 (x=8)
            const xPos = 4 + (state.extChargePos / 100) * 20;
            q2Mesh.position.set(xPos, 0, 0);

            // Check if inside
            let limit = 8; // Sphere default
            if (state.currentShape === 'cube') limit = 6.5;
            // Torus knot is wider/more complex, effective boundary is around 7
            if (state.currentShape === 'blob') limit = 7.5;

            state.isInside = (xPos < limit);

            // Update Flux Meter
            // +Q is always inside (+1). -Q is conditional (-1).
            let flux = 1;
            if (state.isInside) flux -= 1; // Net 0

            const disp = document.getElementById('flux-display');
            const bar = document.getElementById('flux-bar');

            if (flux === 1) {
                disp.innerText = "+Q / ε₀";
                disp.style.color = "#ff9f43";
                bar.style.width = "80%";
                bar.style.backgroundColor = "#ff9f43";
            } else if (flux === 0) {
                disp.innerText = "0";
                disp.style.color = "#e0e6ed";
                bar.style.width = "0%";
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.005;

            // Rotate surfaces slowly
            surfGroup.rotation.y = Math.sin(time * 0.5) * 0.1;
            surfGroup.rotation.z = Math.cos(time * 0.3) * 0.05;

            // Float Charges
            q1Mesh.position.y = Math.sin(time * 2) * 0.2;
            labelQ1.position.y = 2.5 + Math.sin(time * 2) * 0.2;

            q2Mesh.position.y = Math.sin(time * 2 + 1) * 0.2;

            renderer.render(scene, camera);
        }
        animate();

        // ==========================================
        // PART 3: CONTROLLER
        // ==========================================

        let currentChapter = 0;

        function setShape(shape) {
            state.currentShape = shape;
            updatePhysics();
            checkAdvance();
        }

        function toggleLines() {
            state.linesVisible = !state.linesVisible;
            document.getElementById('btn-lines').innerText = state.linesVisible ? "Hide Lines" : "Show Field Lines";
            updatePhysics();
            checkAdvance();
        }

        function moveCharge(val) {
            state.extChargePos = val;
            updatePhysics();
            checkAdvance();
        }

        function resetSim() {
            state.currentShape = 'sphere';
            state.linesVisible = false;
            state.extChargePos = 100;
            document.getElementById('slider-charge').value = 100;
            document.getElementById('btn-lines').innerText = "Toggle Field Lines";

            lockAll();
            loadLesson(0);
            updatePhysics();
        }

        const lessons = [
            {
                title: "Gauss's Law",
                text: "Gauss's Law relates the electric flux flowing out of a closed surface to the charge trapped inside.<br><br>The formula is surprisingly simple:<br><div class='math-block'>Φ = ∮ E · dA = Q_enclosed / ε₀</div><br>Currently, we have a sphere enclosing <strong>+Q</strong>. The Flux Meter shows a positive value because field lines are pushing <strong>out</strong>.<br><br><span class='instruction-inline'>Click 'Show Field Lines'</span> to see the flow.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-lines');
                },
                check: () => state.linesVisible
            },
            {
                title: "Shape Independence",
                text: "Does the Flux depend on the shape of the trap? <br><br>If we change the sphere to a box or a complex knot, the local Electric Field (E) and Area (dA) vectors change drastically. However, the <strong>total number of field lines</strong> poking through the surface remains exactly the same.<br><br><span class='instruction-inline'>Try changing the Surface Geometry</span>.",
                setup: () => {
                    unlock('ctrl-shape');
                },
                check: () => state.currentShape !== 'sphere'
            },
            {
                title: "Symmetry vs. Truth",
                text: "Notice that the Flux Meter stayed constant at <strong>Q/ε₀</strong> regardless of the shape.<br><br><strong>Crucial Concept:</strong> Gauss's Law is <em>always true</em> for any closed surface. <br><br>Even for this <strong>Torus Knot</strong>, which is topologically complex, if it wraps around the charge, the total flux calculation holds.",
                setup: () => { },
                check: () => true
            },
            {
                title: "The Enclosed Charge",
                text: "What happens if we introduce another charge? Here is <strong>-Q</strong> (Cyan).<br><br>As long as -Q is <strong>outside</strong>, any field line it sends into our surface must also exit the other side. Net contribution = 0.<br><br><span class='instruction-inline'>Drag the slider</span> to move -Q <strong>inside</strong> the surface.",
                setup: () => {
                    unlock('ctrl-charge');
                },
                check: () => state.isInside
            },
            {
                title: "Conclusion",
                text: "When -Q enters the surface, it cancels the flux from +Q.<br><br><div class='math-block'>Q_enc = (+Q) + (-Q) = 0</div><br>Field lines start at +Q and end at -Q <em>inside</em> the box. Nothing escapes. The total Flux drops to zero.<br><br>This proves that Flux depends <strong>only</strong> on what is caught inside the trap.",
                setup: () => { },
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Concept ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div>
             <div class="story-text">${l.text}</div>`;

            const btn = document.getElementById('btn-next');

            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Lesson Complete";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }

            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.top.location.href = '/theapplefalls/lesson/5_infitnite_plane';
            }
        } function prevLesson() { if (currentChapter > 0) loadLesson(currentChapter - 1); }
        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) document.getElementById('btn-next').disabled = false;
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        // Init
        loadLesson(0);
        updatePhysics();

        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * newAspect / 2;
            camera.right = viewSize * newAspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

    </script>
</body>

</html>