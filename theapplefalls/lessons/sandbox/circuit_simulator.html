<!DOCTYPE html>
<html>

<head>
    <title>Circuit Sandbox - Interactive 3D Simulator</title>
    <style>
        body {
            margin: 0;
            background-color: #282c34;
            color: white;
            font-family: sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #toolbar {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            max-height: calc(100vh - 40px);
            width: 160px;
            overflow-y: auto;
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }




        /* Custom Scrollbar Styling */
        #toolbar::-webkit-scrollbar {
            width: 6px;
        }

        #toolbar::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        #toolbar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
        }

        #toolbar::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        #toolbar button {
            margin-bottom: 10px;
            padding: 10px;
            font-size: 14px;
            cursor: pointer;
            border: 2px solid #666;
            background-color: #555;
            color: white;
            width: 100%;
            text-align: center;
        }

        #toolbar button:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        #toolbar button.selected {
            border-color: #00aaff;
            background-color: #0077bb;
        }

        #toolbar button.simulate-active {
            border-color: #00ff00;
            background-color: #00aa00;
        }

        #toolbar button:disabled {
            background-color: #333;
            color: #777;
            cursor: not-allowed;
            border-color: #444;
        }

        .section-label {
            font-weight: bold;
            margin-bottom: 5px;
            border-bottom: 1px solid #777;
            padding-bottom: 5px;
            margin-top: 10px;
        }

        .section-label:first-child {
            margin-top: 0;
        }

        /* Glassmorphism Info Panel */
        #info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            width: 240px;
            display: none;
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }




        #info-panel h3 {
            margin-top: 0;
            border-bottom: 1px solid #777;
            padding-bottom: 5px;
            margin-bottom: 15px;
        }

        #info-panel p {
            margin: 8px 0;
            font-size: 14px;
            color: #cbd5e1;
            display: flex;
            justify-content: space-between;
        }

        #info-panel span {
            color: #f8fafc;
            font-weight: 600;
        }
    </style>
</head>

<body>
    <div id="toolbar">
        <div class="section-label">Sandbox</div>
        <button id="tool-reset-cam">Reset Camera</button>
        <button id="tool-clear" style="background-color: #883333;">Clear All</button>

        <div class="section-label">File</div>
        <button id="tool-save">Save</button>
        <button id="tool-load">Load</button>

        <div class="section-label">Mode</div>
        <button id="tool-simulate">Simulate</button>
        <div class="section-label">History</div>
        <button id="tool-undo" disabled>Undo</button>
        <button id="tool-redo" disabled>Redo</button>
        <div class="section-label">Example</div>
        <button id="tool-example-not" style="background-color: #7744aa;">NOT Gate</button>
        <button id="tool-example-alu" style="background-color: #aa4477;">1-bit ALU (Gates)</button>


        <div class="section-label" style="margin-top:10px;">Tools</div>
        <button id="tool-select" class="selected">Select/Move</button>
        <button id="tool-wire">Wire</button>
        <button id="tool-edit-wire">Edit Wire</button>
        <div class="section-label" style="margin-top:10px;">Components</div>
        <button id="tool-battery">Battery</button>
        <button id="tool-capacitor">Capacitor</button>
        <button id="tool-switch">Switch</button>
        <button id="tool-bulb">Bulb</button>
        <button id="tool-fuse">Fuse</button>
        <button id="tool-motor">Motor</button>
        <button id="tool-resistor">Resistor</button>
        <div class="section-label" style="margin-top:10px;">Logic Gates</div>
        <button id="tool-and_gate">AND Gate</button>
        <button id="tool-or_gate">OR Gate</button>
        <button id="tool-not_gate">NOT Gate</button>
        <button id="tool-xor_gate">XOR Gate</button>
        <div class="section-label" style="margin-top:10px;">Logic</div>
        <button id="tool-npn">NPN Transistor</button>
        <button id="tool-pnp">PNP Transistor</button>
        <button id="tool-vcc">VCC (+5V)</button>
        <button id="tool-gnd">GND (0V)</button>
        <button id="tool-probe">Logic Probe</button>

    </div>

    <div id="info-panel">
        <h3 id="info-title">Component</h3>
        <div id="battery-info" style="display: none;">
            <p>Voltage: <span id="info-battery-voltage">9.0 V</span></p>
        </div>
        <div id="capacitor-info" style="display: none;">
            <p>Capacitance: <span id="info-capacitance">1.0 F</span></p>
            <p>Charge: <span id="info-charge">0.00 C</span></p>
            <p>Voltage: <span id="info-voltage">0.00 V</span></p>
        </div>
        <div id="fuse-info" style="display: none;">
            <p>Max Energy: <span id="info-max-energy">50</span></p>
            <p>Current Energy: <span id="info-current-energy">0.00</span></p>
            <p>Status: <span id="info-fuse-status">OK</span></p>
        </div>
        <div id="motor-info" style="display: none;">
            <p>RPM: <span id="info-motor-rpm">0</span></p>
            <p>Status: <span id="info-motor-status">Stopped</span></p>
        </div>
        <div id="resistor-info" style="display: none;">
            <p>Resistance: <span id="info-resistance">100 &Omega;</span></p>
        </div>
        <div id="logic-info" style="display: none;">
            <p>State: <span id="info-logic-state">Floating</span></p>
            <p>Voltage: <span id="info-logic-voltage">0.0 V</span></p>
        </div>
    </div>

    <input type="file" id="load-file-input" style="display: none;" accept=".json">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/geometries/TextGeometry.js"></script>

    <script>
        // --- CONFIGURATION ---
        const DEBUG_MODE = true;
        let requestDebugFrame = false;

        // --- 1. SETUP ---
        const scene = new THREE.Scene();
        const frustumSize = 30;
        const aspect = window.innerWidth / window.innerHeight;
        const camera = new THREE.OrthographicCamera(
            frustumSize * aspect / -2, frustumSize * aspect / 2,
            frustumSize / 2, frustumSize / -2,
            0.1, 1000
        );
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 15, 5);
        scene.add(directionalLight);
        const gridHelper = new THREE.GridHelper(100, 100, 0x888888, 0x444444);
        scene.add(gridHelper);

        // --- 2. GAME STATE ---
        let currentTool = 'select';
        let isSimulating = false;
        let components = [], wires = [], controlPoints = [];
        let ghostComponent = null, selectedComponent = null, selectedWire = null, selectedControlPoint = null;
        let isDragging = false;
        let wireStartNode = null;
        let nextId = 0;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const gridPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const nodeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const selectedNodeMaterial = new THREE.MeshBasicMaterial({ color: 0xff8800 });
        const infoPanel = document.getElementById('info-panel');
        let shiftPressed = false;

        // --- 3. UNDO/REDO ENGINE ---
        const historyStack = [];
        const redoStack = [];
        const undoButton = document.getElementById('tool-undo');
        const redoButton = document.getElementById('tool-redo');
        function executeAction(action, fromUndo = false) {
            let targetArray;
            switch (action.type) {
                case 'add':
                    targetArray = action.isWire ? wires : components; targetArray.push(action.object);
                    scene.add(action.object.mesh);
                    if (action.isWire) action.object.controlPoints.forEach(cp => scene.add(cp));
                    break;
                case 'remove':
                    targetArray = action.isWire ? wires : components;
                    const index = targetArray.indexOf(action.object); if (index > -1) targetArray.splice(index, 1);
                    scene.remove(action.object.mesh);
                    if (action.isWire) action.object.controlPoints.forEach(cp => scene.remove(cp));
                    break;
                case 'move':
                    action.object.mesh.position.copy(fromUndo ? action.from : action.to);
                    updateAttachedWires(action.object); break;
            }
            if (!fromUndo) { historyStack.push(action); redoStack.length = 0; } updateUndoRedoButtons();
        }
        function undo() { if (historyStack.length > 0) { const a = historyStack.pop(); executeAction(a, true); redoStack.push(a); } updateUndoRedoButtons(); }
        function redo() { if (redoStack.length > 0) { const a = redoStack.pop(); executeAction(a, false); historyStack.push(a); } updateUndoRedoButtons(); }
        function updateUndoRedoButtons() { undoButton.disabled = historyStack.length === 0; redoButton.disabled = redoStack.length === 0; }
        undoButton.addEventListener('click', undo);
        redoButton.addEventListener('click', redo);

        // --- 4. COMPONENT & WIRE FACTORIES ---
        function createComponentModel(type) {
            const mesh = new THREE.Group();
            let componentData = { id: -1, type: type, mesh: mesh, nodes: [], isPowered: false, isOn: true };

            const highLevel = 1.5, lowLevel = -1.5;

            if (type === 'battery') {
                componentData.voltage = 9.0;
                const body = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3.0, 1.5), new THREE.MeshStandardMaterial({ color: 0x333333 }));
                body.position.y = 1.5;
                mesh.add(body);
                const loader = new THREE.FontLoader();
                loader.load('https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                    const createText = (text, position, color) => {
                        const textGeo = new THREE.TextGeometry(text, { font: font, size: 0.5, height: 0.1 });
                        const textMesh = new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial({ color: color }));
                        textGeo.center();
                        textMesh.position.copy(position);
                        return textMesh;
                    };
                    mesh.add(createText('+', new THREE.Vector3(0, 3.4, 0), 0xffffff));
                    mesh.add(createText('-', new THREE.Vector3(0, -0.4, 0), 0xffffff));
                });
                addNode(componentData, new THREE.Vector3(0, 3.0, 0));
                addNode(componentData, new THREE.Vector3(0, 0, 0));
            }
            else if (type === 'capacitor') {
                componentData.capacitance = 1.0;
                componentData.charge = 0.0;
                componentData.voltage = 0.0;
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 2.0, 32), new THREE.MeshStandardMaterial({ color: 0x0077be }));
                body.position.y = 1.0;
                mesh.add(body);
                addNode(componentData, new THREE.Vector3(0, 2.0, 0));
                addNode(componentData, new THREE.Vector3(0, 0, 0));
            }
            else if (type === 'switch') {
                componentData.isOn = false;
                const b = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.2, 1.5), new THREE.MeshStandardMaterial({ color: 0x4a4a4a }));
                const l = new THREE.Mesh(new THREE.BoxGeometry(0.2, 2.0, 0.2), new THREE.MeshStandardMaterial({ color: 0xcccccc }));
                l.position.y = 1.0;
                l.name = 'lever';
                mesh.add(b, l);
                addNode(componentData, new THREE.Vector3(-1.0, 0.1, 0));
                addNode(componentData, new THREE.Vector3(1.0, 0.1, 0));
            }
            else if (type === 'bulb') {
                const b = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.6, 32), new THREE.MeshStandardMaterial({ color: 0x502A19 }));
                b.position.y = 0.3;
                const g = new THREE.Mesh(new THREE.SphereGeometry(0.8, 32, 32), new THREE.MeshStandardMaterial({ color: 0xffff99, transparent: true, opacity: 0.6, emissive: 0x000000 }));
                g.position.y = 0.8;
                g.name = 'glass';
                mesh.add(b, g);
                addNode(componentData, new THREE.Vector3(0, 0.6, 0));
                addNode(componentData, new THREE.Vector3(0, 0, 0));
            }
            else if (type === 'fuse') {
                componentData.maxEnergy = 50.0;
                componentData.currentEnergy = 0.0;
                componentData.isBlown = false;

                const glassTube = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 2.5, 32), new THREE.MeshStandardMaterial({ color: 0xaaaaaa, transparent: true, opacity: 0.3 }));
                glassTube.position.y = 1.25;
                const endCap1 = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.2, 32), new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 1.0, roughness: 0.2 }));
                const endCap2 = endCap1.clone();
                endCap1.position.y = 2.5;
                endCap2.position.y = 0;

                const fuseWire = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2.5, 8), new THREE.MeshStandardMaterial({ color: 0xC0C0C0, emissive: 0x000000 }));
                fuseWire.name = 'fuse_wire';
                fuseWire.position.y = 1.25;

                mesh.add(glassTube, endCap1, endCap2, fuseWire);
                addNode(componentData, new THREE.Vector3(0, 2.6, 0));
                addNode(componentData, new THREE.Vector3(0, -0.1, 0));
            }
            else if (type === 'motor') {
                componentData.rpm = 0;

                // Motor Body
                const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), new THREE.MeshStandardMaterial({ color: 0x555555 }));
                body.position.y = 0.6;

                // Shaft
                const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.0, 16), new THREE.MeshStandardMaterial({ color: 0xcccccc }));
                shaft.rotation.x = Math.PI / 2;
                shaft.position.z = 0.8;
                shaft.position.y = 0.6;
                shaft.name = 'shaft';

                // Propeller/Fan on shaft to visualize rotation
                const prop = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.4, 0.1), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
                prop.position.y = 0;
                shaft.add(prop);

                mesh.add(body, shaft);
                addNode(componentData, new THREE.Vector3(0, 1.2, 0));
                addNode(componentData, new THREE.Vector3(0, 0, 0));
            }
            else if (type === 'resistor') {
                componentData.resistance = 100.0;
                const geometry = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 32);
                const material = new THREE.MeshStandardMaterial({ color: 0xf5deb3 }); // Beige
                const body = new THREE.Mesh(geometry, material);
                body.position.y = 0.75;

                // Bands
                const band1 = new THREE.Mesh(new THREE.CylinderGeometry(0.31, 0.31, 0.1, 32), new THREE.MeshBasicMaterial({ color: 0x8B4513 })); // Brown
                band1.position.y = 1.15;
                const band2 = new THREE.Mesh(new THREE.CylinderGeometry(0.31, 0.31, 0.1, 32), new THREE.MeshBasicMaterial({ color: 0x000000 })); // Black
                band2.position.y = 0.85;
                const band3 = new THREE.Mesh(new THREE.CylinderGeometry(0.31, 0.31, 0.1, 32), new THREE.MeshBasicMaterial({ color: 0x8B4513 })); // Brown
                band3.position.y = 0.55;

                mesh.add(body, band1, band2, band3);
                addNode(componentData, new THREE.Vector3(0, 1.5, 0));
                addNode(componentData, new THREE.Vector3(0, 0, 0));
            }
            else if (type === 'npn' || type === 'pnp') {
                // Materials
                const plasticMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.3, metalness: 0.1 });
                const metalMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.2, metalness: 0.9 });

                // Body (The "D" Shape)
                const shape = new THREE.Shape();
                const radius = 0.5;
                const flatOffset = 0.2;
                const angle = Math.acos(flatOffset / radius);
                shape.absarc(0, 0, radius, angle, -angle, false);
                shape.lineTo(radius * Math.cos(angle), -radius * Math.sin(angle));

                const extrudeSettings = {
                    depth: 1.0,
                    bevelEnabled: true,
                    bevelThickness: 0.05,
                    bevelSize: 0.05,
                    bevelSegments: 3
                };

                const bodyGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                bodyGeometry.center();
                const bodyMesh = new THREE.Mesh(bodyGeometry, plasticMaterial);
                bodyMesh.rotation.x = Math.PI / 2;
                bodyMesh.position.y = 1.1; // legHeight (0.6) + half bodyHeight (0.5)
                mesh.add(bodyMesh);

                // Legs
                const legHeight = 0.6;
                const legGeometry = new THREE.CylinderGeometry(0.08, 0.08, legHeight, 16);
                const legX = [-0.4, 0, 0.4];
                legX.forEach(x => {
                    const leg = new THREE.Mesh(legGeometry, metalMaterial);
                    leg.position.set(x, legHeight / 2, 0);
                    mesh.add(leg);
                });

                // Labels
                const loader = new THREE.FontLoader();
                loader.load('https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                    const createText = (text, position, color) => {
                        const textGeo = new THREE.TextGeometry(text, { font: font, size: 0.2, height: 0.05 });
                        const textMesh = new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial({ color: color }));
                        textGeo.center();
                        textMesh.position.copy(position);
                        return textMesh;
                    };
                    mesh.add(createText(type.toUpperCase(), new THREE.Vector3(0, 1.2, 0.5), 0xffffff));
                    mesh.add(createText('B', new THREE.Vector3(-0.4, 0.2, 0.2), 0xaaaaaa));
                    mesh.add(createText('C', new THREE.Vector3(0, 0.2, 0.2), 0xaaaaaa));
                    mesh.add(createText('E', new THREE.Vector3(0.4, 0.2, 0.2), 0xaaaaaa));
                });

                // Nodes: Base, Collector, Emitter
                addNode(componentData, new THREE.Vector3(-0.4, 0, 0)); // Base
                addNode(componentData, new THREE.Vector3(0, 0, 0));    // Collector
                addNode(componentData, new THREE.Vector3(0.4, 0, 0));  // Emitter
            }
            else if (type === 'vcc' || type === 'gnd') {
                const color = type === 'vcc' ? 0xff0000 : 0x0000ff;
                const body = new THREE.Mesh(new THREE.SphereGeometry(0.5, 32, 32), new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 }));
                body.position.y = 0.5;
                mesh.add(body);

                const loader = new THREE.FontLoader();
                loader.load('https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                    const textGeo = new THREE.TextGeometry(type.toUpperCase(), { font: font, size: 0.4, height: 0.1 });
                    const textMesh = new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial({ color: 0xffffff }));
                    textGeo.center();
                    textMesh.position.y = 1.3;
                    mesh.add(textMesh);
                });

                addNode(componentData, new THREE.Vector3(0, 0, 0));
            }
            else if (['and_gate', 'or_gate', 'not_gate', 'xor_gate'].includes(type)) {
                // Chip Body
                const bodyWidth = type === 'not_gate' ? 1.2 : 1.6;
                const body = new THREE.Mesh(new THREE.BoxGeometry(bodyWidth, 0.4, 1.2), new THREE.MeshStandardMaterial({ color: 0x111111 }));
                body.position.y = 0.2;
                mesh.add(body);

                // Pins
                const pinLength = 0.8; // Increased from 0.4
                const pinGeo = new THREE.CylinderGeometry(0.05, 0.05, pinLength, 8);
                const pinMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.8, roughness: 0.2 });

                if (type === 'not_gate') {
                    const pinIn = new THREE.Mesh(pinGeo, pinMat); pinIn.position.set(-bodyWidth / 2 - 0.2, 0.2, 0); pinIn.rotation.z = Math.PI / 2; mesh.add(pinIn);
                    const pinOut = new THREE.Mesh(pinGeo, pinMat); pinOut.position.set(bodyWidth / 2 + 0.2, 0.2, 0); pinOut.rotation.z = Math.PI / 2; mesh.add(pinOut);
                    addNode(componentData, new THREE.Vector3(-bodyWidth / 2 - 0.4, 0, 0)); // Input
                    addNode(componentData, new THREE.Vector3(bodyWidth / 2 + 0.4, 0, 0));  // Output
                } else {
                    const pinIn1 = new THREE.Mesh(pinGeo, pinMat); pinIn1.position.set(-bodyWidth / 2 - 0.2, 0.2, -0.3); pinIn1.rotation.z = Math.PI / 2; mesh.add(pinIn1);
                    const pinIn2 = new THREE.Mesh(pinGeo, pinMat); pinIn2.position.set(-bodyWidth / 2 - 0.2, 0.2, 0.3); pinIn2.rotation.z = Math.PI / 2; mesh.add(pinIn2);
                    const pinOut = new THREE.Mesh(pinGeo, pinMat); pinOut.position.set(bodyWidth / 2 + 0.2, 0.2, 0); pinOut.rotation.z = Math.PI / 2; mesh.add(pinOut);
                    addNode(componentData, new THREE.Vector3(-bodyWidth / 2 - 0.4, 0, -0.3)); // Input A
                    addNode(componentData, new THREE.Vector3(-bodyWidth / 2 - 0.4, 0, 0.3));  // Input B
                    addNode(componentData, new THREE.Vector3(bodyWidth / 2 + 0.4, 0, 0));     // Output
                }


                // Label
                const loader = new THREE.FontLoader();
                loader.load('https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                    const labelText = type.replace('_gate', '').toUpperCase();
                    const textGeo = new THREE.TextGeometry(labelText, { font: font, size: 0.25, height: 0.05 });
                    const textMesh = new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial({ color: 0xffffff }));
                    textGeo.center();
                    textMesh.rotation.x = -Math.PI / 2;
                    textMesh.position.y = 0.45;
                    mesh.add(textMesh);
                });
            }
            else if (type === 'probe') {

                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.4, 1.5, 32), new THREE.MeshStandardMaterial({ color: 0x444444 }));
                body.position.y = 0.75;
                const tip = new THREE.Mesh(new THREE.SphereGeometry(0.3, 32, 32), new THREE.MeshStandardMaterial({ color: 0x333333 }));
                tip.position.y = 1.55;
                tip.name = 'probe_tip';
                mesh.add(body, tip);
                addNode(componentData, new THREE.Vector3(0, 0, 0));
            }
            mesh.userData = componentData;
            return componentData;
        }
        function addNode(componentData, localPosition) { const n = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), nodeMaterial); n.position.copy(localPosition); n.visible = false; n.userData = { isNode: true, component: componentData }; componentData.nodes.push(n); componentData.mesh.add(n); }
        function createWire(startNode, endNode) { const cp = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({ color: 0xff8800 })); cp.position.copy(startNode.getWorldPosition(new THREE.Vector3())).lerp(endNode.getWorldPosition(new THREE.Vector3()), 0.3).add(new THREE.Vector3(0, 2, 0)); cp.userData = { isControlPoint: true }; cp.visible = false; controlPoints.push(cp); const w = { isWire: true, startNode, endNode, controlPoints: [cp], isPowered: false, mesh: new THREE.Mesh(new THREE.BufferGeometry(), new THREE.MeshStandardMaterial({ color: 0xb87333 })) }; w.mesh.userData.parentWire = w; updateWire(w); return w; }
        function updateWire(wire) { const p = [wire.startNode.getWorldPosition(new THREE.Vector3()), ...wire.controlPoints.map(cp => cp.position), wire.endNode.getWorldPosition(new THREE.Vector3())]; const c = new THREE.CatmullRomCurve3(p); wire.mesh.geometry.dispose(); wire.mesh.geometry = new THREE.TubeGeometry(c, 32, 0.08, 8); }
        function updateAttachedWires(component) { wires.forEach(w => { if (w.startNode.userData.component === component || w.endNode.userData.component === component) { updateWire(w); } }); }

        // --- 5. SIMULATION ENGINE (REWRITTEN LOGIC) ---

        function findPath(startNode, endNode) {
            const queue = [{ node: startNode, path: [] }];
            const visited = new Set([startNode]);

            while (queue.length > 0) {
                const { node, path } = queue.shift();

                if (node === endNode) {
                    return path;
                }

                const component = node.userData.component;
                let canTraverse = false;
                if (component.type === 'switch' && component.isOn) canTraverse = true;
                if (component.type === 'fuse' && !component.isBlown) canTraverse = true;
                if (component.type === 'bulb') canTraverse = true; // Bulbs are passive and can be traversed
                if (component.type === 'motor') canTraverse = true;
                if (component.type === 'resistor') canTraverse = true;
                if (component.type === 'capacitor' && component !== startNode.userData.component) canTraverse = true; // Allow traversing other capacitors

                if (canTraverse) {
                    const otherNode = component.nodes.find(n => n !== node);
                    if (otherNode && !visited.has(otherNode)) {
                        visited.add(otherNode);
                        const newPath = [...path, component];
                        if (otherNode === endNode) return newPath;
                        queue.push({ node: otherNode, path: newPath });
                    }
                }

                const connectedWires = wires.filter(w => w.startNode === node || w.endNode === node);
                for (const wire of connectedWires) {
                    const nextNode = (wire.startNode === node) ? wire.endNode : wire.startNode;
                    if (!visited.has(nextNode)) {
                        visited.add(nextNode);
                        const newPath = [...path, wire];
                        if (nextNode === endNode) return newPath;
                        queue.push({ node: nextNode, path: newPath });
                    }
                }
            }
            return null;
        }

        // --- NEW, CORRECTED analyzeCircuit function ---
        function analyzeCircuit() {
            const shouldDebug = DEBUG_MODE && requestDebugFrame;
            if (shouldDebug) console.log("--- Logic Analysis Start ---");

            // 1. Reset states
            components.forEach(c => {
                c.nodes.forEach(n => {
                    n.userData.logicState = 'FLOATING';
                    n.userData.strength = 0;
                });
                c.isPowered = false;
                c.logicState = 'Floating';
                c.logicVoltage = 0.0;
            });
            wires.forEach(w => w.isPowered = false);

            // 2. Initialize fixed sources
            components.forEach(c => {
                if (c.type === 'vcc') {
                    c.nodes[0].userData.logicState = 'HIGH';
                    c.nodes[0].userData.strength = 3;
                } else if (c.type === 'gnd') {
                    c.nodes[0].userData.logicState = 'LOW';
                    c.nodes[0].userData.strength = 3;
                } else if (c.type === 'battery') {
                    c.nodes[0].userData.logicState = 'HIGH';
                    c.nodes[0].userData.strength = 3;
                    c.nodes[1].userData.logicState = 'LOW';
                    c.nodes[1].userData.strength = 3;
                }
            });

            // 3. Propagate states (Iterative approach)
            let changed = true;
            let iterations = 0;
            const maxIterations = 50;

            while (changed && iterations < maxIterations) {
                changed = false;
                iterations++;

                // Propagate through wires
                wires.forEach(w => {
                    const n1 = w.startNode;
                    const n2 = w.endNode;
                    if (propagate(n1, n2, 0)) changed = true;
                    if (propagate(n2, n1, 0)) changed = true;
                });

                // Propagate through components
                components.forEach(c => {
                    if (c.type === 'switch' && c.isOn) {
                        if (propagate(c.nodes[0], c.nodes[1], 0)) changed = true;
                        if (propagate(c.nodes[1], c.nodes[0], 0)) changed = true;
                    } else if (c.type === 'resistor') {
                        if (propagate(c.nodes[0], c.nodes[1], 1)) changed = true;
                        if (propagate(c.nodes[1], c.nodes[0], 1)) changed = true;
                    } else if (c.type === 'npn') {
                        const baseHigh = c.nodes[0].userData.logicState === 'HIGH';
                        if (baseHigh) {
                            if (propagate(c.nodes[1], c.nodes[2], 0)) changed = true;
                            if (propagate(c.nodes[2], c.nodes[1], 0)) changed = true;
                        }
                    } else if (c.type === 'pnp') {
                        const baseLow = c.nodes[0].userData.logicState === 'LOW';
                        if (baseLow) {
                            if (propagate(c.nodes[1], c.nodes[2], 0)) changed = true;
                            if (propagate(c.nodes[2], c.nodes[1], 0)) changed = true;
                        }
                    } else if (c.type === 'bulb' || c.type === 'motor' || c.type === 'fuse') {
                        // These act like low-resistance paths for logic
                        if (propagate(c.nodes[0], c.nodes[1], 0)) changed = true;
                        if (propagate(c.nodes[1], c.nodes[0], 0)) changed = true;
                    } else if (['and_gate', 'or_gate', 'not_gate', 'xor_gate'].includes(c.type)) {
                        // Logic Gates are directional: Inputs -> Output
                        let outState = 'LOW';
                        if (c.type === 'not_gate') {
                            outState = (c.nodes[0].userData.logicState === 'HIGH') ? 'LOW' : 'HIGH';
                        } else {
                            const inA = c.nodes[0].userData.logicState === 'HIGH';
                            const inB = c.nodes[1].userData.logicState === 'HIGH';
                            if (c.type === 'and_gate') outState = (inA && inB) ? 'HIGH' : 'LOW';
                            else if (c.type === 'or_gate') outState = (inA || inB) ? 'HIGH' : 'LOW';
                            else if (c.type === 'xor_gate') outState = (inA !== inB) ? 'HIGH' : 'LOW';
                        }

                        const outNode = (c.type === 'not_gate') ? c.nodes[1] : c.nodes[2];
                        if (outNode.userData.logicState !== outState || outNode.userData.strength !== 2) {
                            outNode.userData.logicState = outState;
                            outNode.userData.strength = 2; // Gates provide a strong signal
                            changed = true;
                        }
                    }
                });

            }

            function propagate(fromNode, toNode, strengthLoss) {
                const fromState = fromNode.userData.logicState;
                const fromStrength = fromNode.userData.strength;
                if (fromState === 'FLOATING') return false;

                const newStrength = Math.max(0, fromStrength - strengthLoss);
                if (newStrength <= 0) return false;

                const toState = toNode.userData.logicState;
                const toStrength = toNode.userData.strength;

                if (toState === 'FLOATING' || newStrength > toStrength || (newStrength === toStrength && fromState !== toState)) {
                    toNode.userData.logicState = fromState;
                    toNode.userData.strength = newStrength;
                    return true;
                }
                return false;
            }

            // 4. Update component internal states based on node states
            components.forEach(c => {
                if (c.type === 'probe') {
                    c.logicState = c.nodes[0].userData.logicState;
                    c.logicVoltage = (c.logicState === 'HIGH') ? 5.0 : 0.0;
                } else if (c.type === 'bulb' || c.type === 'motor' || c.type === 'capacitor') { 
    // Powered if there's a potential difference
    const s1 = c.nodes[0].userData.logicState;
    const s2 = c.nodes[1].userData.logicState;
    c.isPowered = (s1 === 'HIGH' && s2 === 'LOW') || (s1 === 'LOW' && s2 === 'HIGH');
} else if (c.type === 'npn' || c.type === 'pnp') {
                    c.logicState = c.nodes[0].userData.logicState;
                    c.logicVoltage = (c.logicState === 'HIGH') ? 5.0 : 0.0;
                }
            });

            // 5. Update wire visual states
            wires.forEach(w => {
                const s1 = w.startNode.userData.logicState;
                const s2 = w.endNode.userData.logicState;
                w.isPowered = (s1 === 'HIGH' || s2 === 'HIGH'); // For particle flow

                // Color wires based on logic state
                let color = 0xb87333; // Copper
                if (s1 === 'HIGH' || s2 === 'HIGH') color = 0xff3333; // Red for HIGH
                else if (s1 === 'LOW' || s2 === 'LOW') color = 0x3333ff; // Blue for LOW
                w.mesh.material.color.setHex(color);
            });


            if (shouldDebug) console.log(`--- Logic Analysis End (${iterations} iterations) ---`);
        }


        // --- 6. UI & MOUSE EVENT HANDLERS ---
        const toolButtons = document.querySelectorAll('#toolbar button');
        const simulateButton = document.getElementById('tool-simulate');
        simulateButton.addEventListener('click', () => {
            isSimulating = !isSimulating;
            simulateButton.classList.toggle('simulate-active');
            toolButtons.forEach(btn => { if (btn.id !== 'tool-simulate') btn.disabled = isSimulating; });
            updateUndoRedoButtons();
            if (isSimulating) {
                analyzeCircuit();
            } else {
                components.forEach(c => {
                    if (c.type === 'bulb') c.mesh.getObjectByName('glass').material.emissive.setHex(0x000000);
                    if (c.type === 'capacitor') { c.charge = 0; c.voltage = 0; }
                    if (c.type === 'fuse') {
                        c.isBlown = false;
                        c.currentEnergy = 0;
                        const wire = c.mesh.getObjectByName('fuse_wire');
                        if (wire) wire.material.color.set(0xC0C0C0);
                    }
                    if (c.type === 'motor') { c.rpm = 0; }
                });
                updateInfoPanel(selectedComponent);
            }
        });


        document.getElementById('tool-clear').addEventListener('click', () => {

            if (confirm('Are you sure you want to clear the entire workspace?')) {
                clearScene();
            }
        });

        document.getElementById('tool-reset-cam').addEventListener('click', () => {
            camera.position.set(10, 20, 25);
            controls.target.set(0, 0, 0);
            controls.update();
        });

        toolButtons.forEach(btn => {
            if (btn.id.includes('undo') || btn.id.includes('redo') || btn.id.includes('simulate') || btn.id.includes('save') || btn.id.includes('load') || btn.id === 'tool-clear' || btn.id === 'tool-reset-cam') return;
            btn.addEventListener('click', () => {
                const newTool = btn.id.replace('tool-', ''); if (currentTool === newTool) return;
                toolButtons.forEach(b => b.classList.remove('selected')); btn.classList.add('selected'); currentTool = newTool;
                if (selectedComponent) { selectedComponent = null; updateInfoPanel(null); }
                if (ghostComponent) scene.remove(ghostComponent); ghostComponent = null;
                controlPoints.forEach(cp => cp.visible = false);
                if (selectedWire) { selectedWire.mesh.material.color.set(0xb87333); selectedWire = null; }
                if (wireStartNode) { wireStartNode.material = nodeMaterial; wireStartNode = null; }
                const isComponentTool = ['battery', 'capacitor', 'switch', 'bulb', 'fuse', 'motor', 'resistor', 'npn', 'pnp', 'vcc', 'gnd', 'probe', 'and_gate', 'or_gate', 'not_gate', 'xor_gate'].includes(currentTool);
                if (isComponentTool) { ghostComponent = createComponentModel(currentTool).mesh; ghostComponent.traverse(c => { if (c.material) { c.material = c.material.clone(); c.material.transparent = true; c.material.opacity = 0.5; } }); scene.add(ghostComponent); }

                const isWireMode = currentTool === 'wire'; components.forEach(c => c.nodes.forEach(n => n.visible = isWireMode));
            });
        });

        let dragStartPosition = new THREE.Vector3();
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersection = new THREE.Vector3();
            if (raycaster.ray.intersectPlane(gridPlane, intersection)) {
                const snappedPos = new THREE.Vector3(Math.round(intersection.x), 0, Math.round(intersection.z));
                if (ghostComponent) ghostComponent.position.copy(snappedPos);
                if (isDragging && selectedComponent) { selectedComponent.mesh.position.copy(snappedPos); updateAttachedWires(selectedComponent); }
                if (isDragging && selectedControlPoint) { intersection.y = selectedControlPoint.position.y; selectedControlPoint.position.copy(intersection); updateWire(selectedControlPoint.userData.parentWire); }
            }
        }

        function onMouseDown(event) {
            if (event.button !== 0) return;
            if (event.target.tagName !== 'CANVAS' || isDragging) return;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            const intersectedCompBody = intersects.find(i => i.object.parent && i.object.parent.userData.type);
            selectedComponent = intersectedCompBody ? intersectedCompBody.object.parent.userData : null;

            if (isSimulating) {
                const intersectedSwitch = intersects.find(i => i.object.parent && i.object.parent.userData && i.object.parent.userData.type === 'switch');
                if (intersectedSwitch) {
                    intersectedSwitch.object.parent.userData.isOn = !intersectedSwitch.object.parent.userData.isOn;
                }
                updateInfoPanel(selectedComponent);
                return;
            }

            const intersectedNode = intersects.find(i => i.object.userData.isNode && i.object.visible);
            const intersectedWire = intersects.find(i => i.object.userData.parentWire);
            const intersectedCtrlPt = intersects.find(i => i.object.userData.isControlPoint && i.object.visible);

            if (currentTool === 'wire' && intersectedNode) {
                if (!wireStartNode) {
                    wireStartNode = intersectedNode.object;
                    wireStartNode.material = selectedNodeMaterial;
                } else {
                    if (intersectedNode.object.userData.component !== wireStartNode.userData.component) {
                        const newWire = createWire(wireStartNode, intersectedNode.object);
                        executeAction({ type: 'add', object: newWire, isWire: true });
                    }
                    wireStartNode.material = nodeMaterial;
                    wireStartNode = null;
                }
            } else if (['battery', 'capacitor', 'switch', 'bulb', 'fuse', 'motor', 'resistor', 'npn', 'pnp', 'vcc', 'gnd', 'probe', 'and_gate', 'or_gate', 'not_gate', 'xor_gate'].includes(currentTool)) {
                if (ghostComponent) {

                    const newComp = createComponentModel(currentTool);
                    newComp.id = nextId++;
                    newComp.mesh.position.copy(ghostComponent.position);
                    executeAction({ type: 'add', object: newComp, isWire: false });

                    if (!shiftPressed) {
                        // Switch back to select tool
                        const selectBtn = document.getElementById('tool-select');
                        selectBtn.click();
                    }
                }
            } else if (currentTool === 'select') {
                if (selectedComponent) {
                    isDragging = true;
                    controls.enabled = false;
                    dragStartPosition.copy(selectedComponent.mesh.position);
                }
                updateInfoPanel(selectedComponent);
            } else if (currentTool === 'edit-wire') {
                if (selectedWire) { selectedWire.mesh.material.color.set(0xb87333); selectedWire.controlPoints.forEach(cp => cp.visible = false); }
                if (intersectedWire) { selectedWire = intersectedWire.object.userData.parentWire; selectedWire.mesh.material.color.set(0xffff00); selectedWire.controlPoints.forEach(cp => { cp.visible = true; cp.userData.parentWire = selectedWire; }); }
                else if (intersectedCtrlPt) { selectedControlPoint = intersectedCtrlPt.object; isDragging = true; controls.enabled = false; }
            }
        }

        function onMouseUp(event) {
            if (event.button !== 0) return;
            if (isDragging && selectedComponent) {
                if (!selectedComponent.mesh.position.equals(dragStartPosition)) { executeAction({ type: 'move', object: selectedComponent, from: dragStartPosition.clone(), to: selectedComponent.mesh.position.clone() }); }
            }
            isDragging = false;
            selectedControlPoint = null;
            controls.enabled = true;
        }

        function onRightClick(event) {
            event.preventDefault();
            if (isSimulating) return;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            const intersectedCompBody = intersects.find(i => i.object.parent && i.object.parent.userData.type);
            const intersectedWire = intersects.find(i => i.object.userData.parentWire);

            if (intersectedCompBody) {
                const compToDelete = intersectedCompBody.object.parent.userData;
                const wiresToDelete = wires.filter(w => w.startNode.userData.component === compToDelete || w.endNode.userData.component === compToDelete);
                wiresToDelete.forEach(w => executeAction({ type: 'remove', object: w, isWire: true }));
                executeAction({ type: 'remove', object: compToDelete, isWire: false });
            } else if (intersectedWire) {
                executeAction({ type: 'remove', object: intersectedWire.object.userData.parentWire, isWire: true });
            }
        }

        function updateInfoPanel(component) {
            const batteryInfo = document.getElementById('battery-info');
            const capacitorInfo = document.getElementById('capacitor-info');
            const fuseInfo = document.getElementById('fuse-info');
            const motorInfo = document.getElementById('motor-info');
            const resistorInfo = document.getElementById('resistor-info');
            const logicInfo = document.getElementById('logic-info');
            const infoTitle = document.getElementById('info-title');

            infoPanel.style.display = 'none';
            batteryInfo.style.display = 'none';
            capacitorInfo.style.display = 'none';
            fuseInfo.style.display = 'none';
            motorInfo.style.display = 'none';
            resistorInfo.style.display = 'none';
            logicInfo.style.display = 'none';

            if (!component) return;

            infoPanel.style.display = 'block';

            if (component.type === 'battery') {
                batteryInfo.style.display = 'block';
                infoTitle.textContent = 'Battery';
                document.getElementById('info-battery-voltage').textContent = `${component.voltage.toFixed(1)} V`;
            }
            else if (component.type === 'capacitor') {
                capacitorInfo.style.display = 'block';
                infoTitle.textContent = 'Capacitor';
                document.getElementById('info-capacitance').textContent = `${component.capacitance.toFixed(1)} F`;
                document.getElementById('info-charge').textContent = `${component.charge.toFixed(2)} C`;
                document.getElementById('info-voltage').textContent = `${component.voltage.toFixed(2)} V`;
            }
            else if (component.type === 'fuse') {
                fuseInfo.style.display = 'block';
                infoTitle.textContent = 'Fuse';
                document.getElementById('info-max-energy').textContent = `${component.maxEnergy.toFixed(1)}`;
                document.getElementById('info-current-energy').textContent = `${component.currentEnergy.toFixed(2)}`;
                document.getElementById('info-fuse-status').textContent = component.isBlown ? 'BLOWN' : 'OK';
            }
            else if (component.type === 'motor') {
                motorInfo.style.display = 'block';
                infoTitle.textContent = 'Motor';
                document.getElementById('info-motor-rpm').textContent = `${Math.round(component.rpm)}`;
                document.getElementById('info-motor-status').textContent = component.rpm > 10 ? 'Spinning' : 'Stopped';
            }
            else if (component.type === 'resistor') {
                resistorInfo.style.display = 'block';
                infoTitle.textContent = 'Resistor';
                document.getElementById('info-resistance').textContent = `${component.resistance} \u03A9`;
            }
            else if (['npn', 'pnp', 'vcc', 'gnd', 'probe'].includes(component.type)) {
                logicInfo.style.display = 'block';
                infoTitle.textContent = component.type.toUpperCase();
                const state = component.logicState || 'Floating';
                const voltage = component.logicVoltage || 0.0;
                document.getElementById('info-logic-state').textContent = state;
                document.getElementById('info-logic-voltage').textContent = `${voltage.toFixed(1)} V`;
            }
        }


        // --- 7. SAVE/LOAD & EVENT LISTENERS ---
        const saveButton = document.getElementById('tool-save');
        const loadButton = document.getElementById('tool-load');
        const loadFileInput = document.getElementById('load-file-input');
        const exampleNotButton = document.getElementById('tool-example-not');
        const exampleAluButton = document.getElementById('tool-example-alu');
        saveButton.addEventListener('click', saveConfiguration);
        loadButton.addEventListener('click', () => loadFileInput.click());
        loadFileInput.addEventListener('change', loadConfiguration);
        exampleNotButton.addEventListener('click', loadNotGateExample);
        exampleAluButton.addEventListener('click', loadAluExample);


        function loadNotGateExample() {
            const notGateData = {
                "components": [
                    { "id": 0, "type": "vcc", "position": { "x": 0, "y": 0, "z": -6 }, "isOn": true },
                    { "id": 1, "type": "resistor", "position": { "x": 0, "y": 0, "z": -3 }, "isOn": true },
                    { "id": 2, "type": "npn", "position": { "x": 0, "y": 0, "z": 0 }, "isOn": true },
                    { "id": 3, "type": "gnd", "position": { "x": 0, "y": 0, "z": 3 }, "isOn": true },
                    { "id": 4, "type": "switch", "position": { "x": -5, "y": 0, "z": 0 }, "isOn": false },
                    { "id": 5, "type": "probe", "position": { "x": 5, "y": 0, "z": 0 }, "isOn": true }
                ],
                "wires": [
                    // VCC to Resistor
                    { "start": { "componentId": 0, "nodeIndex": 0 }, "end": { "componentId": 1, "nodeIndex": 0 }, "controlPoints": [] },
                    // Resistor to Collector
                    { "start": { "componentId": 1, "nodeIndex": 1 }, "end": { "componentId": 2, "nodeIndex": 1 }, "controlPoints": [] },
                    // Emitter to GND (Curved to avoid Collector)
                    { "start": { "componentId": 2, "nodeIndex": 2 }, "end": { "componentId": 3, "nodeIndex": 0 }, "controlPoints": [{ "x": 1, "y": 1, "z": 1.5 }] },
                    // VCC to Switch
                    { "start": { "componentId": 0, "nodeIndex": 0 }, "end": { "componentId": 4, "nodeIndex": 0 }, "controlPoints": [{ "x": -5, "y": 2, "z": -3 }] },
                    // Switch to Base
                    { "start": { "componentId": 4, "nodeIndex": 1 }, "end": { "componentId": 2, "nodeIndex": 0 }, "controlPoints": [] },
                    // Collector to Probe (Curved UP and RIGHT to be very clear it's from the center)
                    { "start": { "componentId": 2, "nodeIndex": 1 }, "end": { "componentId": 5, "nodeIndex": 0 }, "controlPoints": [{ "x": 2.5, "y": 3, "z": 0 }] }
                ]
            };
            rebuildCircuitFromData(notGateData);
        }

        function loadAluExample() {
            const aluData = {
                "components": [
                    { "id": 0, "type": "vcc", "position": { "x": -12, "y": 0, "z": -6 }, "isOn": true },
                    { "id": 1, "type": "switch", "position": { "x": -8, "y": 0, "z": -4 }, "isOn": false }, // A
                    { "id": 2, "type": "switch", "position": { "x": -8, "y": 0, "z": 0 }, "isOn": false },  // B
                    { "id": 3, "type": "switch", "position": { "x": -8, "y": 0, "z": 4 }, "isOn": false },  // Op
                    { "id": 4, "type": "and_gate", "position": { "x": -2, "y": 0, "z": -2 }, "isOn": true }, // A & B
                    { "id": 5, "type": "or_gate", "position": { "x": -2, "y": 0, "z": 2 }, "isOn": true },  // A | B
                    { "id": 6, "type": "not_gate", "position": { "x": 2, "y": 0, "z": 6 }, "isOn": true },  // !Op
                    { "id": 7, "type": "and_gate", "position": { "x": 6, "y": 0, "z": -2 }, "isOn": true }, // (A&B) & !Op
                    { "id": 8, "type": "and_gate", "position": { "x": 6, "y": 0, "z": 2 }, "isOn": true },  // (A|B) & Op
                    { "id": 10, "type": "or_gate", "position": { "x": 12, "y": 0, "z": 0 }, "isOn": true },  // Final MUX OR
                    { "id": 11, "type": "probe", "position": { "x": 16, "y": 0, "z": 0 }, "isOn": true }
                ],
                "wires": [
                    // VCC to Switches
                    { "start": { "componentId": 0, "nodeIndex": 0 }, "end": { "componentId": 1, "nodeIndex": 0 }, "controlPoints": [] },
                    { "start": { "componentId": 0, "nodeIndex": 0 }, "end": { "componentId": 2, "nodeIndex": 0 }, "controlPoints": [{ "x": -12, "y": 2, "z": 0 }] },
                    { "start": { "componentId": 0, "nodeIndex": 0 }, "end": { "componentId": 3, "nodeIndex": 0 }, "controlPoints": [{ "x": -12, "y": 2, "z": 4 }] },
                    // Switch A to AND1 and OR1
                    { "start": { "componentId": 1, "nodeIndex": 1 }, "end": { "componentId": 4, "nodeIndex": 0 }, "controlPoints": [] },
                    { "start": { "componentId": 1, "nodeIndex": 1 }, "end": { "componentId": 5, "nodeIndex": 0 }, "controlPoints": [{ "x": -5, "y": 1, "z": 0 }] },
                    // Switch B to AND1 and OR1
                    { "start": { "componentId": 2, "nodeIndex": 1 }, "end": { "componentId": 4, "nodeIndex": 1 }, "controlPoints": [] },
                    { "start": { "componentId": 2, "nodeIndex": 1 }, "end": { "componentId": 5, "nodeIndex": 1 }, "controlPoints": [] },
                    // Switch Op to NOT1 and AND3
                    { "start": { "componentId": 3, "nodeIndex": 1 }, "end": { "componentId": 6, "nodeIndex": 0 }, "controlPoints": [] },
                    { "start": { "componentId": 3, "nodeIndex": 1 }, "end": { "componentId": 8, "nodeIndex": 1 }, "controlPoints": [{ "x": 0, "y": 2, "z": 4 }] },
                    // AND1 to AND2
                    { "start": { "componentId": 4, "nodeIndex": 2 }, "end": { "componentId": 7, "nodeIndex": 0 }, "controlPoints": [] },
                    // OR1 to AND3
                    { "start": { "componentId": 5, "nodeIndex": 2 }, "end": { "componentId": 8, "nodeIndex": 0 }, "controlPoints": [] },
                    // NOT1 to AND2
                    { "start": { "componentId": 6, "nodeIndex": 1 }, "end": { "componentId": 7, "nodeIndex": 1 }, "controlPoints": [{ "x": 4, "y": 2, "z": 2 }] },
                    // AND2 to OR2
                    { "start": { "componentId": 7, "nodeIndex": 2 }, "end": { "componentId": 10, "nodeIndex": 0 }, "controlPoints": [] },
                    // AND3 to OR2
                    { "start": { "componentId": 8, "nodeIndex": 2 }, "end": { "componentId": 10, "nodeIndex": 1 }, "controlPoints": [] },
                    // OR2 to Probe
                    { "start": { "componentId": 10, "nodeIndex": 2 }, "end": { "componentId": 11, "nodeIndex": 0 }, "controlPoints": [] }
                ]
            };
            rebuildCircuitFromData(aluData);
        }


        function serializeCircuit() { return { components: components.map(c => ({ id: c.id, type: c.type, position: c.mesh.position.clone(), isOn: c.isOn, isBlown: c.isBlown, currentEnergy: c.currentEnergy, maxEnergy: c.maxEnergy })), wires: wires.map(w => ({ start: { componentId: w.startNode.userData.component.id, nodeIndex: w.startNode.userData.component.nodes.indexOf(w.startNode) }, end: { componentId: w.endNode.userData.component.id, nodeIndex: w.endNode.userData.component.nodes.indexOf(w.endNode) }, controlPoints: w.controlPoints.map(cp => cp.position.clone()) })) }; }
        function saveConfiguration() { const d = serializeCircuit(); const s = JSON.stringify(d, null, 2); const b = new Blob([s], { type: 'application/json' }); const u = URL.createObjectURL(b); const a = document.createElement('a'); a.href = u; a.download = 'circuit-config.json'; a.click(); URL.revokeObjectURL(u); }
        function loadConfiguration(event) { const f = event.target.files[0]; if (!f) return; const r = new FileReader(); r.onload = (e) => { try { const d = JSON.parse(e.target.result); rebuildCircuitFromData(d); } catch (err) { alert('Error parsing file.'); console.error(err); } }; r.readAsText(f); event.target.value = ''; }
        function clearScene() { wires.forEach(w => { scene.remove(w.mesh); w.controlPoints.forEach(cp => scene.remove(cp)); }); components.forEach(c => scene.remove(c.mesh)); components = []; wires = []; controlPoints = []; selectedComponent = null; selectedWire = null; wireStartNode = null; updateInfoPanel(null); nextId = 0; historyStack.length = 0; redoStack.length = 0; updateUndoRedoButtons(); }
        function rebuildCircuitFromData(data) { clearScene(); const m = new Map(); let maxId = 0; data.components.forEach(d => { const c = createComponentModel(d.type); c.id = d.id; c.mesh.position.set(d.position.x, d.position.y, d.position.z); if (d.type === 'switch') c.isOn = d.isOn; if (d.type === 'fuse') { c.isBlown = d.isBlown; c.currentEnergy = d.currentEnergy; c.maxEnergy = d.maxEnergy || 50.0; } components.push(c); scene.add(c.mesh); m.set(c.id, c); if (c.id > maxId) maxId = c.id; }); nextId = maxId + 1; data.wires.forEach(d => { const sC = m.get(d.start.componentId), eC = m.get(d.end.componentId); if (!sC || !eC) return; const sN = sC.nodes[d.start.nodeIndex], eN = eC.nodes[d.end.nodeIndex]; if (!sN || !eN) return; const w = createWire(sN, eN); scene.remove(w.controlPoints[0]); controlPoints.splice(controlPoints.indexOf(w.controlPoints[0]), 1); w.controlPoints = []; d.controlPoints.forEach(p => { const cp = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({ color: 0xff8800 })); cp.position.set(p.x, p.y, p.z); cp.userData = { isControlPoint: true, parentWire: w }; cp.visible = false; controlPoints.push(cp); scene.add(cp); w.controlPoints.push(cp); }); updateWire(w); wires.push(w); scene.add(w.mesh); }); }


        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mouseup', onMouseUp);
        window.addEventListener('contextmenu', onRightClick);
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -frustumSize * aspect / 2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = -frustumSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });


        window.addEventListener('keydown', (event) => {
            if (event.key === 'Shift') shiftPressed = true;
            if (event.key === 'd' || event.key === 'D') {
                requestDebugFrame = true;
            }
        });
        window.addEventListener('keyup', (event) => {
            if (event.key === 'Shift') shiftPressed = false;
        });

        // --- 8. RENDER LOOP ---
        camera.position.set(20, 20, 20);
        controls.target.set(0, 0, 0);

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            const deltaTime = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();

            if (isSimulating) {
                analyzeCircuit();

                // Find the primary active source (battery has priority)
                const battery = components.find(c => c.type === 'battery' && c.isPowered);
                const activeCapacitor = components.find(c => c.type === 'capacitor' && c.isPowered && c.charge > 0.01);
                const primarySource = battery || activeCapacitor;

                components.forEach(c => {
                    if (c.type === 'bulb') {
                        c.mesh.getObjectByName('glass').material.emissive.setHex(c.isPowered ? 0xff8800 : 0x000000);
                    } else if (c.type === 'switch') {
                        c.mesh.getObjectByName('lever').rotation.z = c.isOn ? -Math.PI / 8 : Math.PI / 8;
                    } else if (c.type === 'capacitor') {
                        // Charging: is the capacitor powered by the main battery?
                        if (c.isPowered && battery && battery.isPowered) {
                            let chargeRate = (battery.voltage - c.voltage) * 0.8;
                            c.charge = Math.min(c.charge + chargeRate * deltaTime, c.capacitance * battery.voltage);
                        }
                        // Discharging: is the capacitor powering a circuit by itself?
                        else if (c.isPowered && c.charge > 0 && !battery) {
                            let dischargeRate = 0.5; // Represents the load's resistance
                            c.charge = Math.max(0, c.charge - c.voltage * dischargeRate * deltaTime);
                        }
                        c.voltage = c.charge / c.capacitance;
                    } else if (c.type === 'fuse') {
                        if (c.isPowered && !c.isBlown && primarySource) {
                            const energyGain = primarySource.voltage * deltaTime;
                            c.currentEnergy += energyGain;
                            if (c.currentEnergy >= c.maxEnergy) {
                                c.isBlown = true;
                                c.mesh.getObjectByName('fuse_wire').material.color.set(0x333333);
                            }
                        }
                    } else if (c.type === 'motor') {
                        if (c.isPowered) {
                            c.rpm = Math.min(c.rpm + 100 * deltaTime, 1000); // Spin up
                            c.mesh.getObjectByName('shaft').rotation.z += (c.rpm / 60) * deltaTime * 2 * Math.PI;
                        } else {
                            c.rpm = Math.max(c.rpm - 200 * deltaTime, 0); // Spin down
                            c.mesh.getObjectByName('shaft').rotation.z += (c.rpm / 60) * deltaTime * 2 * Math.PI;
                        }
                    } else if (c.type === 'probe') {
                        const tip = c.mesh.getObjectByName('probe_tip');
                        if (tip) {
                            if (c.logicState === 'HIGH') tip.material.emissive.setHex(0x00ff00);
                            else if (c.logicState === 'LOW') tip.material.emissive.setHex(0x0000ff);
                            else tip.material.emissive.setHex(0x000000);
                        }
                    }
                });


                if (selectedComponent) {
                    updateInfoPanel(selectedComponent);
                }
            }
            renderer.render(scene, camera);

            if (requestDebugFrame) {
                requestDebugFrame = false;
            }
        }
        animate();
    </script>
</body>

</html>