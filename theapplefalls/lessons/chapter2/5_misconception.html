<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>The Invisible Web: Inertia & Trajectories</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
            --red: #ff6b6b;
            --blue: #54a0ff;
            --green: #2ecc71;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        .instruction-inline {
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }

        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        /* NEXT BUTTON STYLING FIX */
        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            border: none;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
            transform: none;
            animation: none;
        }

        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }

        /* SPECIFIC BADGES FOR THIS LESSON */
        .analogy-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            text-transform: uppercase;
            font-weight: 800;
            margin-left: 4px;
            color: #fff;
            vertical-align: middle;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            letter-spacing: 0.5px;
        }

        .badge-wrong {
            background: var(--red);
        }

        .badge-correct {
            background: var(--green);
        }

        .badge-mass {
            background: #9b59b6;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Sim: Field Lines vs. Trajectories</div>
        </header>

        <div id="story-container">
            <div id="chapter-content"><!-- Content injected by JS --></div>
        </div>

        <div id="controls-area">
            <div class="control-row" id="ctrl-vis">
                <label>Step 1: The Context</label>
                <button id="btn-vis" onclick="toggleLines()">Draw Field Lines</button>
            </div>

            <div class="control-row" id="ctrl-massless">
                <label>Step 2: The Idealization</label>
                <button id="btn-ideal" onclick="fireParticle('massless')">Launch "Massless" Charge</button>
            </div>

            <div class="control-row" id="ctrl-real">
                <label>Step 3: The Reality</label>
                <button id="btn-real" onclick="fireParticle('massive')">Launch Massive Charge</button>
            </div>

            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Experiment Control</label>
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Newtonian Physics Engine</div>
    </main>

    <script>
        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const state = {
            linesVisible: false,
            simulating: false,
            mode: 'none', // 'massless' or 'massive'
            time: 0
        };

        const scene = new THREE.Scene();
        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        let viewSize = 60;

        // Orthographic for clear "Map" view
        const camera = new THREE.OrthographicCamera(-viewSize * aspect / 2, viewSize * aspect / 2, viewSize / 2, -viewSize / 2, 1, 1000);
        camera.position.set(0, 50, 0); // Top-down view for 2D trajectory clarity
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('world').appendChild(renderer.domElement);

        // Light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        scene.add(dirLight);

        // Grid
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8, metalness: 0.2 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -5;
        floor.receiveShadow = true;
        scene.add(floor);
        scene.background = new THREE.Color(0x151515);

        const gridHelper = new THREE.GridHelper(100, 20, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -4.9;
        scene.add(gridHelper);

        // --- CHARGES (Dipole) ---
        const charges = [];
        const chargeGroup = new THREE.Group();
        scene.add(chargeGroup);

        function createCharge(val, x, z, color) {
            const geo = new THREE.IcosahedronGeometry(2.5, 1);
            const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, 0, z);

            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 40px Arial';
            ctx.fillStyle = color;
            ctx.textAlign = "center";
            ctx.fillText(val > 0 ? "+" : "-", 32, 48);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
            sprite.position.set(0, 0, 0);
            sprite.scale.set(6, 6, 1);
            sprite.rotation.x = -Math.PI / 2; // Lay flat for top down
            mesh.add(sprite);

            chargeGroup.add(mesh);
            return { val: val, mesh: mesh };
        }

        // Setup Dipole
        const q1 = createCharge(50, -20, 0, '#ff6b6b'); // Source
        const q2 = createCharge(-50, 20, 0, '#54a0ff'); // Sink
        charges.push(q1, q2);

        // --- FIELD LINES (Static Background) ---
        const linesGroup = new THREE.Group();
        scene.add(linesGroup);

        function getNetField(pos) {
            let E = new THREE.Vector3(0, 0, 0);
            charges.forEach(q => {
                const rVec = new THREE.Vector3().subVectors(pos, q.mesh.position);
                const distSq = rVec.lengthSq();
                const dist = Math.sqrt(distSq);
                if (dist < 1) return; // Singularity guard
                // E = k * q / r^2 * rHat
                const mag = q.val / (distSq);
                E.add(rVec.normalize().multiplyScalar(mag));
            });
            return E;
        }

        function generateLines() {
            linesGroup.clear();
            const mat = new THREE.LineBasicMaterial({ color: 0x8892b0, transparent: true, opacity: 0.2 });

            const src = charges[0]; // Positive charge
            const numLines = 24;

            for (let i = 0; i < numLines; i++) {
                const angle = (i / numLines) * Math.PI * 2;
                const startPos = new THREE.Vector3(
                    Math.cos(angle) * 3, 0, Math.sin(angle) * 3
                ).add(src.mesh.position);

                const path = [startPos];
                let curr = startPos.clone();

                for (let step = 0; step < 400; step++) {
                    const E = getNetField(curr);
                    if (E.length() < 0.05) break;

                    curr.add(E.normalize().multiplyScalar(0.5)); // Move along field
                    path.push(curr.clone());

                    // Stop if hitting sink
                    if (curr.distanceTo(charges[1].mesh.position) < 3) break;
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(path);
                linesGroup.add(new THREE.Line(geometry, mat));
            }
        }

        // --- PHYSICS PARTICLE ---
        let physicsParticle = null;
        let particleTrail = [];
        const particleMesh = new THREE.Mesh(
            new THREE.SphereGeometry(1, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0xffffff })
        );
        scene.add(particleMesh);
        particleMesh.visible = false;

        // Trail Line
        const trailGeo = new THREE.BufferGeometry();
        const trailMat = new THREE.LineBasicMaterial({ color: 0x2ecc71, linewidth: 3 });
        const trailLine = new THREE.Line(trailGeo, trailMat);
        scene.add(trailLine);

        function resetPhysics() {
            state.simulating = false;
            particleMesh.visible = false;
            particleTrail = [];
            trailGeo.setFromPoints([]);
        }

        function fireParticle(mode) {
            resetPhysics();
            state.mode = mode;
            state.simulating = true;
            particleMesh.visible = true;

            // Release Point: Slightly offset from the straight line to force a curve
            // Positioned above the source to enter the field
            physicsParticle = {
                pos: new THREE.Vector3(-15, 0, 5),
                vel: new THREE.Vector3(0, 0, 0), // Start from rest
                mass: mode === 'massless' ? 0.05 : 10.0 // Huge mass difference
            };

            particleMesh.position.copy(physicsParticle.pos);

            // Color coding
            if (mode === 'massless') {
                particleMesh.material.color.setHex(0xffaa00); // Orange for 'Test Charge'
                trailMat.color.setHex(0xffaa00);
            } else {
                particleMesh.material.color.setHex(0x2ecc71); // Green for 'Real Physics'
                trailMat.color.setHex(0x2ecc71);
            }

            checkAdvance();
        }

        // ==========================================
        // PART 2: ANIMATION LOOP (PHYSICS ENGINE)
        // ==========================================

        function animate() {
            requestAnimationFrame(animate);

            if (state.simulating && physicsParticle) {
                const dt = 0.05; // Time step

                // 1. Get Electric Field at current position
                const E = getNetField(physicsParticle.pos);

                // 2. Calculate Force (F = qE). Let q = 1.
                const F = E.clone();

                if (state.mode === 'massless') {
                    // FAKE PHYSICS (Aristotelian/Massless)
                    // Velocity is directly proportional to Field (V ~ E)
                    // This forces it to follow the line exactly.
                    physicsParticle.vel = E.normalize().multiplyScalar(0.8);
                } else {
                    // REAL PHYSICS (Newtonian)
                    // F = ma  ->  a = F/m
                    const a = F.clone().divideScalar(physicsParticle.mass);

                    // v = v + a*dt
                    physicsParticle.vel.add(a.multiplyScalar(dt));
                }

                // 3. Update Position
                physicsParticle.pos.add(physicsParticle.vel.clone().multiplyScalar(state.mode === 'massless' ? 1 : dt * 5));

                // Update Mesh
                particleMesh.position.copy(physicsParticle.pos);

                // Update Trail
                if (state.time % 2 === 0 || true) { // Every frame
                    particleTrail.push(physicsParticle.pos.clone());
                    trailGeo.setFromPoints(particleTrail);
                }

                // Stop condition
                if (physicsParticle.pos.distanceTo(q2.mesh.position) < 3 || physicsParticle.pos.length() > 60) {
                    state.simulating = false;
                }
            }

            state.time++;
            renderer.render(scene, camera);
        }

        animate();


        // ==========================================
        // PART 3: NARRATIVE LOGIC
        // ==========================================

        let currentChapter = 0;

        function toggleLines() {
            state.linesVisible = !state.linesVisible;
            if (state.linesVisible) {
                generateLines();
            } else {
                linesGroup.clear();
            }
            document.getElementById('btn-vis').innerText = state.linesVisible ? "Hide Field Lines" : "Draw Field Lines";
            checkAdvance();
        }

        function resetSim() {
            resetPhysics();
            state.linesVisible = false;
            linesGroup.clear();
            document.getElementById('btn-vis').innerText = "Draw Field Lines";
            loadLesson(0);
        }

        const lessons = [
            {
                title: "The Misconception",
                text: "A common mistake is thinking that <strong>Field Lines</strong> represent the path a charged particle will take.<br><br>It looks like a train track, right? If you put a train on a track, it follows the rails. <br><br>Let's set up the map first. We have a Positive Source (Red) and Negative Sink (Blue).<br><br><span class='instruction-inline'>Click 'Draw Field Lines'</span> to see the curves.",
                setup: () => { lockAll(); unlock('ctrl-vis'); },
                check: () => state.linesVisible
            },
            {
                title: "The 'Massless' Ideal",
                text: "Charges <strong>only</strong> follow field lines exactly if they have zero mass (or move very slowly in a highly viscous medium).<br><br>In this case, the force vector points along the line, and without inertia, the particle turns instantly.<br><br><span class='instruction-inline'>Click 'Launch Massless Charge'</span>. Watch how it hugs the curve perfectly.",
                setup: () => { unlock('ctrl-massless'); },
                check: () => state.mode === 'massless'
            },
            {
                title: "The Reality: Inertia",
                text: "Real particles have mass. Mass means <strong>Inertia</strong>.<br><br>Inertia is the resistance to changing direction. When the field line curves, the particle <em>wants</em> to keep going straight.<br><br><span class='instruction-inline'>Click 'Launch Massive Charge'</span>. Watch it 'drift' off the track like a race car taking a corner too fast.",
                setup: () => { unlock('ctrl-real'); },
                check: () => state.mode === 'massive'
            },
            {
                title: "Conclusion",
                text: "Why did that happen?<br><br>At every point, the <strong>Electric Field</strong> (the line) tells the particle which way to <em>accelerate</em> (Force).<br><br>But the particle's <strong>Velocity</strong> tells it where it is going <em>now</em>.<br><br>Unless the line is perfectly straight, the Velocity vector and Force vector point in different directions. The particle moves based on the sum of its history (velocity) and the current pull (force). Now that we've cleared up how charges move, let's look at one of the most important structures in nature: The Electric Dipole.",
                setup: () => { },
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Lesson ${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML = `<div class="chapter-title">${l.title}</div><div class="story-text">${l.text}</div>`;
            const btn = document.getElementById('btn-next');
            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            } l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.parent.location.href = '/lesson/dipole';
            }
        }
        function prevLesson() { if (currentChapter > 0) loadLesson(currentChapter - 1); }
        function checkAdvance() { if (currentChapter >= lessons.length - 1) return; if (lessons[currentChapter].check()) { document.getElementById('btn-next').disabled = false; } }
        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        loadLesson(0);

        window.addEventListener('resize', () => {
            aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * aspect / 2;
            camera.right = viewSize * aspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });
    </script>
</body>

</html>