<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Maxwell's Notebook: Superposition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- THEME & LAYOUT --- */
        :root {
            --bg: #151515;
            --panel: #1e1e1e;
            --text: #dcdcdc;
            --accent: #ff9f43;
            /* Orange */
            --accent-hover: #e58e3c;
            --border: #333;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* LEFT PANEL: THE STORYBOOK */
        aside {
            width: 420px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            font-style: italic;
        }

        #story-container {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chapter-title {
            font-size: 24px;
            font-weight: 300;
            color: #fff;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
        }

        .story-text {
            line-height: 1.8;
            font-size: 15px;
            color: #ccc;
            margin-bottom: 20px;
        }

        .story-text strong {
            color: #fff;
            font-weight: 600;
        }

        /* Highlighted instructions in text */
        .instruction-highlight {
            display: block;
            margin-top: 15px;
            color: var(--accent);
            font-weight: bold;
            background: rgba(255, 159, 67, 0.1);
            padding: 8px 12px;
            border-radius: 4px;
            border-left: 2px solid var(--accent);
            font-size: 13px;
        }

        .math-block {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #333;
            color: #fff;
            text-align: center;
        }

        /* CONTROLS AREA */
        #controls-area {
            background: #181818;
            padding: 20px;
            border-top: 1px solid var(--border);
        }

        .control-row {
            margin-bottom: 15px;
            opacity: 0.5;
            pointer-events: none;
            transition: 0.3s;
            filter: grayscale(1);
        }

        .control-row.active {
            opacity: 1;
            pointer-events: all;
            filter: grayscale(0);
        }

        label {
            display: block;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        button:hover {
            background: #444;
            color: #fff;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
            height: 6px;
            background: #333;
            border-radius: 3px;
        }

        /* NAVIGATION FOOTER */
        #nav-footer {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--border);
            background: #222;
        }

        .nav-btn {
            width: 48%;
            background: #333;
            color: #fff;
            border: none;
        }

        /* NEXT BUTTON STYLING FIX */
        .nav-btn.next {
            background: var(--accent);
            color: #151515;
            border: none;
        }

        .nav-btn.next:hover {
            background: var(--accent-hover);
            color: #000;
        }

        .nav-btn.next:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
            transform: none;
            animation: none;
        }

        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #23252e 0%, #0f1014 100%);
            overflow: hidden;
        }

        .scene-tag {
            position: absolute;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }

        #legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
            color: #ccc;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
        }
    </style>
</head>

<body>

    <aside>
        <header>
            <h1>Maxwell's Notebook</h1>
            <div class="subtitle">Simulation: Vector Addition</div>
        </header>

        <div id="story-container">
            <div id="chapter-content">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="controls-area">
            <!-- 1. Add Q2 -->
            <div class="control-row" id="ctrl-add-q2">
                <label>Step 1: The Second Source</label>
                <button id="btn-add-q2" onclick="introduceQ2()">Introduce Negative Charge (Q₂)</button>
            </div>

            <!-- 2. Show Sum -->
            <div class="control-row" id="ctrl-sum">
                <label>Step 2: Vector Addition</label>
                <button id="btn-sum" onclick="showSum()">Compute E_net</button>
            </div>

            <!-- 3. Move Q2 -->
            <div class="control-row" id="ctrl-move">
                <label>Step 3: Move Q₂ (Angle & Dist)</label>
                <input type="range" id="slider-angle" min="0" max="6.28" value="0" step="0.05">
                <div style="font-size:10px; color:#666; margin-top:5px; text-align:right;">Orbit Position</div>
            </div>

            <!-- Reset -->
            <div class="control-row" id="ctrl-reset"
                style="margin-top:10px; border-top:1px solid #2c313a; padding-top:15px; opacity: 1; pointer-events: all; filter: grayscale(0);">
                <label>Experiment Control</label>
                <button onclick="resetSim()">Reset System</button>
            </div>
        </div>

        <div id="nav-footer">
            <button class="nav-btn" onclick="prevLesson()">Back</button>
            <button class="nav-btn next" id="btn-next" onclick="nextLesson()">Next &rarr;</button>
        </div>
    </aside>

    <main id="world">
        <div class="scene-tag" style="top: 20px; right: 20px;">Vector Space</div>
        <div id="legend">
            <div class="legend-item">
                <div class="dot" style="background:#ff6b6b"></div>E₁ (from Q₁)
            </div>
            <div class="legend-item">
                <div class="dot" style="background:#54a0ff"></div>E₂ (from Q₂)
            </div>
            <div class="legend-item">
                <div class="dot" style="background:#ff9f43"></div>E_net (Resultant)
            </div>
            <div class="legend-item" style="color:#888">
                <div class="dot" style="border:1px dashed #888; background:transparent"></div>Parallel Projection
            </div>
        </div>
    </main>

    <script>
        // ==========================================
        // GLOBALS
        // ==========================================
        let currentChapter = 0;

        const state = {
            q2Visible: false,
            netVisible: false,
            angle: 0,
            time: 0
        };

        // Constants for visuals
        const K = 600; // Increased magnitude for longer arrows
        const Q1_CHARGE = 1;
        const Q2_CHARGE = -1;

        // ==========================================
        // PART 1: THE 3D ENGINE
        // ==========================================

        const scene = new THREE.Scene();

        const sidebarWidth = 420;
        let aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        const viewSize = 50;

        const camera = new THREE.OrthographicCamera(
            -viewSize * aspect / 2, viewSize * aspect / 2,
            viewSize / 2, -viewSize / 2,
            1, 1000
        );

        camera.position.set(30, 40, 30);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('world').appendChild(renderer.domElement);

        // Lights
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Grid
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({
            color: 0x222222,
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -10;
        floor.receiveShadow = true;
        scene.add(floor);
        scene.background = new THREE.Color(0x151515);

        const gridHelper = new THREE.GridHelper(100, 20, 0x2c313a, 0x1f2229);
        gridHelper.position.y = -9.9;
        scene.add(gridHelper);

        // --- UTILS ---
        function createTextSprite(text, scale, color = "white") {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 50px Arial';
            ctx.fillStyle = color;
            ctx.textAlign = "center";
            ctx.fillText(text, 128, 80);
            const tex = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, depthTest: false }));
            sprite.scale.set(scale * 2, scale, 1);
            sprite.renderOrder = 100;
            return sprite;
        }

        function createArrow(color) {
            const group = new THREE.Group();
            const visuals = new THREE.Group();

            // --- GEOMETRY FIX ---
            // We create an arrow with a total length of exactly 1.0 along the X-axis.
            // This ensures that when we scale it by 'len', the tip is exactly at distance 'len'.

            const totalLen = 1.0;
            const headLen = 0.25; // Head is 25% of the total length
            const shaftLen = totalLen - headLen;

            // 1. Shaft (Cylinder)
            // Radius increased slightly to maintain chunky look
            const shaftGeo = new THREE.CylinderGeometry(0.25, 0.25, shaftLen, 12);
            shaftGeo.rotateZ(-Math.PI / 2); // Point along X-axis
            // Move center so it starts at 0 and ends at 0.75
            shaftGeo.translate(shaftLen / 2, 0, 0);

            const shaftMat = new THREE.MeshStandardMaterial({ color: color });
            const shaft = new THREE.Mesh(shaftGeo, shaftMat);

            // 2. Head (Cone)
            const headGeo = new THREE.ConeGeometry(0.5, headLen, 12);
            headGeo.rotateZ(-Math.PI / 2); // Point along X-axis
            // Move center so it starts at 0.75 and tip ends exactly at 1.0
            headGeo.translate(shaftLen + (headLen / 2), 0, 0);

            const headMat = new THREE.MeshStandardMaterial({ color: color });
            const head = new THREE.Mesh(headGeo, headMat);

            visuals.add(shaft, head);
            group.add(visuals);
            group.userData = { visuals: visuals };
            return group;
        }

        // --- SCENE OBJECTS ---

        // Point P
        const pGroup = new THREE.Group();
        const pGeo = new THREE.SphereGeometry(0.5, 16, 16);
        const pMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const pMesh = new THREE.Mesh(pGeo, pMat);
        const labelP = createTextSprite("P", 3, "#ccc");
        labelP.position.y = 2;
        pGroup.add(pMesh, labelP);
        scene.add(pGroup);

        // Q1
        const q1Group = new THREE.Group();
        const qGeo = new THREE.IcosahedronGeometry(2.5, 1);
        const q1Mat = new THREE.MeshStandardMaterial({ color: 0xff6b6b, emissive: 0x550000 });
        const q1Mesh = new THREE.Mesh(qGeo, q1Mat);
        q1Mesh.castShadow = true;
        const labelQ1 = createTextSprite("Q₁ (+)", 3, "#ff6b6b");
        labelQ1.position.y = 4;
        q1Group.add(q1Mesh, labelQ1);
        q1Group.position.set(-15, 0, 0);
        scene.add(q1Group);

        // Q2
        const q2Group = new THREE.Group();
        const q2Mat = new THREE.MeshStandardMaterial({ color: 0x54a0ff, emissive: 0x002255 });
        const q2Mesh = new THREE.Mesh(qGeo, q2Mat);
        q2Mesh.castShadow = true;
        const labelQ2 = createTextSprite("Q₂ (-)", 3, "#54a0ff");
        labelQ2.position.y = 4;
        q2Group.add(q2Mesh, labelQ2);
        q2Group.position.set(15, 0, 0);
        scene.add(q2Group);
        q2Group.visible = false;

        // Vectors
        const arrowE1 = createArrow(0xff6b6b);
        const arrowE2 = createArrow(0x54a0ff);
        const arrowNet = createArrow(0xff9f43);

        scene.add(arrowE1);
        scene.add(arrowE2);
        scene.add(arrowNet);

        // Dashed Lines (for Parallelogram)
        const dashedMat = new THREE.LineDashedMaterial({
            color: 0xaaaaaa,
            dashSize: 1,
            gapSize: 0.5,
            opacity: 0.5,
            transparent: true,
            depthTest: false
        });

        const lineGeo1 = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]);
        const lineGeo2 = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]);

        const line1 = new THREE.Line(lineGeo1, dashedMat);
        const line2 = new THREE.Line(lineGeo2, dashedMat);

        // Compute distances for dashes to appear
        line1.computeLineDistances();
        line2.computeLineDistances();

        scene.add(line1);
        scene.add(line2);

        line1.visible = false;
        line2.visible = false;


        // ==========================================
        // PART 2: ANIMATION LOOP
        // ==========================================

        function getFieldVector(sourcePos, charge) {
            const rVec = new THREE.Vector3(0, 0, 0).sub(sourcePos);
            const r = rVec.length();
            if (r < 0.1) return new THREE.Vector3(0, 0, 0);

            const mag = K * Math.abs(charge) / (r * r);
            rVec.normalize();

            if (charge < 0) rVec.negate();

            return rVec.multiplyScalar(mag);
        }

        function updateArrow(arrowObj, vec, yOffset) {
            if (vec.length() < 0.1) {
                arrowObj.visible = false;
                return;
            }
            arrowObj.visible = true;

            // Apply vertical offset to prevent overlapping
            arrowObj.position.set(0, yOffset, 0);

            const dir = vec.clone().normalize();
            const axisX = new THREE.Vector3(1, 0, 0);
            const quat = new THREE.Quaternion().setFromUnitVectors(axisX, dir);
            arrowObj.quaternion.copy(quat);

            let len = vec.length();
            // Allow longer arrows for better visibility
            len = Math.min(len, 25);
            len = Math.max(len, 0.5);

            arrowObj.userData.visuals.scale.set(len, 1, 1);

            return len; // Return visual length
        }

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.02;

            // Bobbing animations
            q1Mesh.position.y = Math.sin(state.time) * 0.2;
            q2Mesh.position.y = Math.sin(state.time + 1) * 0.2;

            // Q2 Orbit logic
            const dist = 15;
            const x = Math.cos(state.angle) * dist;
            const z = Math.sin(state.angle) * dist;
            q2Group.position.set(x, 0, z);

            // 1. Calculate Vectors
            const E1 = getFieldVector(q1Group.position, Q1_CHARGE);
            const E2 = state.q2Visible ? getFieldVector(q2Group.position, Q2_CHARGE) : new THREE.Vector3(0, 0, 0);

            // 2. Update Source Arrows (Offset E1 down, E2 up)
            const len1 = updateArrow(arrowE1, E1, -0.2);
            let len2 = 0;

            if (state.q2Visible) {
                len2 = updateArrow(arrowE2, E2, 0.2);
                arrowE2.visible = true;
            } else {
                arrowE2.visible = false;
            }

            // 3. Update Resultant & Dashed Lines
            if (state.netVisible && state.q2Visible) {

                // Reconstruct visual vectors based on clamped lengths
                const dir1 = E1.clone().normalize();
                const visualVec1 = dir1.multiplyScalar(len1);

                const dir2 = E2.clone().normalize();
                const visualVec2 = dir2.multiplyScalar(len2);

                const visualNet = new THREE.Vector3().addVectors(visualVec1, visualVec2);

                // Net arrow sits at 0 elevation
                updateArrow(arrowNet, visualNet, 0);
                arrowNet.visible = true;

                // Draw Parallelogram Lines
                // Line 1: Tip of E1 -> Tip of Net
                const tip1Pos = visualVec1.clone();
                tip1Pos.y = -0.2; // Match Red Arrow height
                const netPos = visualNet.clone();

                line1.geometry.setFromPoints([tip1Pos, netPos]);
                line1.computeLineDistances();
                line1.visible = true;

                // Line 2: Tip of E2 -> Tip of Net
                const tip2Pos = visualVec2.clone();
                tip2Pos.y = 0.2; // Match Blue Arrow height

                line2.geometry.setFromPoints([tip2Pos, netPos]);
                line2.computeLineDistances();
                line2.visible = true;

            } else {
                arrowNet.visible = false;
                line1.visible = false;
                line2.visible = false;
            }

            renderer.render(scene, camera);
        }
        animate();

        // ==========================================
        // PART 3: LOGIC & NARRATIVE
        // ==========================================

        function introduceQ2() {
            state.q2Visible = true;
            q2Group.visible = true;
            document.getElementById('btn-add-q2').disabled = true;
            checkAdvance();
        }

        function showSum() {
            state.netVisible = true;
            document.getElementById('btn-sum').disabled = true;
            checkAdvance();
        }

        document.getElementById('slider-angle').addEventListener('input', (e) => {
            state.angle = parseFloat(e.target.value);
            checkAdvance();
        });

        function resetSim() {
            state.q2Visible = false;
            state.netVisible = false;
            state.angle = 0;

            q2Group.visible = false;

            document.getElementById('slider-angle').value = 0;
            document.getElementById('btn-add-q2').disabled = false;
            document.getElementById('btn-sum').disabled = false;

            loadLesson(0);
        }

        const lessons = [
            {
                title: "The First Source",
                text: "Observe the red vector <strong>E₁</strong>. It represents the electric field generated by the positive source <strong>Q₁</strong>. It points away from the source, extending out into space.<br><br>To see how complexity arises, we need to introduce a second source to the system.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-add-q2');
                },
                instruction: "Click 'Introduce Negative Charge (Q₂)' below.",
                check: () => state.q2Visible
            },
            {
                title: "Superposition of Fields",
                text: "A negative source <strong>Q₂</strong> has entered the system, creating a blue field vector <strong>E₂</strong>. Because Q₂ is negative, this field points inwards.<br><br>Notice that <strong>E₁</strong> (Red) remains exactly as it was. The two fields occupy the same point in space simultaneously without destroying each other. To understand the true effect on a particle at P, we must combine them.",
                setup: () => {
                    unlock('ctrl-sum');
                },
                instruction: "Click 'Compute E_net' to visualize the result.",
                check: () => state.netVisible
            },
            {
                title: "The Parallelogram Rule",
                text: "The actual electric field at point P is the <strong>Vector Sum</strong> of the individual fields. This is the Superposition Principle.<br><br>We visualize this using the <strong>Parallelogram Method</strong>. The dashed lines project from the tips of the red and blue vectors. The <strong style='color:#ff9f43'>Orange Resultant</strong> connects the origin to where these lines meet.",
                setup: () => {
                    lockAll();
                    unlock('ctrl-move');
                },
                instruction: "Drag the 'Orbit Position' slider to move Q₂.",
                check: () => state.angle > 0.5
            },
            {
                title: "Conclusion",
                text: "You have successfully visualized how electric fields combine.<br><br>By finding the geometric sum of individual vectors, we can determine the net force on any charge placed at point P, regardless of how many sources are present.<br><br>The orange vector represents the single, unified reality of the field at this point. But what happens if we look at this system from very far away? Does the detail matter, or do we see something simpler?",
                setup: () => { },
                instruction: "Experiment finished. Press Back to review or Reset.",
                check: () => true
            }
        ];

        function loadLesson(idx) {
            currentChapter = idx;
            const l = lessons[idx];
            document.querySelector('header .subtitle').innerText = `Module 2.${idx + 1}: ${l.title}`;
            document.getElementById('chapter-content').innerHTML =
                `<div class="chapter-title">${l.title}</div>
             <div class="story-text">
                ${l.text}
                <span class="instruction-highlight">Action: ${l.instruction}</span>
             </div>`;

            const btn = document.getElementById('btn-next');

            if (currentChapter === lessons.length - 1) {
                btn.innerHTML = "Next Lesson &rarr;";
                btn.disabled = false;
            } else {
                btn.innerHTML = "Next &rarr;";
                btn.disabled = !l.check();
            }

            l.setup();
        }

        function nextLesson() {
            if (currentChapter < lessons.length - 1) {
                loadLesson(currentChapter + 1);
            } else {
                window.top.location.href = '/theapplefalls/lesson/3_asymptotic_behaviorr';
            }
        }
        function prevLesson() {
            if (currentChapter > 0) loadLesson(currentChapter - 1);
        }
        function checkAdvance() {
            if (currentChapter >= lessons.length - 1) return;
            if (lessons[currentChapter].check()) {
                document.getElementById('btn-next').disabled = false;
            }
        }

        function lockAll() { document.querySelectorAll('.control-row').forEach(r => r.classList.remove('active')); }
        function unlock(id) { document.getElementById(id).classList.add('active'); }

        // Init
        loadLesson(0);

        // Resize
        window.addEventListener('resize', () => {
            const newAspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
            camera.left = -viewSize * newAspect / 2;
            camera.right = viewSize * newAspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
        });

    </script>
</body>

</html>